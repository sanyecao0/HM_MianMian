-- MySQL dump 10.13  Distrib 8.0.31, for Win64 (x86_64)
--
-- Host: localhost    Database: heima_mm
-- ------------------------------------------------------
-- Server version	8.0.31

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8mb4 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

CREATE DATABASE IF NOT EXISTS heima_mm CHARACTER SET utf8;

USE heima_mm;

--
-- Table structure for table `catalog`
--

DROP TABLE IF EXISTS `catalog`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `catalog` (
  `id` varchar(100) NOT NULL COMMENT '唯一标识Id',
  `name` varchar(50) DEFAULT NULL COMMENT '题目类型名称',
  `state` varchar(10) DEFAULT NULL COMMENT '状态            0 启用            1 禁用',
  `remark` varchar(2000) DEFAULT NULL COMMENT '备注',
  `courseId` varchar(100) DEFAULT NULL COMMENT '所属学科id',
  `createTime` datetime DEFAULT NULL COMMENT '添加时间',
  `updateTime` datetime DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`),
  KEY `FK_FK_course_catalog` (`courseId`),
  CONSTRAINT `FK_FK_course_catalog` FOREIGN KEY (`courseId`) REFERENCES `course` (`id`)
) COMMENT='题目类型表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `catalog`
--

LOCK TABLES `catalog` WRITE;
/*!40000 ALTER TABLE `catalog` DISABLE KEYS */;
INSERT INTO `catalog` VALUES ('1','Java基础','1','java编程的基础语法','1','2023-05-31 15:59:05','2023-05-31 15:59:05'),('2','JavaWeb','1','web开发入门','1','2023-05-31 15:59:05','2023-05-31 15:59:05'),('3','Spring MVC','1','Controller层框架','1','2023-05-31 15:59:05','2023-05-31 15:59:05'),('4','Spring boot','1','基于Spring的一个快速搭建项目的框架','1','2023-05-31 15:59:05','2023-05-31 15:59:05'),('5','Python基础','1','人生苦短，我用Python','2','2023-05-31 15:59:05','2023-05-31 15:59:05'),('6','函数编程','1','对重复代码的封装','1','2023-05-31 15:59:05','2023-05-31 15:59:05'),('7','面向对象编程','1','Java核心内容','2','2023-05-31 15:59:05','2023-05-31 15:59:05');
/*!40000 ALTER TABLE `catalog` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `company`
--

DROP TABLE IF EXISTS `company`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `company` (
  `id` varchar(50) NOT NULL COMMENT 'ID',
  `name` varchar(255) DEFAULT NULL COMMENT '公司名称',
  `expirationDate` datetime DEFAULT NULL COMMENT '到期时间',
  `address` varchar(255) DEFAULT NULL COMMENT '公司地址',
  `licenseId` varchar(255) DEFAULT NULL COMMENT '营业执照-图片',
  `representative` varchar(255) DEFAULT NULL COMMENT '法人代表',
  `phone` varchar(255) DEFAULT NULL COMMENT '公司电话',
  `companySize` varchar(255) DEFAULT NULL COMMENT '公司规模',
  `industry` varchar(255) DEFAULT NULL COMMENT '所属行业',
  `remarks` varchar(255) DEFAULT NULL COMMENT '备注',
  `state` int DEFAULT '1' COMMENT '状态',
  `city` varchar(20) DEFAULT NULL COMMENT '所在城市',
  `createTime` datetime DEFAULT NULL COMMENT '添加时间',
  `updateTime` datetime DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`)
)  COMMENT='企业表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `company`
--

LOCK TABLES `company` WRITE;
/*!40000 ALTER TABLE `company` DISABLE KEYS */;
INSERT INTO `company` VALUES ('1','北京淘宝网',NULL,'北京市朝阳区来广营','test','马老师','010-88888888','10000人以上','电子商务','',1,'北京','2023-05-31 15:59:29','2023-05-31 15:59:29'),('10','浪潮软件',NULL,'武汉市硚口区','test','刘老师','027-55555555','10000人以上','软件服务','',1,'武汉','2023-05-31 15:59:29','2023-05-31 15:59:29'),('12','简途旅行',NULL,'武汉市青山区','test','李总','027-6666666','1000人以上','旅游出行','',1,'武汉','2023-05-31 15:59:29','2023-05-31 15:59:29'),('13','绿盟科技',NULL,'武汉市青山区','test','赵老板','027-33333333','500人','软件服务','',1,'武汉','2023-05-31 15:59:29','2023-05-31 15:59:29'),('14','金信石',NULL,'北京市朝阳区望京','test','高总','010-22222222','800人','金融服务','',1,'北京','2023-05-31 15:59:29','2023-05-31 15:59:29'),('15','贵鑫堂',NULL,'武汉市青山区',NULL,NULL,NULL,NULL,NULL,NULL,1,'北京','2023-05-31 15:59:29','2023-05-31 15:59:29'),('16','掌众金服',NULL,'武汉市青山区',NULL,NULL,NULL,NULL,NULL,NULL,1,'北京','2023-05-31 15:59:29','2023-05-31 15:59:29'),('17','晨创科技',NULL,'北京市朝阳区望京',NULL,NULL,NULL,NULL,NULL,NULL,1,'北京','2023-05-31 15:59:29','2023-05-31 15:59:29'),('18','中软国际',NULL,'武汉市青山区',NULL,NULL,NULL,NULL,NULL,NULL,1,'北京','2023-05-31 15:59:29','2023-05-31 15:59:29'),('19','全景网',NULL,'北京市朝阳区望京',NULL,NULL,NULL,NULL,NULL,NULL,1,'北京','2023-05-31 15:59:29','2023-05-31 15:59:29'),('1fe4583e7cec4c08b7cd012b3c821196','黑马程序员','2020-10-30 00:00:00','武汉黄陂','test','张伟','13567896789','1','教育','审核通过',1,'湖北武汉','2023-05-31 15:59:29','2023-05-31 15:59:29'),('2','北京支付宝',NULL,'北京市朝阳区来广营',NULL,NULL,NULL,NULL,NULL,NULL,1,'上海','2023-05-31 15:59:29','2023-05-31 15:59:29'),('20','翼龙贷',NULL,'武汉市硚口区',NULL,NULL,NULL,NULL,NULL,NULL,1,'北京','2023-05-31 15:59:29','2023-05-31 15:59:29'),('21','中烟新商盟',NULL,'武汉市青山区',NULL,NULL,NULL,NULL,NULL,NULL,1,'北京','2023-05-31 15:59:29','2023-05-31 15:59:29'),('22','西安泰晟',NULL,'武汉市青山区',NULL,NULL,NULL,NULL,NULL,NULL,1,'北京','2023-05-31 15:59:29','2023-05-31 15:59:29'),('23','联创佳讯',NULL,'北京市朝阳区望京',NULL,NULL,NULL,NULL,NULL,NULL,1,'北京','2023-05-31 15:59:29','2023-05-31 15:59:29'),('24','神航星云',NULL,'武汉市青山区',NULL,NULL,NULL,NULL,NULL,NULL,1,'北京','2023-05-31 15:59:29','2023-05-31 15:59:29'),('25','软通动力',NULL,'北京市朝阳区望京',NULL,NULL,NULL,NULL,NULL,NULL,1,'北京','2023-05-31 15:59:29','2023-05-31 15:59:29'),('26','网众传媒',NULL,'武汉黄陂',NULL,NULL,NULL,NULL,NULL,NULL,1,'北京','2023-05-31 15:59:29','2023-05-31 15:59:29'),('27','软通动力',NULL,'北京市朝阳区来广营',NULL,NULL,NULL,NULL,NULL,NULL,1,'北京','2023-05-31 15:59:29','2023-05-31 15:59:29'),('28','文思海辉',NULL,'武汉市青山区',NULL,NULL,NULL,NULL,NULL,NULL,1,'北京','2023-05-31 15:59:29','2023-05-31 15:59:29'),('29','赞同科技',NULL,'武汉市青山区',NULL,NULL,NULL,NULL,NULL,NULL,1,'北京','2023-05-31 15:59:29','2023-05-31 15:59:29'),('3','北京蚂蚁金服',NULL,'北京市朝阳区望京',NULL,NULL,NULL,NULL,NULL,NULL,1,'上海','2023-05-31 15:59:29','2023-05-31 15:59:29'),('30','北正云鼎',NULL,'湖北武汉',NULL,NULL,NULL,NULL,NULL,NULL,1,'北京','2023-05-31 15:59:29','2023-05-31 15:59:29'),('31','信雅达',NULL,'北京市朝阳区望京',NULL,NULL,NULL,NULL,NULL,NULL,1,'北京','2023-05-31 15:59:29','2023-05-31 15:59:29'),('32','东方微银',NULL,'武汉黄陂',NULL,NULL,NULL,NULL,NULL,NULL,1,'北京','2023-05-31 15:59:29','2023-05-31 15:59:29'),('33','易宝软件',NULL,'北京市朝阳区来广营',NULL,NULL,NULL,NULL,NULL,NULL,1,'北京','2023-05-31 15:59:29','2023-05-31 15:59:29'),('34','智乾区块链',NULL,'武汉市青山区',NULL,NULL,NULL,NULL,NULL,NULL,1,'北京','2023-05-31 15:59:29','2023-05-31 15:59:29'),('35','中科金财',NULL,'武汉市青山区',NULL,NULL,NULL,NULL,NULL,NULL,1,'北京','2023-05-31 15:59:29','2023-05-31 15:59:29'),('4','七牛云服务',NULL,'北京市朝阳区望京',NULL,NULL,NULL,NULL,NULL,NULL,1,'上海','2023-05-31 15:59:29','2023-05-31 15:59:29'),('5','拼多多',NULL,'武汉黄陂',NULL,NULL,NULL,NULL,NULL,NULL,1,'上海','2023-05-31 15:59:29','2023-05-31 15:59:29'),('553137fe-a18d-4f26-9cb0-7aecaa59feb4','PUBG',NULL,'北京市朝阳区来广营','...','高磊','12312341234','奥利给','电子竞技','',1,'卢本超广场','2023-05-31 15:59:29','2023-05-31 15:59:29'),('6','唯品会',NULL,'武汉市硚口区',NULL,NULL,NULL,NULL,NULL,NULL,1,'上海','2023-05-31 15:59:29','2023-05-31 15:59:29'),('7','唯品会',NULL,'武汉市青山区',NULL,NULL,NULL,NULL,NULL,NULL,1,'广州','2023-05-31 15:59:29','2023-05-31 15:59:29'),('9','甲骨文培训',NULL,'北京市朝阳区望京','','','','','','',1,'深圳','2023-05-31 15:59:29','2023-05-31 15:59:29');
/*!40000 ALTER TABLE `company` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `course`
--

DROP TABLE IF EXISTS `course`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `course` (
  `id` varchar(100) NOT NULL COMMENT '学科id，主键',
  `name` varchar(50) DEFAULT NULL COMMENT '学科名称',
  `state` varchar(10) DEFAULT NULL COMMENT '状态：是否显示，0 显示，1 不显示',
  `remark` varchar(2000) DEFAULT NULL COMMENT '备注',
  `createTime` datetime DEFAULT NULL COMMENT '添加时间',
  `updateTime` datetime DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`)
) COMMENT='学科表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `course`
--

LOCK TABLES `course` WRITE;
/*!40000 ALTER TABLE `course` DISABLE KEYS */;
INSERT INTO `course` VALUES ('1','Java','1','目前最火的学科','2023-05-31 16:00:41','2023-05-31 16:00:41'),('2','Python','1','时下很流行的学科','2023-05-31 16:00:41','2023-05-31 16:00:41'),('3','大数据','1','很有钱景的学科','2023-05-31 16:00:41','2023-05-31 16:00:41'),('4','人工智能','1','当前很火的学科','2023-05-31 16:00:41','2023-05-31 16:00:41'),('5','Php','1','怎么翻译呢','2023-05-31 16:00:41','2023-05-31 16:00:41'),('6','C++','1','一个古老的学科','2023-05-31 16:00:41','2023-05-31 16:00:41');
/*!40000 ALTER TABLE `course` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `dept`
--

DROP TABLE IF EXISTS `dept`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `dept` (
  `id` varchar(40) NOT NULL COMMENT '唯一标识ID',
  `name` varchar(50) DEFAULT NULL COMMENT '部门名称',
  `parentId` varchar(40) DEFAULT NULL COMMENT '所属部门(父部门)',
  `state` decimal(6,0) DEFAULT NULL COMMENT '1代表启用，0代表停用，默认为1',
  `createTime` datetime DEFAULT NULL COMMENT '添加时间',
  `updateTime` datetime DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`),
  KEY `SYS_C005596` (`parentId`),
  CONSTRAINT `SYS_C005596` FOREIGN KEY (`parentId`) REFERENCES `dept` (`id`)
) COMMENT='部门表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `dept`
--

LOCK TABLES `dept` WRITE;
/*!40000 ALTER TABLE `dept` DISABLE KEYS */;
INSERT INTO `dept` VALUES ('100','集团总部',NULL,1,'2023-05-31 16:00:53','2023-05-31 16:00:53'),('100101','顺义校区','100',1,'2023-05-31 16:00:53','2023-05-31 16:00:53'),('100101101','顺义教研部','100101',1,'2023-05-31 16:00:53','2023-05-31 16:00:53'),('100101102','顺义人事部','100101',1,'2023-05-31 16:00:53','2023-05-31 16:00:53'),('100102','昌平校区','100',1,'2023-05-31 16:00:53','2023-05-31 16:00:53'),('100102101','昌平教研部','100102',1,'2023-05-31 16:00:53','2023-05-31 16:00:53'),('100102102','昌平学工部','100102',1,'2023-05-31 16:00:53','2023-05-31 16:00:53'),('100102103','昌平行政部','100102',1,'2023-05-31 16:00:53','2023-05-31 16:00:53'),('100103','总部研究院','100',1,'2023-05-31 16:00:53','2023-05-31 16:00:53'),('100104','总部总裁办公室','100',1,'2023-05-31 16:00:53','2023-05-31 16:00:53'),('100105','总部博学谷','100',1,'2023-05-31 16:00:53','2023-05-31 16:00:53'),('100106','总部人事部','100',1,'2023-05-31 16:00:53','2023-05-31 16:00:53'),('100107','总部财务部','100',1,'2023-05-31 16:00:53','2023-05-31 16:00:53');
/*!40000 ALTER TABLE `dept` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `examination_paper`
--

DROP TABLE IF EXISTS `examination_paper`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `examination_paper` (
  `id` varchar(100) NOT NULL,
  `memberId` varchar(100) DEFAULT NULL,
  `score` float DEFAULT NULL COMMENT '是否收藏：0.否 1.是',
  `state` int DEFAULT NULL COMMENT '存储用户答案选项',
  `createTime` datetime DEFAULT NULL,
  `applyTime` datetime DEFAULT NULL,
  PRIMARY KEY (`id`)
) COMMENT='会员试卷表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `examination_paper`
--

LOCK TABLES `examination_paper` WRITE;
/*!40000 ALTER TABLE `examination_paper` DISABLE KEYS */;
INSERT INTO `examination_paper` VALUES ('1','1',75,1,'2020-03-01 17:47:03','2020-03-01 19:47:07');
/*!40000 ALTER TABLE `examination_paper` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `examine_log`
--

DROP TABLE IF EXISTS `examine_log`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `examine_log` (
  `id` varchar(100) NOT NULL,
  `comments` varchar(100) DEFAULT NULL,
  `status` varchar(10) DEFAULT NULL COMMENT '审核状态            0 待审核            1 已审核            2 已拒绝',
  `questionId` varchar(100) NOT NULL,
  `userId` varchar(100) DEFAULT NULL COMMENT '审核人ID',
  `createTime` datetime DEFAULT NULL,
  `updateTime` datetime DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `FK_FK_examine_question` (`questionId`),
  CONSTRAINT `FK_FK_examine_question` FOREIGN KEY (`questionId`) REFERENCES `question` (`id`)
) COMMENT='审核日志表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `examine_log`
--

LOCK TABLES `examine_log` WRITE;
/*!40000 ALTER TABLE `examine_log` DISABLE KEYS */;
INSERT INTO `examine_log` VALUES ('01406E951164496CBA7A29FC91DF5246','1112527','1','01406E951164496CBA7A29FC91DF5246',NULL,NULL,NULL),('1','没有选项','-1','1',NULL,'2020-03-07 12:18:01',NULL);
/*!40000 ALTER TABLE `examine_log` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `member`
--

DROP TABLE IF EXISTS `member`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `member` (
  `id` varchar(100) NOT NULL,
  `nick_name` varchar(50) DEFAULT NULL,
  `avatar_url` text,
  `gender` varchar(10) DEFAULT NULL,
  `age` int DEFAULT NULL,
  `birthday` datetime DEFAULT NULL,
  `email` varchar(50) DEFAULT NULL,
  `telephone` varchar(50) DEFAULT NULL,
  `address` varchar(200) DEFAULT NULL,
  `registerDate` datetime DEFAULT NULL,
  `remark` varchar(1000) DEFAULT NULL,
  `state` varchar(10) DEFAULT NULL,
  PRIMARY KEY (`id`)
) COMMENT='会员表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `member`
--

LOCK TABLES `member` WRITE;
/*!40000 ALTER TABLE `member` DISABLE KEYS */;
INSERT INTO `member` VALUES ('1','黑马小孩',NULL,'male',22,'1995-07-20 17:27:30','xiaohai@163.com','13567890123','北京','2020-03-02 17:28:13',NULL,'1'),('2','初入江湖',NULL,'male',23,'1995-07-20 17:27:30','test@sina.com','13254789021','山东','2020-03-02 17:28:13',NULL,'0');
/*!40000 ALTER TABLE `member` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `member_question`
--

DROP TABLE IF EXISTS `member_question`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `member_question` (
  `id` varchar(100) NOT NULL,
  `questionId` varchar(100) DEFAULT NULL,
  `examinationpaperId` varchar(100) DEFAULT NULL,
  `answerResult` varchar(10) DEFAULT NULL COMMENT '存储用户答案选项',
  `rightAnswer` varchar(10) DEFAULT NULL COMMENT '是否收藏：0.否 1.是',
  PRIMARY KEY (`id`)
) COMMENT='会员答题表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `member_question`
--

LOCK TABLES `member_question` WRITE;
/*!40000 ALTER TABLE `member_question` DISABLE KEYS */;
INSERT INTO `member_question` VALUES ('1','1','1','1','1');
/*!40000 ALTER TABLE `member_question` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `module`
--

DROP TABLE IF EXISTS `module`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `module` (
  `id` varchar(40) NOT NULL COMMENT '模块id，主键',
  `parentId` varchar(40) DEFAULT NULL COMMENT '父模块id',
  `name` varchar(100) DEFAULT NULL COMMENT '模块名称',
  `curl` varchar(200) DEFAULT NULL COMMENT '模块的访问地址',
  `ctype` decimal(11,0) DEFAULT NULL COMMENT '模块类型：0 一级菜单/1 二级菜单',
  `state` decimal(11,0) DEFAULT NULL COMMENT '状态：1启用，0停用',
  `remark` varchar(100) DEFAULT NULL COMMENT '备注信息',
  `createTime` datetime DEFAULT NULL COMMENT '添加时间',
  `updateTime` datetime DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`)
) COMMENT='模块表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `module`
--

LOCK TABLES `module` WRITE;
/*!40000 ALTER TABLE `module` DISABLE KEYS */;
INSERT INTO `module` VALUES ('1',NULL,'平台系统管理','system',0,1,'system','2023-05-31 16:01:03','2023-05-31 16:01:03'),('101','1','企业管理','/system/company?operation=list',1,1,'企业增删改查','2023-05-31 16:01:03','2023-05-31 16:01:03'),('102','1','部门管理','/system/dept?operation=list',1,1,'部门增删改查','2023-05-31 16:01:03','2023-05-31 16:01:03'),('103','1','用户管理','/system/user?operation=list',1,1,'用户增删改查','2023-05-31 16:01:03','2023-05-31 16:01:03'),('104','1','角色管理','/system/role?operation=list',1,1,'角色增删改查','2023-05-31 16:01:03','2023-05-31 16:01:03'),('105','1','模块管理','/system/module?operation=list',1,1,'模块增删改查','2023-05-31 16:01:03','2023-05-31 16:01:03'),('106','1','系统日志管理','/system/sysLog?operation=list',1,1,'系统日志增删改查','2023-05-31 16:01:03','2023-05-31 16:01:03'),('2',NULL,'题库管理','store',0,1,'store','2023-05-31 16:01:03','2023-05-31 16:01:03'),('201','2','题目学科管理','/store/course?operation=list',1,1,'学科增删改查','2023-05-31 16:01:03','2023-05-31 16:01:03'),('202','2','题目类型管理','/store/catalog?operation=list',1,1,'题目类型增删改查','2023-05-31 16:01:03','2023-05-31 16:01:03'),('203','2','题目管理','/store/question?operation=list',1,1,'题目增删改查','2023-05-31 16:01:03','2023-05-31 16:01:03'),('204','2','题目审核日志','/store/examineLog?operation=list',1,1,'题目审核日志增删改查','2023-05-31 16:01:03','2023-05-31 16:01:03'),('3',NULL,'会员管理','member',0,1,'front','2023-05-31 16:01:03','2023-05-31 16:01:03'),('301','3','会员账号管理','/front/member?operation=list',1,1,'会员增删改查','2023-05-31 16:01:03','2023-05-31 16:01:03'),('302','3','会员答题管理','/front/examinationPaper?operation=list',1,1,'会员答题增删改查','2023-05-31 16:01:03','2023-05-31 16:01:03');
/*!40000 ALTER TABLE `module` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `question`
--

DROP TABLE IF EXISTS `question`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `question` (
  `id` varchar(100) NOT NULL,
  `catalogId` varchar(100) NOT NULL COMMENT '题目类型id',
  `subject` varchar(200) DEFAULT NULL COMMENT '题干',
  `type` varchar(10) DEFAULT NULL COMMENT '题目类型： 1. 单选  2. 多选 3. 简答',
  `difficulty` varchar(10) DEFAULT NULL COMMENT '难度：1 简单，2 一般 ，3 困难',
  `picture` varchar(100) DEFAULT NULL COMMENT '题目图片url地址',
  `analysis` varchar(2000) DEFAULT NULL COMMENT '答案解析',
  `remark` varchar(100) DEFAULT NULL COMMENT '备注信息',
  `isClassic` varchar(10) DEFAULT NULL COMMENT '是否精选题目：0，不是  1，是',
  `state` varchar(10) DEFAULT NULL COMMENT '题目状态，1：启用，0：禁用',
  `reviewStatus` varchar(10) DEFAULT '0' COMMENT '审核状态：  0 待审核 1 审核通过,-1 审核不通过',
  `companyId` varchar(50) DEFAULT NULL COMMENT '企业id',
  `createTime` datetime DEFAULT NULL COMMENT '添加时间',
  `updateTime` datetime DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`),
  KEY `FK_FK_question_catalog` (`catalogId`),
  KEY `FK_Reference_16` (`companyId`),
  CONSTRAINT `FK_FK_question_catalog` FOREIGN KEY (`catalogId`) REFERENCES `catalog` (`id`),
  CONSTRAINT `FK_Reference_16` FOREIGN KEY (`companyId`) REFERENCES `company` (`id`)
) COMMENT='题目表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `question`
--

LOCK TABLES `question` WRITE;
/*!40000 ALTER TABLE `question` DISABLE KEYS */;
INSERT INTO `question` VALUES ('01406E951164496CBA7A29FC91DF5246','1','这是一道测试题','1','1',NULL,'测试','test','1','1','1','1','2022-08-21 17:21:16','2022-08-21 17:21:16'),('1','1','springmvc，mybatis的执行流程，spring中事物的管理','3','1',NULL,'springmvc执行流程：1.spring mvc将所有的请求都提交给DispatcherServlet,它会委托应用系统的其他模块负责对请求 进行真正的处理工作。2.DispatcherServlet查询一个或多个HandlerMapping,找到处理请求的Controller.3.DispatcherServlet请请求提交到目标Controller4.Controller进行业务逻辑处理后，会返回一个ModelAndView5.Dispathcher查询一个或多个ViewResolver视图解析器,找到ModelAndView对象指定的视图对象6.视图对象负责渲染返回给客户端。二：mybatis执行流程1加载配置并初始化2接收调用请求3处理操作请求 触发条件：API接口层传递请求过来(A)根据SQL的ID查找对应的MappedStatement对象。(B)根据传入参数对象解析Mapp',NULL,'1','1','0','1','2023-05-25 13:27:14','2023-05-25 13:27:14'),('10','3','简单说明requests.content和requests.text的区别','3','3',NULL,'requests.text返回的是Unicode类型的数据，如果想获取文本，可以使用request.textrequests.content返回的是bytes类型的数据，也就是二进制类型的数据，如果想获取图片，文件，则可以使用requests.content',NULL,'1','1','1','3','2023-03-25 11:22:14','2023-03-25 11:22:14'),('100','2','OOM你遇到过哪些情况？你是怎么搞定的？','3','2',NULL,'如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄漏对象时通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收。如果不存在泄漏，那就应该检查虚拟机的参数(-Xmx与-Xms)的设置是否适当。b. 虚拟机栈和本地方法栈溢出如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。如果虚拟机在扩展栈时无法申请到足够的内存空间，则抛出OutOfMemoryError异常这里需要注意当栈的大小越大可分配的线程数就越少。c. 运行时常量池溢出异常信息：java.lang.OutOfMemoryError:PermGen space如果要向运行时常量池中添加内容，最简单的做法就是使用Stri',NULL,'1','1','1','2','2023-03-25 11:22:14','2023-03-25 11:22:14'),('101','2','arralylist的扩容问题','3','1',NULL,'1、ArrayList的原始大小size + 将要插入集合的大小numNew = 得到扩充后ArrayList的最小长度minCapacity2、如果ArrayList的原始大小size为0，即ArrayList为空，ArrayList扩充后的最小长度minCapacity= Math.max(10, minCapacity)，也就是说扩充后的最小长度minCapacity，并不仅仅是原始长度size加上插入集合的长度numNew。3、上面得到的扩充后最小长度minCapacity，并不是最终扩充后的长度，还需要进一步进行计算。（1）得到ArrayList的原始大小oldCapacity（2）得到新的扩充后的大小：newCapacity = oldCapacity*1.5；（3）将上面计算的扩充后的最小长度minCapacity与这里得到的扩充后的大小newCapacity进行比较，取较大的那个最为最终扩充后的大小。',NULL,'1','1','1','2','2023-02-25 16:21:16','2023-02-25 16:21:16'),('102','2','scrapy的异步处理','3','1',NULL,'scrapy框架的异步机制是基于twisted异步网络框架处理的，在settings.py文件里可以设置具体的并发量数值（默认是并发量16）。',NULL,'1','1','1','2','2022-08-21 17:21:16','2022-08-21 17:21:16'),('103','2','synchronized 和 ReentrantLock 有什么不同','3','2',NULL,'时，首先要尝试获取对象锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象锁，把锁的计算器加1，相应的，在执行monitorexit指令时会将锁计算器就减1，当计算器为0时，锁就被释放了。如果获取对象锁失败，那当前线程就要阻塞，直到对象锁被另一个线程释放为止。c. ReentrantLock由于ReentrantLock是java.util.concurrent包下提供的一套互斥锁，相比Synchronized，ReentrantLock类提供了一些高级功能，主要有以下3项：1.等待可中断，持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，这相当于Synchronized来说可以避免出现死锁的情况。2.公平锁，多个线程等待同一个锁时，必须按照申请',NULL,'1','1','1','2','2023-05-26 10:22:16','2023-05-26 10:22:16'),('104','2','hash碰撞','3','2',NULL,'（1）开放地址法 （2）拉链法 （3）再哈希法 （4）建立公共溢出区',NULL,'1','1','1','2','2023-03-25 11:22:14','2023-03-25 11:22:14'),('105','2','Error 和 Exception有什么区别','3','2',NULL,'Error类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢出等。如java.lang.StackOverFlowError和Java.lang.OutOfMemoryError。对于这类错误，Java编译器不去检查他们。对于这类错误的导致的应用程序中断，仅靠程序本身无法恢复和预防，遇到这样的错误，建议让程序终止。Exception类表示程序可以处理的异常，可以捕获且可能恢复。遇到这类异常，应该尽可能处理异常，使程序恢复运行，而不应该随意终止异常。',NULL,'1','1','1','2','2023-03-25 11:22:14','2023-03-25 11:22:14'),('106','2','闭包的作用域','3','2',NULL,'先来谈谈变量的作用域变量的作用域无非就是两种：全局变量和局部变量。全局作用域：最外层函数定义的变量拥有全局作用域，即对任何内部函数来说，都是可以访问的：',NULL,'1','1','1','2','2023-03-25 11:22:14','2023-03-25 11:22:14'),('107','2','Post和get区别','3','2',NULL,'get:从指定的服务器中获取数据。GET请求能够被缓存GET请求会保存在浏览器的浏览记录中以GET请求的URL能够保存为浏览器书签GET请求有长度限制GET请求主要用以获取数据post:POST请求不能被缓存下来POST请求不会保存在浏览器浏览记录中以POST请求的URL无法保存为浏览器书签POST请求没有长度限制POST请求会把请求的数据放置在HTTP请求包的包体中,POST的安全性比GET的高.可能修改变服务器上的资源的请求.',NULL,'1','1','1','2','2023-03-25 11:22:14','2023-03-25 11:22:14'),('108','2','什么是 异常链','3','2',NULL,'a.常常会再捕获一个异常后跑出另外一个异常，并且希望把异常原始信息保存下来，这被称为异常链。b.在JDK1.4以前，程序员必须自己编写代码来保存原始异常信息，c.现在所有Throwable的子类子构造器中都可以接受一个cause对象作为参数，这个cause就异常原由，代表着原始异常，即使在当前位置创建并抛出行的异常，也可以通过这个cause追踪到异常最初发生的位置。d.Throwable类及其所有的子类都提供了带cause参数的构造器，其他的异常类就只有通过initCause()来设置cause了。',NULL,'1','1','1','2','2023-03-25 11:22:14','2023-03-25 11:22:14'),('109','2','悲观锁和乐观锁？','3','3',NULL,'悲观锁(PessimisticLock),顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。乐观锁(OptimisticLock),顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐观锁。',NULL,'1','1','1','2','2023-03-25 11:22:14','2023-03-25 11:22:14'),('11','1','反爬虫措施？','3','4',NULL,'通过Headers反爬虫：从用户请求的Headers反爬虫是最常见的反爬虫策略。很多网站都会对Headers的User-Agent进行检测，还有一部分网站会对Referer进行检测（一些资源网站的防盗链就是检测Referer）。如果 遇到了这类反爬虫机制，可以直接在爬虫中添加Headers，将浏览器的User-Agent复制到爬虫的 Headers中；或者将Referer值修改为目标网站域名。对于检测Headers的反爬虫，在爬虫中修改或 者添加Headers就能很好的绕过。 基于用户行为反爬虫： 还有一部分网站是通过检测用户行为，例如同一IP短时间内多次访问同一页面，或者同一账户短时 间内多次进行相同操作。 大多数网站都是前一种情况，对于这种情况，使用IP代理就可以解决。可以专门写一个爬虫，爬取 网上公开的代理ip，检测后全部保存起来。这样的代理ip爬虫经常会用到，最好自己准备一个。有了 大量代理ip后可以每请求几次更',NULL,'1','0','0','3','2023-05-25 13:27:14','2023-05-25 13:27:14'),('110','2','并发线程的应用','3','2',NULL,'1、吞吐量：你做WEB，容器帮你做了多线程，但是他只能帮你做请求层面的。简单的说，可能就是一个请求一个线程。或多个请求一个线程。如果是单线程，那同时只能处理一个用户的请求。2、伸缩性：也就是说，你可以通过增加CPU核数来提升性能。如果是单线程，那程序执行到死也就利用了单核，肯定没办法通过增加CPU核数来提升性能。',NULL,'1','1','1','2','2023-03-25 11:22:14','2023-03-25 11:22:14'),('111','2','java中有哪些锁','3','3',NULL,'java重要有这些锁：偏向锁、轻量级锁、重量级锁、读写锁、重入锁、共享锁、独占锁、自旋锁、公平锁、非公平锁、死锁、活锁',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('112','2','Celery中broker的功能，异步任务的原理？','3','3',NULL,'Celery的broker其实通常是指消息队列，对消息进行接收和分发一个对象。异步任务原理本质上是把每个任务解耦，利用多进程、多线程、协程执行任务',NULL,'1','1','1','2','2022-08-21 17:21:16','2022-08-21 17:21:16'),('113','2','库存超发怎么解决？','3','3',NULL,'1.悲观锁锁表。2.采用乐观锁，数据库设置版本号字段，增减库存的时候，通过判断版本号来减库存',NULL,'1','1','1','2','2023-05-26 10:22:16','2023-05-26 10:22:16'),('114','2','冒泡排序、二分算法','3','2',NULL,'1.冒泡排序解析：1.比较相邻的两个元素，如果前一个比后一个大，则交换位置。　　　2.第一轮的时候最后一个元素应该是最大的一个。　　　3.按照步骤一的方法进行相邻两个元素的比较，这个时候由于最后一个元素已经是最大的了，所以最后一个元素不用比较。2.二分查找解析：二分查找，也为折半查找。首先要找到一个中间值，通过与中间值比较，大的放又，小的放在左边。再在两边中寻找中间值，持续以上操作，直到找到所在位置为止。（1）递归方法（2）非递归方法',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('115','2','什么是重入锁','3','3',NULL,'举个例子可能更容易理解，如果线程A获取到了锁S，线程A再次进入的时候任然可以获取到锁S，只不过是获取锁的次数会增加1，java中的Lock锁的实现类ReentrantLock就是一个可重入锁，它具体的实现是更具AQS框架来实现的，AQS实现锁的本质是通过CAS算法实现的，CAS的优点是减少线程时间的切换，提高了效率，缺点是会出现ABA问题',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('116','2','把session放到redis我为什么要这样干？','3','2',NULL,'解决分布式系统session不能共享的问题',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('117','2','说下你对nginx的理解？','3','2',NULL,'1放置静态资源，（html+js+css+图片），2实现负载均衡。3反向代理',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('118','2','ABA问题怎么解决','3','3',NULL,'ABA问题是指在CAS操作时，其他线程将变量值A改为了B，但是又被改回了A，等到本线程使用期望值A与当前变量进行比较时，发现变量A没有变，于是CAS就将A值进行了交换操作，但是实际上该值已经被其他线程改变过，这与乐观锁的设计思想不符合。ABA问题的解决思路是，每次变量更新的时候把变量的版本号加1，那么A-B-A就会变成A1-B2-A3，只要变量被某一线程修改过，改变量对应的版本号就会发生递增变化，从而解决了ABA问题',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('119','2','数据库分页我要第二页的十条数据该怎么写？','3','1',NULL,'select*fromtablelimit10,10',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('12','3','加入Redis里面有1亿个key，其中10w个key是以某个固定的一直的前缀开头的，如何将他们全部找出来。','3','5',NULL,'使用keys指令可以扫出指定模式的key列表。对方接着追问：如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？这个时候你要回答redis关键的一个特性：redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。',NULL,'1','0','0','2','2022-08-21 17:21:16','2022-08-21 17:21:16'),('122','2','工作流由哪些主要结构组成？','3','2',NULL,'Activiti工作流引擎数据库表结构数据库表的命名Acitiviti数据库中表的命名都是以ACT_开头的。第二部分是一个两个字符用例表的标识。此用例大体与服务API是匹配的。l ACT_RE_*:&rsquo;RE&rsquo;表示repository。带此前缀的表包含的是静态信息，如，流程定义，流程的资源（图片，规则等）。l ACT_RU_*:&rsquo;RU&rsquo;表示runtime。这是运行时的表存储着流程变量，用户任务，变量，职责（job）等运行时的数据。Activiti只存储实例执行期间的运行时数据，当流程实例结束时，将删除这些记录。这就保证了这些运行时的表小且快。l ACT_ID_*:&rsquo;ID&rsquo;表示identity。这些表包含标识的信息，如用户，用户组，等等。l ACT_HI_*:&rsquo;HI&rsquo;表示history。就是这些表包含着历史的相关数据，如结束的流程实例，变量，任务，等',NULL,'1','1','1','2','2022-08-21 17:21:16','2022-08-21 17:21:16'),('123','2','假如现在有10万条电话号码的数据，怎么能导入到redis服务器中？需要考虑什么问题吗？','3','3',NULL,'这个必须要考虑内存溢出的问题，我们可以不考虑效率，因为这些数据都是提前导入到系统中的，考虑到内存溢出，我们可以创建一个阻塞队列，把数据读入到阻塞队列中，然后从阻塞队列中把数据在导入到redis服务器中',NULL,'1','1','1','2','2023-05-26 10:22:16','2023-05-26 10:22:16'),('126','2','Tomcat内存参数在哪个文件配置?tomcat 端口号在哪个文件配置？','3','2',NULL,'/bin/catalina.bat server.xml',NULL,'1','1','1','2','2022-08-21 17:21:16','2022-08-21 17:21:16'),('127','2','是否了解连接池，使用连接池有什么好处？','3','2',NULL,'数据库连接是非常消耗资源的，影响到程序的性能指标。连接池是用来分配、管理、释放数据库连接的，可以使应用程序重复使用同一个数据库连接，而不是每次都创建一个新的数据库连接。通过释放空闲时间较长的数据库连接避免数据库因为创建太多的连接而造成的连接遗漏问题，提高了程序性能',NULL,'1','1','1','2','2022-08-21 17:21:16','2022-08-21 17:21:16'),('128','2','Django中 使用celery发送邮件 发送不出去，怎么解决？','3','5',NULL,'Celery 自带消息队列 发送成功会有回调功能 判断是否发送成功 如果成功就会删除消息队列的东西 如果不成功 他会接着发还有一种情况就是 公司邮箱本身有问题 差文档多健 日志 多分析',NULL,'1','1','1','2','2022-08-21 17:21:16','2022-08-21 17:21:16'),('129','2','1.Iterator和ListIterator的区别是什么？','3','2',NULL,'1.ListIterator只能用于List，Iterator是通用的2.Iterator容易引起并发修改异常问题，而ListIterator可以避免线程安全问题的发生，因为其有内置的add()等修改集合的方法3. ListIterator和Iterator都有hasNext()和next()方法，可以实现顺序向后遍历，但是ListIterator有hasPrevious()和previous()方法，可以实现逆向（顺序向前）遍历。Iterator就不可以。4. ListIterator可以定位当前的索引位置，nextIndex()和previousIndex()可以实现。Iterator没有此功能。5. 都可实现删除对象，但是ListIterator可以实现对象的修改，set()方法可以实现。Iierator仅能遍历，不能修改。',NULL,'1','1','1','2','2022-08-21 17:21:16','2022-08-21 17:21:16'),('13','1','Redis是多进程还是多线程的，简单描述redis数据库对于线程的管理机制','3','3',NULL,'单线程指的是网络请求模块使用了一个线程（所以不需考虑并发安全性），即一个线程处理所有网络请求，其他模块仍用了多个线程。redis实际上是采用了线程封闭的观念，把任务封闭在一个线程，自然避免了线程安全问题，不过对于需要依赖多个redis操作的复合操作来说，依然需要锁，而且有可能是分布式锁。','','1','1','-1','4','2023-05-26 10:22:16','2023-05-31 15:45:54'),('130','2','闭包的解释','','2','2b0bd738-2cf7-46c4-8152-c575b79bf4aa.png','一个拥有许多变量和绑定了这些变量的环境的表达式（通常是一个函数），因而这些变量也是该表达式的一部分。闭包的特点：　　1.作为一个函数变量的一个引用，当函数返回时，其处于激活状态。　　2.一个闭包就是当一个函数返回时，一个没有释放资源的栈区。　　简单的说，Javascript允许使用内部函数---即函数定义和函数表达式位于另一个函数的函数体内。而且，这些内部函数可以访问它们所在的外部函数中声明的所有局部变量、参数和声明的其他内部函数。当其中一个这样的内部函数在包含它们的外部函数之外被调用时，就会形成闭包。','','1','1','0','2','2023-05-26 10:22:16','2023-06-01 09:18:27'),('131','2','Java 中怎么获取一份线程 dump 文件？','3','2',NULL,'指令获取： jstack -l pid。【抓dump】1、一般抓法adplus -hang -p 3230 -quiet 抓3230 pid进程，hang模式，相当于把那个进程暂停住，取内存快照adplus -crash -pn w3wp -quiet 抓w3wp进程，crash模式，当那个进程崩溃结束的时候自动抓取当时的内存adplus -hang -iis -quiet 抓IIS相关进程，包括其上host的web应用，以及iis自身2、抓window服务3、远程抓',NULL,'1','1','1','2','2023-05-26 10:22:16','2023-05-26 10:22:16'),('133','2','vue的优点是什么？','3','2',NULL,'(1)低耦合。视图（View）可以独立于Model变化和修改，一个ViewModel可以绑定到不同的&quot;View&quot;上，当View变化的时候Model可以不变，当Model变化的时候View也可以不变。(2)可重用性。你可以把一些视图逻辑放在一个ViewModel里面，让很多view重用这段视图逻辑。(3)独立开发。开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计，使用Expression Blend可以很容易设计界面并生成xml代码。(4)可测试。界面素来是比较难于测试的，而现在测试可以针对ViewModel来写。(5)组件之间的传值(6)路由之间跳转',NULL,'1','1','1','2','2023-05-26 10:22:16','2023-05-26 10:22:16'),('134','2','高并发情况下提升页面加载速度的方案？','3','3',NULL,'高并发是什么？简单点说，就是同一时间内，大量的请求服务器，这个大量一般是指千万级以上的请求次数。不要被&ldquo;高并发&rdquo;这3个字吓到，一个系统真正需要高并发的地方并不多，可能是一个接口或者几个接口，但这部分功能很重要。1.Nginx要做负载均衡2.程序层面做多线程，锁等机制3.数据库层面处理，mysql+redis4.服务器配置要尽量高',NULL,'1','1','1','2','2023-05-26 10:22:16','2023-05-26 10:22:16'),('135','2','Tcp协议和udp协议有什么区别？','3','2',NULL,'（1）TCP面向连接（如打电话要先拨号建立连接）;UDP是无连接的，即发送数据之前不需要建立连接（2）每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信（3）TCP首部开销20字节;UDP的首部开销小，只有8个字节（4）TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道',NULL,'1','1','1','2','2023-05-26 10:22:16','2023-05-26 10:22:16'),('136','2','超卖情况的解决？','3','5',NULL,'1000个人同时秒杀10 份商品，用队列的方式储存10 个，如果超过 10 条,直接已结束返回页面给用户，如果没有超过10 条，则用户可进入填写，订单及确认页面。',NULL,'1','1','1','2','2023-05-26 10:22:16','2023-05-26 10:22:16'),('137','2','Vector,ArrayList,LinkedList之间的区别','3','2',NULL,'(1)同步性ArrayList,LinkedList是不同步的，而Vestor是同步的。所以如果不要求线程安全的话，可以使用ArrayList或LinkedList，可以节省为同步而耗费的开销。但在多线程的情况下，有时候就不得不使用Vector了。当然，也可以通过一些办法包装ArrayList,LinkedList，使他们也达到同步，但效率可能会有所降低。(2)数据增长从内部实现机制来讲ArrayList和Vector都是使用Objec的数组形式来存储的。当你向这两种类型中增加元素的时候，如果元素的数目超出了内部数组目前的长度它们都需要扩展内部数组的长度，Vector缺省情况下自动增长原来一倍的数组长度，ArrayList是原来的50%,所以最后你获得的这个集合所占的空间总是比你实际需要的要大。所以如果你要在集合中保存大量的数据那么使用Vector有一些优势，因为你可以通过设置集合的初始化大小来避免不必要的资源开销。(3)检索、插入、删除对象的效率ArrayList和Vecto',NULL,'1','1','1','2','2023-05-26 10:22:16','2023-05-26 10:22:16'),('138','2','mysql事务的特性','3','1',NULL,'（1）原子性(Atomicity)：事务中的全部操作在数据库中是不可分割的，要么全部完成，要么均不执行。（2）一致性(Consistency)：几个并行执行的事务，其执行结果必须与按某一顺序串行执行的结果相一致。（3）隔离性(Isolation)：事务的执行不受其他事务的干扰，事务执行的中间结果对其他事务必须是透明的。（4）持久性(Durability)：对于任意已提交事务，系统必须保证该事务对数据库的改变不被丢失，即使数据库出现故障',NULL,'1','1','1','2','2023-05-26 10:22:16','2023-05-26 10:22:16'),('139','2','你对乐观锁和悲观锁有了解吗？','3','2',NULL,'悲观锁(Pessimistic Lock), 顾名思义，就是很悲观，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会block直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）。    乐观锁(Optimistic Lock), 顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库如果提供类似于write_condition机制的其实都是提供的乐',NULL,'1','1','1','2','2023-05-26 10:22:16','2023-05-26 10:22:16'),('14','4','redis相比memcached有哪些优势','3','3',NULL,'Redis在很多方面具备数据库的特征，或者说就是一个数据库系统，而Memcache只是简单的K/V缓存。 如果要说内存使用效率，使用简单的key-value存储的话，Memcached的内存利用率更高，而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcache。当然，这和你的应用场景和数据特性有关。 如果你对数据持久化和数据同步有所要求，那么推荐你选择Redis，因为这两个特性Memcache都不具备。即使你只是希望在升级或者重启系统后缓存数据不会丢失，选择Redis也是明智的。',NULL,'0','0','0','4','2023-05-25 13:27:14','2023-05-25 13:27:14'),('140','2','redis和mysql的区别','3','3',NULL,'readis是内存数据库，数据保存在内存中，速度快。mysql是关系型数据库，持久化存储，存放在磁盘里面，功能强大。检索的话，会涉及到一定的IO，数据访问也就慢。',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('141','2','什么是视图？以及视图的使用场景有哪些？','3','2',NULL,'视图是一种基于数据表的一种虚表。(1)视图是一种虚表。(2)视图建立在已有表的基础上, 视图赖以建立的这些表称为基表。(3)向视图提供数据内容的语句为 SELECT 语句,可以将视图理解为存储起来的 SELECT 语句。(4)视图向用户提供基表数据的另一种表现形式。(5)视图没有存储真正的数据，真正的数据还是存储在基表中。(6)程序员虽然操作的是视图，但最终视图还会转成操作基表。(7)一个基表可以有0个或多个视图有的时候，我们可能只关系一张数据表中的某些字段，而另外的一些人只关系同一张数据表的某些字段...那么把全部的字段都都显示给他们看，这是不合理的。我们应该做到：他们想看到什么样的数据，我们就给他们什么样的数据...一方面就能够让他们只关注自己的数据，另一方面，我们也保证数据表一些保密的数据不会泄露出来...我们在查询数据的时候，常常需要编写非常长的SQL语句，几乎每次都要写很长很长....上面已经说了，视图就是基于查询的一种虚表，也就是说，视图可以将查询出来的数据进行封装。。。那么我们在使用的时候就会变得非常方便...值得注意的是：使用视图可以让我们专注与逻辑，但不提高查询',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('142','2','对事物的理解，怎么应用的，为什么使用事务','3','2',NULL,' Atomic（原子性）：事务中的所有元素作为一个整体提交或回滚，事务的个元素是不可分的，事务是一个完整操作。 Consistency（一致性）：只有合法的数据可以被写入数据库，否则事务应该将其回滚到最初状态。事物完成时和事物开始之前，数据存储中的数据处于一致状态。保证数据的无损。 Isolation（隔离性）：事务允许多个用户对同一个数据进行并发访问，而不破坏数据的正确性和完整性。同时，并行事务的修改必须与其他并行事务的修改相互独立。事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。 Durability（持久性）：事务结束后，事务处理的结果必须能够得到固化。它对于系统的影响是永久性的。该修改即使出现致命的系统故障也将',NULL,'1','1','1','2','2022-08-21 17:21:16','2022-08-21 17:21:16'),('144','2','数据库优化方案','3','3',NULL,'优化索引、SQL语句、分析慢查询设计表的时候严格根据数据库的设计范式来设计数据库使用缓存，把经常访问到的数据而且不需要经常变化的数据放在缓存中，能节约磁盘IO优化硬件；采用SSD，使用磁盘队列技术(RAID0,RAID1,RDID5)等；采用MySQL内部自带的表分区技术，把数据分层不同的文件，能够提高磁盘的读取效率垂直分表；把一些不经常读的数据放在一张表里，节约磁盘I/O主从分离读写；采用主从复制把数据库的读操作和写入操作分离开来分库分表分机器（数据量特别大），主要的的原理就是数据路由选择合适的表引擎，参数上的优化进行架构级别的缓存，静态化和分布式不采用全文索引',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('145','2','事物的传播行为','3','2',NULL,'1、PROPAGATION_REQUIRED：如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。2、PROPAGATION_SUPPORTS：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。&lsquo;3、PROPAGATION_MANDATORY：支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。4、PROPAGATION_REQUIRES_NEW：创建新事务，无论当前存不存在事务，都创建新事务。5、PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。6、PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。7、PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('147','2','如何实现session信息的写入？','3','2',NULL,'flask中有三个session：第一个：数据库中的session，例如:db.session.add()第二个：在flask_session扩展中的session，使用：fromflask_sessionimportSession，使用第三方扩展的session可以把信息存储在服务器中，客户端浏览器中只存储sessionid第三个：flask自带的session，是一个请求上下文，使用：fromflaskimportsession。自带的session把信息加密后都存储在客户端的浏览器cookie中',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('148','2','什么是事务？','3','2',NULL,'(1)事务简单来说：一个Session中所进行所有的操作，要么同时成功，要么同时失败ACID &mdash; 数据库事务正确执行的四个基本要素包含：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。一个支持事务（Transaction）中的数据库系统，必需要具有这四种特性，否则在事务过程（Transaction processing）当中无法保证数据的正确性，交易过程极可能达不到交易。举个例子:A向B转账，转账这个流程中如果出现问题，事务可以让数据恢复成原来一样【A账户的钱没变，B账户的钱也没变】。(2)事务隔离级别数据库定义了4个隔离级别：Serializable【可避免脏读，不可重复读，虚读】Repeatable read【可避免脏读，不可重复读】Read committed【可避免脏读】Read uncommitted【级别最低，什么都避免不了】分别对应Connection类中的4个常量:TRANSACTION_READ_UNCOMMITTEDTRANSACTION_READ_COM',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('149','2','线程实现方式哪几种，如何保证线程安全性，说明Threadlocal的应用场景','3','2',NULL,'Java多线程有三种实现方式：(1)继承Thread类，重写run函数(2)实现Runnable接口，重写run函数开启线程：Thread t = new Thread(对象) //创建线程对象t.start()(3)实现Callable接口，重写call函数             java的同步机制，大概是通过:1.synchronized；2.Object方法中的wait,notify；3.ThreadLocal机制来实现的, 其中synchronized有两种用法:1.对类的方法进行修饰2.synchronized(对象）的方法进行修饰　在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('15','1','谈谈对线程池的理解?','3','2',NULL,'作用：减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务，提高系统性能。可以根据系统的承受能力，调整线程池中工作线程的数目，防止因为消耗过多的内存，而把服务器累趴（每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机）。',NULL,'0','0','0','4','2023-05-25 13:27:14','2023-05-25 13:27:14'),('150','2','请求钩子的理解？','3','3',NULL,'请求钩子是通过装饰器的形式实现的，支持以下四种：1，before_firrequest在处理第一个请求前运行2，before_request:在每次请求前运行3，after_request:如果没有未处理的异常抛出，在每次请求后运行4，teardown_request:即使有未处理的异常抛出，在每次请求后运行',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('151','2','1.讲讲反射机制？2.设计模式你了解多少？','3','2',NULL,'程序在运行的时候可以获取任意一个类的内部信息，也可以说是动态获取设计模式的目的：为了代码可重用性、让代码更容易被他人理解、保证代码可靠性  设计模式有23种',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('153','2','java开启多线程的几种方法','3','2',NULL,'Thread, Runnable, 线程池，Callable） 一个类集成thread类，或者实现runnable接口，并且都要重写其run方法。如果配置线程池的话，一般都是为了减少线程创建和销毁的次数，保证现成的重复利用以及同时执行多个任务的话，才会考虑。当然在使用时，可以根据系统的承受能力去调整线程的数量及大小。',NULL,'1','1','1','2','2023-05-26 10:22:16','2023-05-26 10:22:16'),('154','2','一个变量后写多个过滤器是如何执行？','3','2',NULL,'{{expression|filter1|filter2|...}}即表达式(expression)使用filter1过滤后再使用filter2过滤.',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('155','2','Java 的泛型是什么？有什么好处和优点？JDK 不同版本的泛型有什么区别？','3','2',NULL,'泛型是 Java SE 1.5 的新特性，泛型的本质是参数化类型，这种参数类型可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口、泛型方法。在 Java SE 1.5 之前没有泛型的情况的下只能通过对类型 Object 的引用来实现参数的任意化，其带来的缺点是要做显式强制类型转换，而这种强制转换编译期是不做检查的，容易把问题留到运行时，所以 泛型的好处是在编译时检查类型安全，并且所有的强制转换都是自动和隐式的，提高了代码的重用率，避免在运行时出现 ClassCastException。JDK 1.5 引入了泛型来允许强类型在编译时进行类型检查；JDK 1.7 泛型实例化类型具备了自动推断能力，譬如 List&lt;String&gt; list = new ArrayList&lt;String&gt;(); 可以写成 List&lt;String&gt; llist = new ArrayList&lt;&gt;(); 了，JDK 具备自动推断能力。',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('156','2','tcp和udp的区别？','3','4',NULL,'TCP和UDP的优缺点及区别TCP的优点： 可靠，稳定 TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。 TCP的缺点： 慢，效率低，占用系统资源高，易被攻击 TCP在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的CPU、内存等硬件资源。 而且，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。UDP的优点： 快，比TCP稍安全 UDP没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP较TCP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击&hellip;&hellip; UDP的缺点： 不可靠，不稳定 因为UDP没有TCP那些可',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('159','2','equals和hashCode的区别','3','2',NULL,'equals我们一般是来判断两个对象是否相等，一般来说比如在根据equals()方法比较两个对象是相等的，那么调用这两个对象中的hashCode方法都肯定会产生同样的整数结果。与之相反，如果比较后是不相等的，那么调用这两个对象的hashCode方法，就不一定会产生相同的整数结果了。',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('160','2','简单说说 Comparable 和 Comparator 的区别和场景？','3','2',NULL,'Comparable 对实现它的每个类的对象进行整体排序，这个接口需要类本身去实现，若一个类实现了 Comparable 接口，实现 Comparable 接口的类的对象的 List 列表（或数组）可以通过 Collections.sort（或 Arrays.sort）进行排序，此外实现 Comparable 接口的类的对象可以用作有序映射（如TreeMap）中的键或有序集合（如TreeSet）中的元素而不需要指定比较器， 实现 Comparable 接口必须修改自身的类（即在自身类中实现接口中相应的方法），如果我们使用的类无法修改（如 SDK 中一个没有实现 Comparable 的类），我们又想排序，就得用到 Comparator 这个接口了（策略模式）。所以如果你正在编写一个值类，它具有非常明显的内在排序关系，比如按字母顺序、按数值顺序或者按年代顺序，那你就应该坚决考虑实现 Comparable 这个接口， 若一个类实现了 Comparable 接口就意味着该类支持排序，而 Comparator 是比较器，我们若需要控制某个类的次序，可以建立一个该类的比较器来进行排序。</',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('162','2','简单说说 Iterator 和 ListIterator 的区别？','3','2',NULL,'区别主要如下。ListIterator 有 add() 方法，可以向 List 中添加对象，而 Iterator 不能。ListIterator 和 Iterator 都有 hasNext() 和 next() 方法，可以实现顺序向后遍历，但是 ListIterator 有 hasPrevious() 和 previous() 方法，可以实现逆向（顺序向前）遍历，Iterator 就不可以。ListIterator 可以定位当前的索引位置，通过 nextIndex() 和 previousIndex() 可以实现，Iterator 没有此功能。都可实现删除对象，但是 ListIterator 可以实现对象的修改，通过 set() 方法可以实现，Iterator 仅能遍历，不能修改。',NULL,'1','1','1','2','2022-08-21 17:21:16','2022-08-21 17:21:16'),('163','2','过滤器和拦截器的区别','3','2',NULL,'（1）拦截器intercepter不依赖与servlet容器，而过滤器是依赖servlet容器的。（2）拦截器只是针对action的请求起作用，而过滤器则可以对几乎所有的请求起作用。（3）在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。（4）还有一个很重要的点，就是拦截器可以获取IOC容器中的各个bean，而过滤器就不行，比如在拦截器里注入一个service，可以调用业务逻辑。',NULL,'1','1','1','2','2023-05-26 10:22:16','2023-05-26 10:22:16'),('165','2','数据库垂直和水平拆分？','3','2',NULL,'垂直拆分其实就是一中把大表化成小表的一种操作，什么意思呢？比如原来表10个字段，三个字段查询比较多，剩余的7个字段单独拆出来存一个表，这样可以提高查询效率；水平拆分就是数据量比较大，例如10亿，1亿作为一个表，这样可以拆成10个，横向的数据拆分成小表为水平拆分',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('167','2','python如何解决sql注入','3','3',NULL,'SQL注入即是指web应用程序对用户输入数据的合法性没有判断，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。利用参数化查询、对数据进行词法分析、使用存储过程等防止',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('168','2','struts2的执行流程','3','3',NULL,'Filter的配置找到FilterDispatcher,并且获取到FilterDispatcher的实例对象。FilterDispatcher对象会将该用户请求发送给ActionMapper,如果需要struts2进行处理的话ActionMapper就会通知FileterDispatcher,需要处理这个请求了,这个时候FileterDispatcher就会停止过滤器链后面的部分，然后建立一个ActionProxy实例。这个ActionProxy实例就会通过ConfigurationManager询问框架的配置文件找到需要调用的Action类，于此同时创建一个ActionInvocation实例，在由ActionInvocation实例调用Action的execute方法。最后，Action执行完毕后ActionInvocation根据struts.xml配置找到对应的返回结果。',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('169','2','ArrayList和LinkedList有什么区别？','3','2',NULL,'ArrayList和LinkedList都实现了List接口，他们有以下的不同点：ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。也可以参考ArrayList vs. LinkedList。',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('171','2','你们秒杀怎么做的','3','2',NULL,'当时我们在做的时候，遇到了一些问题，当时为了减库存操作，需要考虑到两个问题：首先若是用户成功秒杀商品，我们记录了其购买明细，却没有减库存。会导致商品的超卖。还有就是减了库存却没有记录用户的购买明细，导致商品的少卖。对于上述两个问题，可以通过MySQL内置的事务机制进行处理，它可以准确的帮我们完成减库存和记录用户购买明细的过程。并且在针对高并发优化,使用了redis缓存数据库解决，使用Redis优化地址暴露接口，在dao包下新建一个cache包，然后创建一个RedisDao.java函数，在spring-dao.xml中配置redisdao构造器。',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('172','2','JVM垃圾回收机制，何时触发MinorGC等操作','3','3',NULL,'不同的对象生命周期不同。把不同生命周期的对象放在不同代上，不同代上采用最合适它的垃圾回收方式进行回收。',NULL,'1','1','1','2','2022-08-21 17:21:16','2022-08-21 17:21:16'),('173','2','什么是HTTP协议','3','2',NULL,'HTTP是超文本传输协议, 是一个客户端和服务器端请求和应答的标准。底层使用TCP,客户端是终端用户，服务器端是网站。通过使用Web浏览器、网络爬虫或者其它的工具，客户端发起一个到服务器上指定端口（默认端口为80）的HTTP请求。',NULL,'1','1','1','2','2023-05-26 10:22:16','2023-05-26 10:22:16'),('174','2','描述jvm加载class文件原理和机制','3','5',NULL,'JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的，Java中的类加载器是一个重要的Java运行时系统组件，它负责在运行时查找和装入类文件中的类。　　由于Java的跨平台性，经过编译的Java源程序并不是一个可执行程序，而是一个或多个类文件。当Java程序需要使用某个类时，JVM会确保这个类已经被加载、连接（验证、准备和解析）和初始化。类的加载是指把类的.class文件中的数据读入到内存中，通常是创建一个字节数组读入.class文件，然后产生与所加载类对应的Class对象。加载完成后，Class对象还不完整，所以此时的类还不可用。当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）三个步骤。最后JVM对类进行初始化，包括：1)如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类；2)如果类中存在初始化语句，就依次执行这些初始化语句。　　类的加载是由类加载器完成的，类加载器包括：根加载器（BootStrap）、扩展加载器（',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('175','2','restful风格api？','3','4',NULL,'REST:Representational State Transfer 的缩写，翻译：&ldquo;具象状态传输&rdquo;。一般解释为&ldquo;表现层状态转换&rdquo;。REST 是设计风格而不是标准。是指客户端和服务器的交互形式。我们需要关注的重点是如何设计REST 风格的网络接口。REST 的特点：1.具象的。一般指表现层，要表现的对象就是资源。比如，客户端访问服务器，获取的数据就是资源。比如文字、图片、音视频等。2.表现：资源的表现形式。txt 格式、html 格式、json 格式、jpg 格式等。浏览器通过 URL 确定资源的位置，但是需要在 HTTP 请求头中，用 Accept 和 Content-Type 字段指定，这两个字段是对资源表现的描述。3.状态转换：客户端和服务器交互的过程。在这个过程中，一定会有数据和状态的转化，这种转化叫做状态转换。其中，GET 表示获取资源，POST 表示新建资源，PUT 表示更新资源，DELETE 表示删除资源。HTTP 协议中最常用的就是这',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('176','2','对volatile有了解吗','3','2',NULL,'Java 内存模型中的可见性、原子性和有序性。可见性：　　可见性是一种复杂的属性，因为可见性中的错误总是会违背我们的直觉。通常，我们无法确保执行读操作的线程能适时地看到其他线程写入的值，有时甚至是根本不可能的事情。为了确保多个线程之间对内存写入操作的可见性，必须使用同步机制。　　可见性，是指线程之间的可见性，一个线程修改的状态对另一个线程是可见的。也就是一个线程修改的结果。另一个线程马上就能看到。比如：用volatile修饰的变量，就会具有可见性。volatile修饰的变量不允许线程内部缓存和重排序，即直接修改内存。所以对其他线程是可见的。但是这里需要注意一个问题，volatile只能让被他修饰内容具有可见性，但不能保证它具有原子性。比如 volatile int a = 0；之后有一个操作 a++；这个变量a具有可见性，但是a++ 依然是一个非原子操作，也就是这个操作同样存在线程安全问题。　　在 Java 中 volatile、synchronized 和 final 实现可见性。原子性：<br /',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('177','2','cookies和session的区别？','3','2',NULL,'1.cookie 数据存放在客户的浏览器上，session 数据放在服务器上。2.cookie 不是很安全，别人可以分析存放在本地的 cookie 并进行 cookie 欺骗考虑到安全应当使用 session。3.session 会在一定时间内保存在服务器上。当访问增多，会比较占用服务器的性能考虑到减轻服务器性能方面，应当使用 cookie。4.单个 cookie 保存的数据不能超过 4K，很多浏览器都限制一个站点最多保存 20 个 cookie。5.建议： 将登陆信息等重要信息存放为 SESSION 其他信息如果需要保留，可以放在 cookie 中',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('178','2','String 是最基本的数据类型吗？','3','2',NULL,'不是。Java中的基本数据类型只有8个：byte、short、int、long、float、double、char、boolean；除了基本类型（primitive type）和枚举类型（enumeration type），剩下的都是引用类型（reference type）',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('179','2','Java 线程优先级是怎么定义的','3','2',NULL,'Java 线程的优先级定义为从 1 到 10 的等级，默认为 5，设置和获取线程优先级的方法是 setPriority(int newPriority) 和 getPriority()，Java 的这个优先级会被映射到操作系统中线程的优先级，不过由于操作系统各不相同，不一定都是 10 个优先级，所以 Java中不同的优先级可能会被映射到操作系统中相同的优先级，同时优先级对操作系统而言更多的是一种建议和提示而非强制，所以我们不要过于依赖优先级。',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('180','2','简单说说 java 的 Class.forName 和 ClassLoader.loadClass 方法的区别？','3','2',NULL,'一个 Java 类加载到 JVM 中会经过三个步骤，装载（查找和导入类或接口的二进制数据）、链接（校验：检查导入类或接口的二进制数据的正确性；准备：给类的静态变量分配并初始化存储空间；解析：将符号引用转成直接引用；）、初始化（激活类的静态变量的初始化 Java 代码和静态 Java 代码块）。',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('181','2','ThreadLocal 用途是什么，原理是什么，用的时候要注意什么  ','3','2',NULL,'我们知道,在多线程程序中,同一个线程在某个时间段只能处理一个任务.我们希望在这个时间段内,任务的某些变量能够和处理它的线程进行绑定,在任务需要使用这个变量的时候,这个变量能够方便的从线程中取出来.ThreadLocal能很好的满足这个需求,用ThreadLocal变量的程序看起来也会简洁很多,因为减少了变量在程序中的传递.2.ThreadLocal的原理是怎么样的?  每个运行的线程都会有一个类型为ThreadLocal.ThreadLocalMap的map,这个map就是用来存储与这个线程绑定的变量,map的key就是ThreadLocal对象,value就是线程正在执行的任务中的某个变量的包装类Entry.3. ThreadLocal保存变量的生命周期是怎么样的?  ThreadLocal保存变量的生命周期 &lt;=任务的生命周期&lt;=线程的生命周期ThreadLocal.set，ThreadLocal.remove实际上是同样的道',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('182','2','redis原理,和Redis雪崩处理','3','2',NULL,'缓存穿透 一般的缓存系统,都是按照key去缓存的,如果不存在对应的value,应该去后端系统查询(比如数据库).如果key对应的value是一定不存在,并且对key并发请求量很大,就会对后端系统造成很大的压力,这就叫做缓存穿透; 缓存雪崩 缓存雪崩指的是我们设置缓存是采用了相同的过期时间,导致缓存在某一时期同时失效,请求全部转发到DB,DB瞬间压力多大雪崩; 解决方案 把缓存的时间失效分散开,比如在原来的时间基础上增加一个随机值,比如1~5分钟随机,这样每一个缓存的过期时间的重复率聚会降低,就很难引发集体失效事件;',NULL,'1','1','1','2','2022-08-21 17:21:16','2022-08-21 17:21:16'),('183','2','CocurrentHashMap原理是什么？cocurrent包下除此之外还用过哪些类？','3','2',NULL,'采用分段锁的机制 ，对每个entry数组进行加锁相比hashtable效率要高，还有atomic包',NULL,'1','1','1','2','2023-05-26 10:22:16','2023-05-26 10:22:16'),('185','2','Java中如何实现多线程','3','2',NULL,'继承Thread类实现Runnable接口推荐使用Runnable接口',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('186','2','说一下AOP与IOC的概念（即spring的核心）','3','2',NULL,'a)IOC：Spring是开源框架，使用框架可以使我们减少工作量，提高工作效率并且它是分层结构，即相对应的层处理对应的业务逻辑，减少代码的耦合度。而spring的核心是IOC控制反转和AOP面向切面编程。IOC控制反转主要强调的是程序之间的关系是由容器控制的，容器控制对象，控制了对外部资源的获取。而反转即为，在传统的编程中都是由我们创建对象获取依赖对象，而在IOC中是容器帮我们创建对象并注入依赖对象，正是容器帮我们查找和注入对象，对象是被获取，所以叫反转。Spring支持三种依赖注入方式，分别是属性（Setter方法）注入，构造注入和接口注入。在Spring中，那些组成应用的主体及由Spring IOC容器所管理的对象被称之为Bean。Spring的IOC容器通过反射的机制实例化Bean并建立Bean之间的依赖关系。简单地讲，Bean就是由Spring IOC容器初始化、装配及被管理的对象。获取Bean对象的过程，首先通过Resource加载配置文件并启动IOC容器，然后通过getBean方法获取be',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('187','2','fianl，finally，finalize的区别','3','1',NULL,'final&mdash;修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载。finally&mdash;再异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。finalize&mdash;方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object 类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() ',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('188','2','HashMap 中的 key 如果是 Object 则需要实现哪些方法？','3','2',NULL,'hashCode 方法和 equals 方法。因为 hashCode 方法用来计算 Entry 在数组中的 index 索引位置，equals 方法用来比较数组指定 index 索引位置上链表的节点 Entry 元素是否相等。否则由于 hashCode 方法实现不恰当会导致严重的 hash 碰撞，从而使 HashMap 会退化成链表结构而影响性能。',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('189','2','flask中的请求钩子？','3','3',NULL,'请求钩子是通过装饰器的形式实现的，支持以下四种：1，before_firrequest 在处理第一个请求前运行2，before_request:在每次请求前运行3，after_request:如果没有未处理的异常抛出，在每次请求后运行4，teardown_request:即使有未处理的异常抛出，在每次请求后运行',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('190','2','HashMap 默认的初始化长度是多少？为什么默认长度和扩容后的长度都必须是 2 的幂？','3','2',NULL,'在 JDK 中默认长度是 16（在 Android SDK 中的 HashMap 默认长度为 4），并且默认长度和扩容后的长度都必须是 2 的幂。因为我们可以先看下 HashMap 的 put 方法核心',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('191','2','描述一下对象的创建过程','3','2',NULL,'1)装载：将Java二进制代码导入jvm中，生成Class文件。2)连接：a）校验：检查载入Class文件数据的正确性b）准备：给类的静态变量分配存储空间c）解析：将符号引用转成直接引用3）：初始化：对类的静态变量，静态方法和静态代码块执行初始化工作。',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('193','2','HashMap和Hashtbale区别？','3','1',NULL,'HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的区别。主要的区别有：线程安全性，同步(synchronization)，以及速度。HashMap几乎可以等价于Hashtable，除了HashMap是非synchronized的，并可以接受null(HashMap可以接受为null的键值(key)和值(value)，而Hashtable则不行)。HashMap是非synchronized，而Hashtable是synchronized，这意味着Hashtable是线程安全的，多个线程可以共享一个Hashtable；而如果没有正确的同步的话，多个线程是不能共享HashMap的。Java 5提供了ConcurrentHashMap，它是HashTable的替代，比HashTable的扩展性更好。另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构',NULL,'1','1','1','2','2023-05-26 10:22:16','2023-05-26 10:22:16'),('194','2','请简单描述一下ajax技术？','3','2',NULL,'ajax是指一种创建交互式网页应用的网页开发技术，简单的说就是一个异步页面交互技术',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('195','2','COOKIE的跨域','3','3',NULL,'在任何一个系统登录后，可以访问这个统一加载上的所有系统。登录之后，用户的权限和信息不再受某个系统的限制，即使某个系统出现故障(包括统一加载平台)，其他系统还是能正常使用的。这就需要用户权限等信息保存到客户端，不受服务器的限制。在cookie相关文档信息中，提到cookie是不能跨域访问的，但是在二级域名是可以共享cookie的。这样就是我们的项目有了局限性，必须将多个系统的域名统一，作为二级域名，统一平台提供使用主域名。这样就可以实cookie的单点登录了。domain属性:例如设成&quot;.hanj.com&quot;则在.hanj.com下的所有服务器下的文件都可以调用cookie.统一平台域名：www.hanj.com统一加载平台和各子系统都是不同的服务器，统一加载平台提供登录认证服务，在统一加载平台认证系统上登录后，用户都可以被其他的系统识别.',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('197','2','运行时异常和一般异常有何区别？','3','1',NULL,'相同点：两种异常同属于Exception父类。不同点：(1)运行时异常都是RuntimeException类及其子类异常，如NullPointerException、IndexOutOfBoundsException等。(2)一般异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。1、一般异常：一般异常包括IOException、SQLException等以及用户自定义的Exception异常。对于这种异常，JAVA编译器强制要求我们必需对出现的这些异常进行catch并处理，否则程序就不能编译通过。所以，面对这种异常不管我们是否愿意，只能自己去写一大堆catch块去处理可能的异常。2、常见RuntimeException：ArrayStoreException：试图将错误类型的对象存储到一个对象数组时抛出的异常ClassCastException',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('198','2','ConcurrentHashMap是什么','3','3',NULL,'并发编程实践中，ConcurrentHashMap是一个经常被使用的数据结构，相比于Hashtable以及Collections.synchronizedMap()，ConcurrentHashMap在线程安全的基础上提供了更好的写并发能力，但同时降低了对读一致性的要求。ConcurrentHashMap的设计与实现非常精巧，大量的利用了volatile，final，CAS等lock-free技术来减少锁竞争对于性能的影响.ConcurrentHashMap采用了分段锁的设计，只有在同一个分段内才存在竞态关系，不同的分段锁之间没有锁竞争。相比于对整个Map加锁的设计，分段锁大大的提高了高并发环境下的处理能力。但同时，由于不是对整个Map加锁，导致一些需要扫描整个Map的方法（如size(), containsValue()）需要使用特殊的实现，另外一些方法（如clear()）甚至放弃了对一致性的要求（ConcurrentHashMap是弱一致性的',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('2','1','多线程通信','3','1',NULL,'1、使用volatile进行线程之间的通信2、wait/notify的方法3、CountDownLatch实现线程间通信',NULL,'1','1','1','1','2022-08-21 17:21:16','2022-08-21 17:21:16'),('201','3','信号量是什么','3','3',NULL,'信号量是用来解决线程间同步或互斥的一种机制，也是一个特殊的变量，变量的值代表着当前可以利用的资源。信号量的本质是数据操作锁，它本身不具有数据交换的功能，而是通过控制其他的通信资源（文件，外部设备）来实现进程间通信，它本身只是一种外部资源的标识。信号量在此过程中负责数据操作的互斥、同步等功能。为了防止出现因多个程序同时访问一个共享资源而引发的一系列问题，我们需要一种方法，它可以通过生成并使用令牌来授权，在任一时刻只能有一个执行线程访问代码的临界区域。临界区域是指执行数据更新的代码需独占式地执行。而信号量就可以提供这样的一种访问机制，让一个临界区同一时间只有一个线程在访问它，也就是说信号量是用来调协进程对共享资源的访问的。其中共享内存的使用就要用到信号量。',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('203','3','进程间的通信方式','3','2',NULL,'管道( pipe )：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。有名管道 (named pipe) ： 有名管道也是半双工的通信方式，但是它允许无亲缘关系进程间的通信。信号量( semophore ) ： 信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。因此，主要作为进程间以及同一进程内不同线程之间的同步手段。消息队列( message queue ) ： 消息队列是由消息的链表，存放在内核中并由消息队列标识符标识。消息队列克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。信号 ( sinal ) ： 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。共享内存( shared memory ) ：共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问。共享内存是最快的 I',NULL,'1','1','1','3','2023-05-26 10:22:16','2023-05-26 10:22:16'),('207','3','用PHP打印出前一天的时间格式是2006-5-10 22:21:21','3','2',NULL,'echo date(&#39;Y-m-d H:i:s&#39;,strtotime(&#39;-1 day&#39;,time()));',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('208','3','后端如何进行项目优化','3','3',NULL,'1.页面做缓存 2.主页静态化 3.阻塞操作使用celery异步 4.对数据库进行优化',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('209','3','怎么设计数据库','3','2',NULL,'第一范式：数据库表的每一列都是不可分割的原子数据项，即列不可拆分第二范式：建立在第一范式的基础上，要求数据库表中的每个实例或记录必须是可以唯一被区分的，即唯一标识。第三范式：建立在第二范式的基础上，任何非主属性不依赖与其他非主属性，即引用主键。',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('211','3','写二分查找','3','3',NULL,' 1. def binary_search(alist,item): 2. n = len(alist) 3. if n == 0: 4. return False 5. mid = n // 2 6. if alist[mid] == item: 7. return True 8. elif alist[mid] &gt; item: 9. return binary_search(alist[:mid],item) 10. else: 11. return binary_search(alist[mid+1:],item) 12. 13. if __name__ == &#39;__main__&#39;: 14. li = [3,6,8,10,40,60] 15. print(binary_search(li,60))',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('212','3','什么是线程池？','3','2',NULL,'在一个应用程序中初始化一个线程集合，然后在需要执行新的任务时重用线程池中的线程，而不是创建一个新的线程。线程池中的每个线程都有被分配一个任务，一旦任务完成，线程就回到线程池中，等待下一次的任务分配',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('214','3','停止一个线程的方法','3','3',NULL,'终止线程的三种方法：1. 使用退出标志，使线程正常退出，也就是当run方法完成后线程终止。2. 使用stop方法强行终止线程（这个方法不推荐使用，因为stop和suspend、resume一样，也可能发生不可预料的结果）。3. 使用interrupt方法中断线程。',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('215','3','关于csrf的了解和其在django中如何保护','3','3',NULL,'（1）一开始用户打开浏览器，访问受信任网站A，输入用户名和密码登陆请求登陆网站A。 （2）网站A验证用户信息，用户信息通过验证后，网站A产生Cookie信息并返回给浏览器。 （3）用户登陆网站A成功后，可以正常请求网站A。 （4）用户未退出网站A之前，在同一浏览器中，打开一个TAB访问网站B。 （5）网站B看到有人方式后，他会返回一些攻击性代码。 （6）浏览器在接受到这些攻击性代码后，促使用户不知情的情况下浏览器携带Cookie（包括sessionId）信息，请求网站A。这种请求有可能更新密码，添加用户什么的操作。  解决方法：settings中开启csrf保护，在表单中添加csrf_token',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('216','3','简单说说 Java 的 JVM 内存结构分为哪几个部分？','3','2',NULL,'JVM 内存共分为虚拟机栈、堆、方法区、程序计数器、本地方法栈五个部分，分别解释如下。虚拟机栈：线程私有的，每个方法在执行时会创建一个栈帧，用来存储局部变量表、操作数栈、动态连接、方法返回地址等；其中局部变量表用于存放 8 种基本数据类型（boolean、byte、char、short、int、float、long、double）和 reference 类型。每个方法从调用到执行完毕对应一个栈帧在虚拟机栈中的入栈和出栈。',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('217','3','你知道线程同步与阻塞的关系？同步一定阻塞吗？阻塞一定同步的吗？','3','3',NULL,'线程同步与否跟阻塞非阻塞没关系，同步是个过程，阻塞是线程的一种状态。多个线程操作共享变量时可能会出现竞争。这时需要同步来防止两个以上的线程同时进入临界区内，在这个过程中后进入临界区的线程将阻塞，等待先进入的线程走出临界区。',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('218','3','面向对象有哪些特征？','3','1',NULL,'1.封装：封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面，面向对象计算始于这个基本概念，即现实世界可以被描绘成一系列完全自治，封装的对象，这些对象通过一个受保护的接口访问其他对象2.继承：继承是一种联结类的层次模型，并且允许和鼓励类的重用，它提供了一种明确表达共性的方法，对象的一个新类可以从现在的类中派生，这个过程成为继承，新类继承了原始类的特性，新类成为原始类的派生类，而原始类称为新类的基类，派生类可以从他的基类那里继承方法和实例变量，并且类可以修改或增加新的方法使之更加适合特殊的需求3.抽象：抽象就是忽略一个主题中与当前目标无关的那些方面，以便充分的注意与当前目标有关的方面，抽象包括两个方面，一个是过程抽象，二是数据抽象4.多态性：多态性是指允许不同类的对象对同一消息作出响应，多态性包括参数化多态性和包含多态性，多态性语言具有灵活，抽象，行为共享，代码共享的优势，很好的解决了应用程序函数同名的问题',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('219','3','说一下单例模式','3','3',NULL,'单例模式具体实现方式非常多，有饿汉式、懒汉式、双检锁、私有静态内部类、枚举等。饿汉式是在类加载的时候由静态成员变量位置创建对象；懒汉式则是在用户在第一次调用方法的时候创建，但是高并发时会有安全隐患，由此引申出双检锁模式；但是网上有人说双检锁模式也不安全，涉及到java指令重排序问题，导致用户获取的单例对象可能残缺，需要用volatile关键字修饰成员变量，但是这种错误我曾经模拟过很多次，根本测试不出来，所以我很怀疑；私有静态内部类的方案是一种不错的方案，既能延迟对象的初始化时机，又能保证安全性；最后一种枚举方案是我比较喜欢的，因为代码简单，而且安全，尤其是用户无法通过暴力反射来打破单例状态，但是它的初始化时机也是类加载时初始化。',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('220','3','前端的框架的了解','3','1',NULL,'vue，bootstrap,jquery......',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('221','3','说一下java的垃圾回收','3','3',NULL,'首先说一下垃圾确定算法：引用计数法：垃圾回收器会遍历对象列表，清理引用数为0的对象。缺点：两个对象互相引用时，清理不掉。可达性分析：思想---所有存活的对象，一定能追溯到其存活在栈（虚拟机栈/本地方法栈）、堆或方法区中的引用。也就是从GC Roots开始遍历，游离在引用链之外的对象视为垃圾。目前主流虚拟机采用的是分代收集算法：主流JVM的垃圾回收算法，把堆分为新生代、老年代；方法区对应永久带。新生代（Minor GC）：刚初始化的对象，状态不稳定，每次垃圾回收时都有大量对象被回收，具有朝生夕灭的特性。大部分垃圾收集器对于新生代都采取复制算法，因为复制对象的次数较少。一般来说是将新生代划分为一块较大的Eden（伊甸园）空间和两块较小的Survivor（幸存者）空间（一般为8:1:1），每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。新生代实际可用的内存空间为自身的90%。对象在Survivor每熬过一次Minor G',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('222','3','爬虫爬过哪个网站','3','1',NULL,'根据自身项目而定，项目相关网站都可以说，同时可以说一些自己爬过的网站练手',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('223','3','==号和equals的区别','3','2',NULL,'equal:是用来比较两个对象内部的内容是否相等的，由于所有的类都是继承java.lang.Object类的，所以如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法。而Object中的equal方法返回的却是==的判断，因此，如果在没有进行该方法的覆盖后，调用该方法是没有任何意义的。在java面向对象的处理中我们一般在javabean中都要选择重写equals方法，使用hibernate后，我们要生成数据库的映射文件与实体类，最好在实体类中进行equals方法的重写，重写时我们可以根据自己的定义来实现该方法只要遵守那五条原则',NULL,'1','1','1','3','2023-05-26 10:22:16','2023-05-26 10:22:16'),('224','3','说一些自己知道的简单的算法？','3','3',NULL,'常用的且学过的：冒泡排序，快速排序，选择排序，插入排序&hellip;&hellip;',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('225','3','java自带的常用线程池有那几个？','3','2',NULL,'Java通过Executors提供四种线程池，分别为：newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('226','3','Java中，什么是构造方法？什么是构造方法重载？什么是复制构造方法？','3','3',NULL,'当新对象被创建的时候，构造方法会被调用。每一个类都有构造方法。在程序员没有给类提供构造方法的情况下，Java编译器会为这个类创建一个默认的构造方法。Java中构造方法重载和方法重载很相似。可以为一个类创建多个构造方法。每一个构造方法必须有它自己唯一的参数列表。Java不支持像C++中那样的复制构造方法，这个不同点是因为如果你不自己写构造方法的情况下，Java不会创建默认的复制构造方法。',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('227','3','scrapy爬虫原理','3','2',NULL,'1，spider打开某网页，获取到一个或者多个request，经由scrapy engine传送给调度器scheduler，request特别多并且速度特别快会在scheduler形成请求队列queue，由scheduler安排执行。2，schelduler会按照一定的次序取出请求，经由引擎, 下载器中间键，发送给下载器dowmloader，这里的下载器中间键是设定在请求执行前，因此可以设定代理，请求头，cookie等。3，下载下来的网页数据再次经过下载器中间键，经过引擎，经过爬虫中间键传送给爬虫spiders，这里的下载器中间键是设定在请求执行后，因此可以修改请求的结果，这里的爬虫中间键是设定在数据或者请求到达爬虫之前，与下载器中间键有类似的功能。4，由爬虫spider对下载下来的数据进行解析，按照item设定的数据结构经由爬虫中间键，引擎发送给项目管道itempipeline，这里的项目管道itempipeline可以对数据进行进一步的清洗，存储等操作，这里爬虫极有可能从数据中解析到进一步的请求，request，它会把请求经由引',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('228','3','java中线程安全的集合有哪些？','3','2',NULL,'1、线程安全(Thread-safe)的集合对象：Vector 线程安全：HashTable 线程安全：StringBuffer 线程安全：2、非线程安全的集合对象：ArrayList ：LinkedList：HashMap：HashSet：TreeMap：TreeSet：StringBulider：',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('229','3','文章的去重','3','5',NULL,'python去除文件中重复的文章，我们可以设置一个一个空list，res_list，用来加入没有出现过的文章！如果出现在res_list，我们就认为该行句子已经重复了',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('23','1','SQL注入的攻击原理及如何在代码中防止SQL注入','3','3',NULL,'SQL注入即是指web应用程序对用户输入数据的合法性没有判断，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。利用参数化查询、对数据进行词法分析、使用存储过程等防止',NULL,'0','0','0','1','2023-05-26 10:22:16','2023-05-26 10:22:16'),('230','3','简述src和href的区别','3','3',NULL,'src是source的缩写，是在页面中引入某种资源,当浏览器解析到src时，会暂停浏览器的渲染，直到该资源加载完毕；href用于在当前文档和引用资源之间建立联系。',NULL,'1','1','1','3','2023-05-26 10:22:16','2023-05-26 10:22:16'),('231','3','list，set，map的是否继承collection？','3','2',NULL,'List，Set是，Map不是。Collection是最基本的集合接口，一个Collection代表一组Object，即Collection的元素。一些Collection允许相同的元素而另一些不行。一些能排序而另一些不行。Java JDK不能提供直接继承自Collection的类，Java JDK提供的类都是继承自Collection的&quot;子接口&quot;，如:List和Set。注意：Map没有继承Collection接口，Map提供key到value的映射。一个Map中不能包含相同key，每个key只能映射一个value。Map接口提供3种集合的视图，Map的内容可以被当做一组key集合，一组value集合，或者一组key-value映射。',NULL,'1','1','1','3','2023-05-26 10:22:16','2023-05-26 10:22:16'),('232','3','为什么很多 Java 规范都建议不要显式的创建 Thread，而使用线程池？','3','2',NULL,'因为使用线程池的好处是减少在创建和销毁线程上所消耗的时间和系统资源，解决资源不足的问题，如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者过渡切换问题。',NULL,'1','1','1','3','2023-05-26 10:22:16','2023-05-26 10:22:16'),('234','3','new Object()的原理是什么？','3','3',NULL,'1)创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。2)属性和方法被加入到 this 引用的对象中。3)新创建的对象由 this 所引用，并且最后隐式的返回 this',NULL,'1','1','1','3','2023-05-26 10:22:16','2023-05-26 10:22:16'),('235','3','列出arrylist，linklist，vectory的存储性能和特性','3','2',NULL,'Vector中的方法由于添加了synchronized修饰，因此Vector是线程安全的容器，但性能上较ArrayList差，因此已经是Java中的遗留容器。   LinkedList使用双向链表实现存储（将内存中零散的内存单元通过附加的引用关联起来，形成一个可以按序号索引的线性结构，这种链式存储方式与数组的连续存储方式相比，内存的利用率更高），按序号索引数据需要进行前向或后向遍历，但是插入数据时只需要记录本项的前后项即可，所以插入速度较快。         Vector属于遗留容器（Java早期的版本中提供的容器，除此之外，Hashtable、Dictionary、BitSet、Stack、Properties都是遗留容器），已经不推荐使用，但是由于ArrayList和LinkedListed都是非线程安全的，如果遇到多个线程操作同一个容器的场景，则可以通过工具类Collectio',NULL,'1','1','1','3','2023-05-26 10:22:16','2023-05-26 10:22:16'),('236','3','阐述线程安全和线程非安全','3','2',NULL,'线程安全就是多线程访问时，采用了加锁机制，当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程读取完，其他线程才可使用。不会出现数据不一致或者数据污染。   线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据',NULL,'1','1','1','3','2023-05-26 10:22:16','2023-05-26 10:22:16'),('237','3','Java 中静态代码块、构造代码块、构造方法的执行顺序是什么？','3','2',NULL,'因为静态代码块作用于类级别，构造代码块和构造方法作用于对象级别，所以静态代码块是随着类的加载而被执行，只要类被加载了就会执行，而且只会加载一次，主要用于给类进行初始化；构造代码块在每次创建一个对象时就会执行一次且优先于构造函数，主要用于初始化不同对象共性的初始化内容和初始化实例环境；构造方法在每次创建一个对象时就会执行一次，同时构造方法是给特定对象进行初始化，而构造代码是给所有对象进行初始化；所以通过分析得出他们三者的执行顺序为 静态代码块 &gt; 构造代码块 &gt; 构造方法。',NULL,'1','1','1','3','2023-05-26 10:22:16','2023-05-26 10:22:16'),('238','3','3，常用的集合有哪些','3','2',NULL,'ArrayList，HashMap，HashSet等',NULL,'1','1','1','3','2023-05-26 10:22:16','2023-05-26 10:22:16'),('239','3','3.单例和多例','3','3',NULL,'单例模式就是保证对象在内存中只有一份, 多例可以理解为是多份, Java的枚举类就可以看做是多例',NULL,'1','1','1','3','2023-05-26 10:22:16','2023-05-26 10:22:16'),('240','3','1.ArrayList和LinkedList的区别','3','3',NULL,'ArrayList增删慢，查找快，LinkedList正好相反',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('241','3','b继承a的方法','3','2',NULL,'继承:原型继承,借用构造函数继承,组合继承,拷贝继承. 一般最简单面试会用的继承方式:原型继承:b.prototype=new a();',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('242','3','接口与抽象类的区别','3','2',NULL,'1.语法层面上的区别　　1）抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法；　　2）抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；　　3）接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法；　　4）一个类只能继承一个抽象类，而一个类却可以实现多个接口。2.设计层面上的区别　　1）抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽象，包括属性、行为，但是接口却是对类局部（行为）进行抽象。举个简单的例子，飞机和鸟是不同类的事物，但是它们都有一个共性，就是都会飞。那么在设计的时候，可以将飞机设计为一个类Airplane，将鸟设计为一个类Bird，但是不能将 飞行 这个特性也设计为类，因此它只是一个行为特性，并不是对一类事物的抽象描述。此时可以将 飞行 设计为一个接口Fly，包含方法fly( )，然后A',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('243','3','1.ArrayList和LinkedList的区别','3','3',NULL,'ArrayList增删慢，查找快，LinkedList正好相反',NULL,'1','1','1','3','2023-05-26 10:22:16','2023-05-26 10:22:16'),('244','3','简述内存溢出的查找方式以及解决思路','3','4',NULL,'内存溢出是指应用系统中存在无法回收的内存或使用的内存过多，最终使得程序运行要用到的内存大于虚拟机能提供的最大内存。 引起内存溢出的原因有很多种，常见的有以下几种：　　1.内存中加载的数据量过于庞大，如一次从数据库取出过多数据；　　2.集合类中有对对象的引用，使用完后未清空，使得JVM不能回收；　　3.代码中存在死循环或循环产生过多重复的对象实体；　　4.使用的第三方软件中的BUG；　　5.启动参数内存值设定的过小；内存溢出的解决方案：   第一步，修改JVM启动参数，直接增加内存。(-Xms，-Xmx参数一定不要忘记加。)　　第二步，检查错误日志，查看&ldquo;OutOfMemory&rdquo;错误前是否有其它异常或错误。　　第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。重点排查以下几点：',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('245','3','java 的 Integer 和 int 有什么区别？','3','2',NULL,'int 是 java 内置基本数据类型之一，java 为每个基本类型都提供了一个封装类，Integer 就是 int 的封装类（也叫包装类型）；int 变量的默认值为 0，Integer 变量的默认值为 null，所以 Integer 可以区分出未赋值和值为 0 的区别；Integer 类内部提供了一些关于整数操作的方法，例如上文用到的表示整数的最大值和最小值。',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('246','3','2.HashMap的数据结构是什么','3','3',NULL,'1.7是数组+链表；1.8是数组+链表+红黑树',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('247','3','int和integer的区别','3','2',NULL,'int是java的原始数据类型，Integer是java为int提供的封装类。',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('248','3','字符串的方式有哪些','3','1',NULL,'charcharAt(intindex)返回index所指定的字符Stringconcat(Stringstr)将两字符串连接booleanendsWith(Stringstr)测试字符串是否以str结尾booleanequals(Objectobj)比较两对象char[]getBytes将字符串转换成字符数组返回char[]getBytes(Stringstr)将指定的字符串转成制服数组返回booleanstartsWith(Stringstr)测试字符串是否以str开始',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('249','3','String和StringBuff的区别','3','2',NULL,'String和StringBuff可以储存和操作字符串，即包含多个字符的字符数据。String类提供了数值不可改变的字符串，StringBuff则可变。',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('250','3','java 中 char 类型变量能不能储存一个中文的汉字，为什么？','3','2',NULL,'java 的 char 类型变量是用来储存 Unicode 编码字符的，Unicode 字符集包含了汉字，所以 char 类型自然就能存储汉字，但是在某些特殊情况下某个生僻汉字可能没有包含在 Unicode 编码字符集中，这种情况下 char 类型就不能存储该生僻汉字了。',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('251','3','基本数组去重的实现','3','1',NULL,'//最简单数组去重法functionunique1(array){varn=[];//一个新的临时数组//遍历当前数组for(vari=0;i&lt;array.length;i++){//如果当前数组的第i已经保存进了临时数组，那么跳过，//否则把当前项push到临时数组里面if(n.indexOf(array[i])==-1)n.push(array[i]);}return&',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('252','3','运行时异常和一般异常有什么区别','3','2',NULL,'运行时异常表示虚拟机的通常操作中可能发生的异常，是一种常见的运行错误。java编译时要求方法必须声明抛出可能的非运行时异常，但并不要求必须声明抛出未捕获的运行时异常。',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('253','3','简单说说堆和栈各自的特点？','3','2',NULL,'栈是一种具有后进先出性质的数据结构，也就是说后存放的先取，先存放的后取。堆是一种经过排序的树形数据结构，每个结点都有一个值。通常我们所说的堆的数据结构，是指二叉堆。堆的特点是根结点的值最小（或最大），且根结点的两个子树也是一个堆。由于堆的这个特性，常用来实现优先队列，堆的存取是随意的。',NULL,'1','1','1','3','2023-05-26 10:22:16','2023-05-26 10:22:16'),('254','3','error和Exception的区别','3','2',NULL,'Error类一般是指与虚拟机相关的问题，如系统崩溃，虚拟机错误，内存空间不足，方法调用栈溢等。Exception类表示程序可以处理的异常，可以捕获且可能恢复。',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('255','3','为什么不建议在代码中直接使用 Executors 创建线程池，而是推荐通过 ThreadPoolExecutor 方式创建？','3','2',NULL,'其实不直接使用工具类的目的只有一个，那就是可以明确的让我们知道线程池的运行规则，避免使用工具类的包装而不够直观内部机制而导致潜在的问题。譬如使用 Executors 的 FixedThreadPool 和 SingleThreadPool 创建线程池的原理都允许请求的队列长度为 Integer 的最大值，这样的话可能会堆积大量的请求导致 OOM；而使用 Executors 的 CachedThreadPool 和 ScheduledThreadPool 创建线程池的原理都允许创建线程数量为 Integer 的最大值，这样的话可能会导致创建大量的线程而导致 OOM，所以推荐直接通过明确的构造参数创建线程池，这样就相当与时刻提醒自己的线程池特性是什么。',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('256','3','js中变量声明提前','3','1',NULL,'有许多同学知道js在执行的时候，是从上到下，从左到右，一行一行执行的，但是不知道在这之前还要做一些事情，js程序在正式执行之前，会将所有var声明的变量和function声明的函数，预读到所在作用域的顶部，但是对var声明只是将声明提前，赋值仍然保留在原位置，function声明，会将函数名称和函数体都提前，而且先预声明变量再预定义函数。这个过程也被叫做，&ldquo;预解析&rdquo;或者&ldquo;预编译&rdquo;。',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('257','3','Java内存模型？','3','2',NULL,'1.程序计数器：是一个数据结构，用于保存当前正常执行的程序的内存地址。Java虚拟机的多线程就是通过线程轮流切换并分配处理器时间来实现的，为了线程切换后能恢复到正确的位置，每条线程都需要一个独立的程序计数器，互不影响，该区域为&ldquo;线程私有&rdquo;。2.Java虚拟机栈：线程私有的，与线程生命周期相同，用于存储局部变量表，操作栈，方法返回值。局部变量表放着基本数据类型，还有对象的引用。3.本地方法栈：跟虚拟机栈很像，不过它是为虚拟机使用到的Native方法服务。4.Java堆：所有线程共享的一块内存区域，对象实例几乎都在这分配内存。5.方法区：各个线程共享的区域，储存虚拟机加载的类信息，常量，静态变量，编译后的代码。6.运行时常量池：代表运行时每个class文件中的常量表。包括几种常量：编译时的数字常量、方法或者域的引用。',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('258','3','3.对JVM了解与否，还有一大堆项目中的细节问题','3','5',NULL,'jvm体系总体分四大块：<ul>	<li>类的加载机制</li>	<li>jvm内存结构</li>	<li>GC算法 垃圾回收</li>	<li>GC分析 命令调优</li></ul>',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('259','3','说一说servlet的生命周期','3','2',NULL,'Servlet被服务器实例化后，容器运行其init()方法，请求到达时运行其service()方法，service方法自动派遣运行与请求对应的doXXX方法（doGet，doPost）等，当服务器决定将实例销毁的时候调用其destroy()方法。',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('26','5','Mysql的引擎','3','2',NULL,'主要MyISAM与InnoDB两个引擎，其主要区别如下：InnoDB支持事务，MyISAM不支持，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了；MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用；InnoDB支持外键，MyISAM不支持；MyISAM是默认引擎，InnoDB需要指定；InnoDB不支持FULLTEXT类型的索引；InnoDB中不保存表的行数，如selectcount()fromtable时，InnoDB；需要扫描一',NULL,'0','0','0','2','2022-08-21 17:21:16','2022-08-21 17:21:16'),('260','3','你能不能谈谈，java GC是在什么时候，对什么东西，做了什么事情？','3','2',NULL,'1.新生代有一个Eden区和两个survivor区，首先将对象放入Eden区，如果空间不足就向其中的一个survivor区上放，如果仍然放不下就会引发一次发生在新生代的minor GC，将存活的对象放入另一个survivor区中，然后清空Eden和之前的那个survivor区的内存。在某次GC过程中，如果发现仍然又放不下的对象，就将这些对象放入老年代内存里去。2.大对象以及长期存活的对象直接进入老年区。3.当每次执行minor GC的时候应该对要晋升到老年代的对象进行分析，如果这些马上要到老年区的老年对象的大小超过了老年区的剩余大小，那么执行一次Full GC以尽可能地获得老年区的空间。',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('261','3','overload 和 override 的区别','3','2',NULL,'Overload是重载，是有相同的方法名，但参数类型或个数彼此不同；Override是重写，是在子类与父类中，子类中的方法的方法名，参数个数、类型都与父类中的完全一样，在子类中覆盖掉了父类的改方法。',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('262','3','java和JavaScript的区别','3','1',NULL,'数据类型不同Java的数据类型分为8种，分别是：byte、short、int、long、float、double、char以及Boolean，而JavaScript的数据类型为三种，分别为：number、string和Boolean。除此之外，Java和Javascript变量方面也有不同。',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('263','3','CAS（Compare And Swap） 无锁算法','3','2',NULL,'CAS是乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。CAS有3个操作数，内存值V，旧的预期值A，要修改的新值B。当且仅当预期值A和内存值V相同时，将内存值V修改为B，否则什么都不做。',NULL,'1','1','1','3','2023-05-26 10:22:16','2023-05-26 10:22:16'),('264','3','forward 和 redirect 的区别','3','2',NULL,'1.forward请求url地址栏不会改变，redirect请求会改变；2.forward:转发页面和转发到的页面可以共享request域中的数据，redirect不能共享request域中的数据；3.forward比redirect效率高；',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('265','3','项目当中用到了什么设计模式？','3','2',NULL,'适配器模式：将一个接口适配到另一个接口，Java I/O中InputStreamReader将Reader类适配到InputStream，从而实现了字节流到字符流的准换。装饰者模式：保持原来的接口，增强原来有的功能。FileInputStream 实现了InputStream的所有接口，BufferedInputStreams继承自FileInputStream是具体的装饰器实现者，将InputStream读取的内容保存在内存中，而提高读取的性能。',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('266','3','Get与post传参得区别','3','1',NULL,'a)这个答案说几个很装逼别人又不知道得答案，比如get只发送一次tcp。而post发送两次tcp连接b)Get传参有长度限制，post没有',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('267','3','执行完以下代码块后有几个String实例可以被垃圾回收器回收？<pre><code>String a =new String(\"a\");  String b =new String(\"b\");  String c =new String(\"c\");  b=a;  a=null;  c=b;</code></pre>','3','2',NULL,'1.只有一个String实例被回收，因为只有a实例为null,被垃圾回收器回收。',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('268','3','请写出代理模式的两种模式？','3','2',NULL,'//懒汉式<pre><code>public class SingletonClass{    private static SingletonClass instance=null;    public static SingletonClass getInstance()    {        if(instance==null)        {            synchronized(SingletonClass.class)            {                if(instance==null)                    instance=new SingletonClass();            }        }        return instance;    }    private SingletonClass(){    }}</code></pre>//饿汉式<',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('269','3','说说使用cookie得弊端','3','1',NULL,'a)每个特定的域名下最多生成20个cookieb)IE6或更低版本最多20个cookie',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('27','5','数据库的优化','3','2',NULL,'1.优化索引、SQL语句、分析慢查询；2.设计表的时候严格根据数据库的设计范式来设计数据库；3.使用缓存，把经常访问到的数据而且不需要经常变化的数据放在缓存中，能节约磁盘IO4.优化硬件；采用SSD，使用磁盘队列技术(RAID0,RAID1,RDID5)等5.采用MySQL内部自带的表分区技术，把数据分层不同的文件，能够提高磁盘的读取效率；6.垂直分表；把一些不经常读的数据放在一张表里，节约磁盘I/O；7.主从分离读写；采用主从复制把数据库的读操作和写入操作分离开来；8.分库分表分机器（数据量特别大），主要的的原理就是数据路由；9.选择合适的表引擎，参数上的优化10.进行架构级别的缓存，静态化和分布式；11.不采用全文索引；12.采用更快的存储方式，例如',NULL,'0','0','0','2','2022-08-21 17:21:16','2022-08-21 17:21:16'),('270','3','请写出ArrayList、LinkedList、vector的区别？','3','2',NULL,'ArrayList和LinkedList都间接的实现了List接口，都不是线程安全的(Vector是线程安全的)。ArrayList底层是基于数组结构，而LinkedList底层是基于链表(双链表)结构。ArrayList的查询修改快，LinkedList的增删速度快。ArrayList扩容是增长原来的一半也就是1.5倍(Vector是增长原来的2倍)，LinkedList是基于节点来扩容的。ArrayList初始化容量大小是10，vector初始化容量也是10。',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('271','3','String、StringBuffer与StringBuilder之间区别？','3','2',NULL,'String为字符串常量，一旦被创建就不能修改它的值，对于已经存在的String对象修改都是重新创建一个新的对象，释放原String对象。String是final类，不能被继承。StringBuffer和StringBuilder都是字符串变量，对它修改时不会像String那样重新建立对象，StringBuffer和StringBuilder只能通过构造来创建，不能通过赋值符号&quot; = &quot;来赋值，初始化为null，通过构造参数或append方法来完成赋值操作。在字符串的操作中sb的效率要高于String。在一般情况下执行速度：StringBuilder &gt; StringBuffer &gt; String；特殊情况：String的效率大于StringBuffer/StringBuilderStringstr=&ldquo;Thisisonlya&rdquo;+&ldquo;simple&rdquo;+&ldquo;test&rdquo;;St',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('272','3','请说出几种减少页面加载时间得方法','3','2',NULL,'a)优化图片b)减少http请求c)压缩并且合并css',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('273','3','Javascript如何实现继承?','3','2',NULL,'原型链继承,借用构造函数继承,组合继承,寄生式继承,寄生组合继承',NULL,'1','1','1','3','2023-05-26 10:22:16','2023-05-26 10:22:16'),('274','3','简述servlet的生命周期？','3','2',NULL,'servlet的生命周期分为三个阶段： 1、初始化阶段，调用init()方法如果在web.xml的servlet标签中添加&lt;loadon-startup&gt;1&lt;/loadon-startup&gt;。那么启动服务器时加载servlet并创建servlet对象，在调用init方法初始化配置。如果没配置启动项，那么当首次访问servlet时servlet对象并调用init方法初始化servlet。init()方法只执行一次，也就是说servlet是一个单例。2、响应客户请求阶段 调用service()方法每次请求servlet时，servlet容器会创建请求的ServletRequest对象和ServletResponse对象，然后调用Servlet的service方法。service方法从ServletRequest对象获得客户请求信息，处理该请求，并通过ServletResponse对象向客户返回响应信息。3、销毁阶段 调用destroy()',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('275','3','前端页面有哪三层构成这三层分别是什么','3','2',NULL,'结构层，表示层，行为层（行为层是js操作dom得主体部分）',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('276','3','输出数据库连接池的工作机制是什么？','3','2',NULL,'数据库连接池的工作机制: 数据库连接池在初始化时将创建一定数量的数据库连接放到连接池中，这些数据库连接的数量是由最小数据库连接数来设定的。无论这些数据库连接是否被使用，连接池都将一直保证至少拥有这么多的连接数量。连接池的最大数据库连接数量限定了这个连接池能占有的最大连接数，当应用程序向连接池请求的连接数超过最大连接数量时，这些请求将被加入到等待队列中。',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('277','3','Javascript创建对象的几种方式?','3','2',NULL,'工厂方式,构造函数方式,原型模式,混合构造函数原型模式,动态原型方式',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('278','3','简单说明dom事件冒泡','3','2',NULL,'假设一个元素div，有一个下级元素p，，两个元素都绑定了click事件，用户点击了p，p先触发，div后触发，这就是事件冒泡',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('279','3','闭包是什么，有什么特性，对页面有什么影响','3','1',NULL,'闭包是一个封闭的隔离的空间，在js中表现为函数所构成的外部无法访问的区域，当函数被外部引用时，就创建了该函数的闭包闭包的实质是一个函数，是一个用于返回局部变量值的函数，因为在全局中，受JavaScript链式作用域结构的影响，父级变量中无法访问到子级的变量值，为了解决这个问题，才使用闭包这个概念。闭包的特性：①.封闭性：外界无法访问闭包内部的数据，如果在闭包内声明变量，外界是无法访问的，除非闭包主动向外界提供访问接口；②.持久性：一般的函数，调用完毕之后，系统自动注销函数，而对于闭包来说，在外部函数被调用之后，闭包结构依然保存在系统中，闭包中的数据依然存在，从而实现对数据的持久使用。优点：①减少全局变量。②减少传递函数的参数量③封装；缺点：使用闭包会占有内存资源，过多的使用闭包会导致内存泄露等.',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('280','3','阻止事件冒泡','3','2',NULL,'functionstopPropagation(e){e=e||window.event;if(e.stopPropagation){e.stopPropagation();}else{e.cancelBubble=true;//DOM阻止冒泡方法//IE阻止冒泡方法}}<pre><code class=\"language-javascript\">\"function stopPropagation(e) { e = e || window.event; if(e.stopPropagation) { e.stopPropagation(); } else { e.cancelBubble = true;',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('281','3','你如何优化自己的代码?','3','2',NULL,'代码重用避免全局变量(命名空间,封闭空间,模块化mvc..) 拆分函数避免函数过于臃肿:单一职责原则适当的注释,尤其是一些复杂的业务逻辑或者是计算逻辑,都应该写出这个业务逻辑的具体过程内存管理,尤其是闭包中的变量释放',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('282','3','请尽可能详尽的解释ajax思路:先解释异步,再解释ajax如何使用(后面还有专题)','3','2',NULL,'Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求,从服务器获得据,然后用javascript来操作DOM而更新页面.这其中最关键的一步就是从服务器获得请求数据.要清楚这个过程和原理,我们必须对XMLHttpRequest有所了解.XMLHttpRequest是ajax的核心机制,它是在IE5中首先引入的,是一种支持异步请求的技术.简单的说,也就是javascript可以及时向服务器提出请求和处理响应,而不阻塞用户.达到无刷新的效果',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('283','3','HTTP协议中,GET和POST有什么区别?分别使用什么场景?','3','2',NULL,'get传送的数据长度有限制,post没有get通过url传递,在浏览器地址栏可见,post是在报文中传递post一般用于表单提交. get一般用于简单的数据查询,严格要求不是那么高的场景',NULL,'1','1','1','3','2023-05-26 10:22:16','2023-05-26 10:22:16'),('284','3','那些操作会造成HTML页面回流与重绘','3','1',NULL,'调整窗口大小；改变字体大小；样式表变动；元素内容变化，尤其是输入控件；CSS伪类激活；DOM操作；offsetWidth,width,clientWidth,scrollTop/scrollHeight的计算，会使浏览器将渐进回流队列Flush，立即执行回流。',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('285','3','写出冒泡排序的实现','3','2',NULL,'<pre><code>void bubble_sort(int arr[], int len) {      int i, j;      for (i = 0; i &lt; len - 1; i++)    //外层循环控制趟数，总趟数为len-1        for (j = 0; j &lt; len - 1 - i; j++)  //内层循环为当前i趟数 所需要比较的次数            if (arr[j] &gt; arr[j + 1])                  swap(arr[j], arr[j + 1]);          } </code></pre>',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('286','3','如何判断一个js变量是数组类型','3','2',NULL,'<pre><code class=\"language-javascript\">ES5:Array.isArray(); [] instanceof Array; 调用数组的 slice 方法; Object.prototype.toString.call([]); // \"[object Array]\" </code></pre>',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('287','3','integer如何判断相等','3','2',NULL,'Integer为对象判断是否相等还是使用equals最靠谱，int为基本类型，判断是否相等就是可以使用==',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('288','3','简述src和href的区别','3','2',NULL,'src是source的缩写，是在页面中引入某种资源,当浏览器解析到src时，会暂停浏览器的渲染，直到该资源加载完毕；href用于在当前文档和引用资源之间建立联系。',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('289','3','scss是什么?在vue.cli中的安装使用步骤是?有哪几大特性?','3','2',NULL,'css的预编译。 使用步骤: 第一步:用npm下三个loader(sass-loader、css-loader、node-sass)第二步:在build目录找到webpack.base.config.js，在那个extends属性中加一个拓展.scss第三步:还是在同一个文件，配置一个module属性 第四步:然后在组件的style标签加上lang属性，例如:lang=&rdquo;scss&rdquo; 有哪几大特性:1、可以用变量，例如($变量名称=值);2、可以用混合器，例如() 3、可以嵌套 5、mint-ui是什么?怎么使用?说出至少三个组件使用方法?答:基于vue的前端组件库。npm安装，然后import样式和&nbs',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('290','3','编写一个方法，去掉一个数组的重复元素','3','2',NULL,'去除重复的数组：* 方法一：需要一个存储去重后元素的数组，然后两层循环，外层遍历原数组，内容逐个判断是否和之后的元素重复，然后再提出来存入新的数组。方法System.arraycopy(被复制的数组，起始下标，接收的新数组，起始下标，结束下标);可以直接复制数组，既然这样，我就没必要纠结新数组的长度了，直接声明一个跟原数组长度一样的临时数组，只要记录下去重后的元素个数，然后就可以确定去重后数组长度再去将临时数组拷贝到新数组就行了。* 方法二:只需要创建一个集合，然后遍历数组逐一放入集合，只要在放入之前用contains()方法判断一下集合中是否已经存在这个元素就行了，然后用toArray转成数组一切搞定。* 方法三：最简单的方法就是利用Set集合无序不可重复的特性进行元素过滤。* 方法四：链表的哈希集合：有顺序，不重复。',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('291','3','newObject()的原理是什么？','3','2',NULL,'1)创建一个空对象，并且this变量引用该对象，同时还继承了该函数的原型。2)属性和方法被加入到this引用的对象中。3)新创建的对象由this所引用，并且最后隐式的返回this',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('292','3','axios+tp5进阶中，调用axios.post(&lsquo;api/user&rsquo;)是进行的什么操作?axios.put(&lsquo;api/user/8&prime;)呢?','3','2',NULL,'跨域，添加用户操作，更新操作。 9、什么是RESTfulAPI?怎么使用? 答:是一个api的标准，无状态请求。请求的路由地址是固定的， 如果是tp5则先路由配置中把资源路由配置好。标准有:.post.put.delete10、vuex是什么?怎么使用?哪种功能场景使用它? 答:vue框架中状态管理。在main.js引入store，注入。 新建了一个目录store，.....export。场景有:单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车11、mvvm框架是什么?它和其它框架(jquery)的区别是什么?哪些场景合?答:一个model+view+viewModel框架，数据模型model，viewModel连接两个区别:vue数据驱动，通过数据来',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('293','3','请写出常用的java多线程启动方式，Executors线程池有几种常用类型','3','2',NULL,'线程池作用就是限制系统中执行线程的数量。根据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果；少了浪费了系统资源，多了造成系统拥挤效率不高。用线程池控制线程数量，其他线程 排队等候。一个任务执行完毕，再从队列的中取最前面的任务开始执行。若队列中没有等待进程，线程池的这一资源处于等待。当一个新任务需要运行时，如果线程 池中有等待的工作线程，就可以开始运行了；否则进入等待队列。Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。ThreadPoolExecutor是Executors类的底层实现。',NULL,'1','1','1','3','2023-05-26 10:22:16','2023-05-26 10:22:16'),('294','3','请介绍你知道的多线程并发控制方法','3','2',NULL,'线程池、线程同步、互斥锁、读写锁、原子数、唤醒、通知、信号量、线程交换队列',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('295','3','typescript和javascript有和异同？','3','2',NULL,'typescript是javascript的超集，它可以编译成纯javascript；typescript是对es6的具体实现，引入了数据类型的概念，声明一个变量的时候如果指定了数据类型，那么赋值的时候要给其对应数据类型的值，否则程序会报错。Typescript中使用class来声明一个类，通过extends关键字来实现继承。简言之typescript使得前端开发和后端开发越来越接近。',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('296','3','jdk9新特性有哪些','3','3',NULL,'1. Java 平台级模块系统。2. Linking。3. JShell : 交互式 Java REPL。4. 改进的 Javadoc。5. 集合工厂方法改进的 。6.Stream API。7. 私有接口方法。8. HTTP/2。9. 多版本兼容 JAR',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('297','3','序列化的作用是什么','3','3',NULL,'序列化就是一种用来处理对象流的机制，所谓对象流也就是将对象的内容进行流化。可以对流化后的对象进行读写操作，也可将流化后的对象传输于网络之间。序列化是为了解决对象流读写操作时可能引发的问题（如果不进行序列化可能会存在数据乱序的问题）。要实现序列化，需要让一个类实现Serializable接口，该接口是一个标识性接口，标注该类对象是可被序列化的，然后使用一个输出流来构造一个对象输出流并通过writeObject(Object)方法就可以将实现对象写出（即保存其状态）；如果需要反序列化则可以用一个输入流建立对象输入流，然后通过readObject方法从流中读取对象。序列化除了能够实现对象的持久化之外，还能够用于对象的深度克隆',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('298','3','GC得回收机制','3','4',NULL,'GC就是垃圾回收机制：在系统运行过程中，会产生一些无用的对象，这些对象占据着一定的内存，如果不对这些对象清理回收无用对象的内存，可能会导致内存的耗尽，所以垃圾回收机制回收的是内存。同时GC回收的是堆区和方法区的内存。',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('299','3','简述Javascript的垃圾回收机制','3','1',NULL,'现在各大浏览器通常用采用的垃圾回收有两种方法：标记清除、引用计数。标记清除：这是javascript中最常用的垃圾回收方式。当变量进入执行环境是，就标记这个变量为&ldquo;进入环境&rdquo;。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到他们。当变量离开环境时，则将其标记为&ldquo;离开环境&rdquo;。垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。引用计数：另一种不太常见的垃圾回收策略是引用计数。引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变成0时',NULL,'1','1','1','3','2022-08-21 17:21:16','2022-08-21 17:21:16'),('3','1','下面关于线程创建的定义不正确的有（）','1','1',NULL,'',NULL,'1','1','1','1','2023-05-26 10:22:16','2023-05-26 10:22:16'),('30','6','多线程通信','3','2',NULL,'1使用volatile进行线程之间的通信2wait/notify的方法3CountDownLatch实现线程间通信',NULL,'0','0','0','2','2023-05-26 10:22:16','2023-05-26 10:22:16'),('300','4','有如下一串数字1,1,2,3,5,8...用算法实现第二十个数字的值是什么（提示：递归算法）','3','2',NULL,'<pre><code>public class Test1 {   public static void main(String[] args) {  System.out.print(1+\",\");  System.out.print(1+\",\");  int f1 = 1, f2 = 1, f, M=10;       for(int i=3; i&lt;=M; i++) {        f = f2;        f2 = f1 + f2;        f1 = f;        System.out.print(f2+\",\");           }  }  }</code></pre>',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('301','4','你了解使用过哪些算法？','3','3',NULL,'见的算法和数据结构：字符串，链表，树，图，排序，递归 vs. 迭代，动态规划，位操作，概率问题，排列组合，',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('302','4','String、StringBuffer和StringBuilder之间的区别','3','2',NULL,'这三个类之间的区别主要是在两个方面，即运行速度和线程安全这两方面。1、首先说运行速度，或者说是执行速度，在这方面运行速度快慢为：StringBuilder &gt; StringBuffer &gt; String　　String最慢的原因：　　String为字符串常量，而StringBuilder和StringBuffer均为字符串变量，即String对象一旦创建之后该对象是不可更改的，但后两者的对象是变量，是可以更改的。2、在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的。3、总结一下：   String：适用于少量的字符串操作的情况　　StringBuilder：适用于单线程下在字符缓冲区进行大量操作的情况　　StringBuffer：适用多线程下在字符缓冲区进行大量操作的情况',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('303','4','请解释一下<strong>JavaScript</strong>的同源策略。','3','2',NULL,'同源策略是客户端脚本(尤其是Javascript)的重要的安全度量标准。它最早出自NetscapeNavigator2.0，其目的是防止某个文档或脚本从多个不同源装载。所谓同源指的是:协议，域名，端口相同，同源策略是一种安全协议，指一段脚本只能读取来自同一来源的窗口和文档的属性。',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('304','4','JavaEE中的设计模式有哪些？谈谈你对工厂模式的理解？','3','4',NULL,'Java中的23种设计模式：Factory（工厂模式），   Builder（建造模式），    Factory Method（工厂方法模式）， Prototype（原始模型模式），Singleton（单例模式），  Facade（门面模式）， Adapter（适配器模式），  Bridge（桥梁模式），    Composite（合成模式）， Decorator（装饰模式），  Flyweight（享元模式），   Proxy（代理模式）， Command（命令模式），   Interpreter（解释器模式）， Visitor（访问者模式）， Iterator（迭代子模式），  Mediator（调停者模式），  Memento（备忘录模式），<br /',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('305','4','多线程(实现多线程的三种方式)','3','1',NULL,'1、 继承Thread类实现多线程2、 实现Runnable接口方式实现多线程3、通过线程池创建线程',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('306','4','ArrayList 和 LinkedList 有什么区别。','3','2',NULL,'ArrayList和LinkedList都实现了List接口，有以下的不同点：1、ArrayList是基于索引的数据接口，它的底层是数组。它可以以O(1)时间复杂度对元素进行随机访问。与此对应，LinkedList是以元素列表的形式存储它的数据，每一个元素都和它的前一个和后一个元素链接在一起，在这种情况下，查找某个元素的时间复杂度是O(n)。2、相对于ArrayList，LinkedList的插入，添加，删除操作速度更快，因为当元素被添加到集合任意位置的时候，不需要像数组那样重新计算大小或者是更新索引。3、LinkedList比ArrayList更占内存，因为LinkedList为每一个节点存储了两个引用，一个指向前一个元素，一个指向下一个元素。',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('307','4','数据库里面的索引和约束是什么?','3','2',NULL,'索引是为了提高数据的检索速度，索引是建立在数据表上，根据一个或多个字段建立的约束是为了保持数据的完整性，约束有非空约束，主键约束，外键约束等等。',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('308','4','.Hibernate工作原理及为什么要用?','3','2',NULL,'原理： 1.读取并解析配置文件 2.读取并解析映射信息，创建SessionFactory 3.打开Session 4.创建事务Transation 5.持久化操作 6.提交事务 7.关闭Session 8.关闭SesstionFactory为什么要用： 1. 对JDBC访问数据库的代码做了封装，大大简化了数据访问层繁琐的重复性代码。 2. Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现。他很大程度的简化DAO层的编码工作 3. hibernate使用Java反射机制，而不是字节码增强程序来实现透明性。 4. hibernate的性能非常好，因为它是个轻量级框架。映射的灵活性很出色。它支持各种关系数据库，从一对一到多对多的各种复杂关系。',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('309','4','Bean 工厂和 Application contexts 有什么区别？','3','2',NULL,'Application contexts提供一种方法处理文本消息，一个通常的做法是加载文件资源（比如镜像），它们可以向注册为监听器的bean发布事件。另外，在容器或容器内的对象上执行的那些不得不由bean工厂以程序化方式处理的操作，可以在Application contexts中以声明的方式处理。Application contexts实现了MessageSource接口，该接口的实现以可插拔的方式提供获取本地化消息的方法。',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('31','6','说明Session和Cookie的联系','3','2',NULL,'Session对Cookie的依赖：Cookie采用客户端存储，Session采用的服务端存储的机制。Session是针对每个用户（浏览器端）的，Session值保存在服务器上，通过SessionId来区分哪个用户的Session。因此SessionId需要被绑定在浏览器端。SessionId通常会默认通过Cookie在浏览器端绑定，当浏览器端禁用cookie时，可通过Url重写（可以在地址栏看到sessionid=KWJHUG6JJM65HS2K6之类的字符串）或者表单隐藏字段的方式将SessionId传回给服务器，以便服务通过SessionId获取客户端对应的Session。具体一次的请求流程：当程序需要为客户端创建一个Session的时候，服务器首先检测这个客户端请求里面是否已经包含了Session的表示（Se',NULL,'0','0','0','2','2023-05-26 10:22:16','2023-05-26 10:22:16'),('310','4','Enumeration和Iterator的主要区别','3','2',NULL,'（1）java中的集合类都提供了返回Iterator的方法，就是迭代器，它和Enumeration（枚举）的主要区别其实就是Iterator可以删除元素，但是Enumration却不能。（2）还有一点要注意的就是，使 用Iterator来遍历集合时，应使用Iterator的remove()方法来删除集合中的元素，使用集合的remove()方法将抛出ConcurrentModificationException异常。（3）Enumeration 接口的功能与 Iterator 接口的功能是重复的。此外，Iterator 接口添加了一个可选的移除操作，并使用较短的方法名。新的实现应该优先考虑使用 Iterator 接口而不是Enumeration 接口。',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('311','4','Http有没有状态，如果没有状态，怎么解决http无状态？','3','2',NULL,'无状态的，一般使用cookie和session技术做会话跟踪',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('312','4','什么是分布式锁？','3','3',NULL,'控制分布式系统之间同步访问共享资源的一种方式。在分布式系统中，常常需要协调他们的动作。如果不同的系统或是同一个系统的不同主机之间共享了一个或一组资源，那么访问这些资源的时候，往往需要互斥来防止彼此干扰来保证一致性，在这种情况下，便需要使用到分布式锁。',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('313','4','int和integer区别？','3','2',NULL,'（1）Integer是int的包装类；int是基本数据类型；（2）Integer变量必须实例化后才能使用；int变量不需要；（3）Integer实际是对象的引用，指向此new的Integer对象；int是直接存储数据值 ；（4）Integer的默认值是null；int的默认值是0。',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('314','4','对ES678了解吗？如果了解请列举','3','2',NULL,'ES6中新增的特性：箭头操作符（箭头函数）类的支持（class关键字）增强的对象字面量字符串模板let与const关键字模块',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('315','4','maven依赖路径最短优先原则','3','2',NULL,'一个项目Demo依赖了两个jar包，其中A-B-C-X(1.0) ， A-D-X(2.0)。由于X(2.0)路径最短，所以项目使用的是X(2.0)。',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('316','4','如何解决jar冲突','3','2',NULL,'遇到冲突的时候第一步要找到maven加载的到时是什么版本的jar包，通过们mvn dependency:tree查看依赖树，通过maven的依赖原则来调整坐标在pom文件的申明顺序是最好的办法。',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('318','4','请说出vue.cli项目中src目录每个文件夹和文件的用法？','3','2',NULL,'assets文件夹是放静态资源；components是放组件；router是定义路由相关的配置;view视图；app.vue是一个应用主组件；main.js是入口文件',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('319','4','active-class是哪个组件的属性?嵌套路由怎么定义?','3','2',NULL,'<strong>vue-router模块的router-link组件。 2、怎么定义vue-router的动态路由?怎么获取传过来的动态参数?答:在router目录下的index.js文件中，对path属性加上/:id。使用router对象的params.idvue-router有哪几种导航钩子?答:三种，一种是全局导航钩子:router.beforeEach(to,from,next)，作用:跳转前进行判断拦截。第二种:组件内的钩子;第三种:单独路由独享组件4、scss是什么?安装使用的步骤是?有哪几大特性? 答:预处理css，把css当前函数编写，定义变量,嵌套。先装css-loader、node-loader、s',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('32','7','列举Java中的数据类型','3','2',NULL,'a) boolean、byte、char、short、int、float、douboe、long',NULL,'0','0','0','2','2023-05-26 10:22:16','2023-05-26 10:22:16'),('320','4','axios+tp5进阶中，调用axios.post(&lsquo;api/user&rsquo;)是进行的什么操作?axios.put(&lsquo;api/user/8&prime;)呢?','3','2',NULL,'跨域，添加用户操作，更新操作。 9、什么是RESTfulAPI?怎么使用? 答:是一个api的标准，无状态请求。请求的路由地址是固定的， 如果是tp5则先路由配置中把资源路由配置好。标准有:.post.put.delete10、vuex是什么?怎么使用?哪种功能场景使用它? 答:vue框架中状态管理。在main.js引入store，注入。 新建了一个目录store，.....export。场景有:单页应用中，组件之间的状态。音乐播放、登录状态、加入购物车11、mvvm框架是什么?它和其它框架(jquery)的区别是什么?哪些场景合?答:一个model+view+viewModel框架，数据模型model，viewModel连接两个区别:vue数据驱动，通过数据来',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('321','4','SESSION 与COOKIE 的区别是什么？','3','2',NULL,'cookie 是存放在浏览器端，不同的浏览器存储的cookie数量和数据的大小都不一致。大多数情况下单个域名限制最多保存20个cookie，每个cookie保存的数据不能超过4K。session存储在服务端，默认是以文件的形式存储，也可以存储在数据库和redis、memcache等缓存内存中',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('322','4','Vue的双向数据绑定原理是什么?','3','2',NULL,'vue.js是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。具体步骤:第一步:需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化第二步:compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图第三步:Watcher订阅者是Observer和Compile之间',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('323','4','谈谈angularjs最核心的东西','3','1',NULL,'最为核心的是：MVC模块化自动化双向数据绑定语义化标签、依赖注入等等',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('324','4','vue-loader是什么?使用它的用途有哪些? ','3','2',NULL,'解析.vue文件的一个加载器，跟template/js/style转换成js模块。用途:js可以写es6、style样式可以scss或less、template可以加jade等',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('325','4','请说出vue.cli项目中src目录每个文件夹和文件的用法?','3','2',NULL,'<strong><strong>assets</strong>文件夹是放静态资源;<strong>components</strong>是放组件;<strong>router</strong>是定义路由相关的配置<strong>;view</strong>视图;<strong>app.vue</strong>是一个应用主组件;<strong>main.js</strong>是入口文件</strong>',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('326','4','说明 PHP 中传值和传引用的区别?','3','2',NULL,'传值：是把实参的值赋值给形参，那么对形参的修改，不会影响实参的值传地址：是传值的一种特殊方式，只是他传递的是地址，不是普通的如int那么传地址以后，实参和形参都指向同一个对象传引用：真正的以地址的方式传递参数传递以后，形参和实参都是同一个对象，只是他们名字不同而已对形参的修改将影响实参的值',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('327','4','vue/angular单页应用有哪些优缺点？','3','2',NULL,'优点：速度：更好的用户体验，让用户在webapp感受nativeapp的速度和流畅，MVC：经典MVC开发模式，前后端各负其责。ajax：重前端，业务逻辑全部在本地操作，数据都需要通过AJAX同步、提交。路由：在URL中采用#号来作为当前视图的地址,改变#号后的参数，页面并不会重载。分离前后端关注点，前端负责界面显示，后端负责数据存储和计算，各司其职，不会把前后端的逻辑混杂在一起；减轻服务器压力，服务器只用出数据就可以，不用管展示逻辑和页面合成，吞吐能力会提高几倍；同一套后端程序代码，不用修改就可以用于Web界面、手机、平板等多种客户端；缺点：SEO问题，现在可以通过Prerender等技术解决一部分；前进、后退、地址栏等，需要程序进行管理；书签，需要程序来提供支持；',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('328','4','vue框架的优缺点','3','2',NULL,'优点：Vue.js是一个构建数据驱动的web界面的渐进式框架。Vue.js的目标是通过尽可能简单的API实现响应的数据绑定和组合的视图组件。核心是一个响应的数据绑定系统。1.轻量级的框架2.双向数据绑定3.指令4.插件化缺点：不支持低端浏览器。',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('329','4','2.vue的HTTP请求的原理？','3','2',NULL,'vue1.0中的$http服务需要引入一个叫vue-resource.js的文件，因为vue.js中没有$http服务。如果需要使用这个服务去百度下载vue-resource.js然后引进项目即可。vue2.0版本引入axios',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('33','7','Http有没有状态，如果没有状态，怎么解决http无状态？','3','1',NULL,'无状态的，一般使用cookie和session技术做会话跟踪',NULL,'0','0','0','2','2023-05-26 10:22:16','2023-05-26 10:22:16'),('330','4','3.瀑布流实现的原理？','3','2',NULL,'瀑布流布局要求要进行布置的元素等宽，然后计算元素的宽度与浏览器宽度之比，得到需要布置的列数。创建一个数组，长度为列数，里面的值为已布置元素的总高度（最开始为0）然后将未布置的元素依次布置到高度最小的那一列，就得到了瀑布流布局。',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('331','4','JQeury常用的API有哪些？','3','2',NULL,'<pre><code class=\"language-javascript\">\"jQuery使用addClass()方法给元素加class$(\"\".well\"\").addClass(\"\"animated shake\"\");jQuery根据id属性来获取元素渐变隐藏效果$(\"\"#target3\"\").addClass(\"\"animated fadeOut\"\");三种选择器元素选择器：$(\"\"button\"\")class选择器：$(\"\".btn\"\")id选择器：$(\"\"#target1\"\")使用jQUery删除HTML元素的class$(\"\"#target2\"\").removeClass(\"\"btn-default\"\");使用jQUery改变HTML元素的css样式选择器.css(“属性”,”值”);$(\"\"#target1\"\").css(\"\"color\"\",\"\"red\"\");使用jQUery设置元素不可用$(\"\"#target1\"\").prop(\"\"disabled\"\",true);jQuery使用text()改变文本内',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('332','4','如何做上传二进制流图片？','3','5',NULL,'<pre><code class=\"language-javascript\">\"function convertImgToBase64(url, callback, outputFormat){    var canvas = document.createElement(\'CANVAS\'),        ctx = canvas.getContext(\'2d\'),        img = new Image;    img.crossOrigin = \'Anonymous\';    img.onload = function(){        canvas.height = img.height;        canvas.width = img.width;        ctx.drawImage(img,0,0);        var dataURL = canvas.toDataURL(outputFormat || \'image/png\');        callback.call(this, dataURL); ',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('333','4','H5的离线缓存？','3','2',NULL,'HTML5提供了很多新的功能以及相应的接口，离线存储就是其中的一个，离线存储可以将站点的一些文件存储在本地，在没有网络的时候还是可以访问到以缓存的对应的站点页面，其中这些文件可以包括html，js，css，img等等文件，但其实即使在有网络的时候，浏览器也会优先使用已离线存储的文件，返回一个200（fromcache）头。这跟HTTP的缓存使用策略是不同的。它是浏览器自己的一种机制，随着移动互联网时代的到来，网络可靠性降低，如果我们已经将需要的文件缓存下下来，一旦网络无法访问，也能继续访问。而且做好相应资源的缓存可以带来更好的用户体验，当用户使用自己的流量上网时，本地缓存不仅可以提高用户访问速度，而且大大节约用户的使用流量。什么是Manifest：其实Manifest是一个简单的文本文件，它的扩展名是任意',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('334','4','H5的数据存储？','3','2',NULL,'HTML5的本地存储API中的localStorage与sessionStorage在使用方法上是相同的，区别在于sessionStorage在关闭页面后即被清空，而localStorage则会一直保存。',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('335','4','简单解释CGI,fastCGI,PHP-FPM','3','4',NULL,'CGI：CGI的英文是（COMMON GATEWAY INTERFACE）公共网关接口，它的作用就是帮助服务器与语言通信。是 Web Server 与 Web Application 之间数据交换的一种协议。FastCGI：同 CGI，是一种通信协议，但比 CGI 在效率上做了一些优化，fast-cgi则是一个进程可以处理多个请求。PHP-CGI：是 PHP （Web Application）对 Web Server 提供的 CGI协议的接口程序。PHP-FPM：是 PHP（Web Application）对 Web Server 提供的 FastCGI 协议的接口程序，额外还提供了相对智能一些任务管理',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('336','4','什么是媒体查询？','3','1',NULL,'CSS3媒体查询，就是根据页面分辨率设置不同的css样式，达到自适应的目的。',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('337','4','PHP的垃圾收集机制是怎样的','3','4',NULL,'在PHP5.3版本之前，PHP只有简单的基于引用计数的垃圾回收，当一个变量的 引用计数变为0时， PHP将在内存中销毁这个变量，只是这里的垃圾并不能称之为垃圾。 并且PHP在一个生命周期结束后就会释放此进程/线程所占的内容，这种方式决定了PHP在前期不需要过多考虑内存的泄露问题。 但是随着PHP的发展，PHP开发者的增加以及其所承载的业务范围的扩大，在PHP5.3中引入了更加完善的垃圾回收机制。 新的垃圾回收机制解决了无法处理循环的引用内存泄漏问题。PHP5.3中的垃圾回收机制使用了文章 引用计数系统中的同步周期回收(Concurrent Cycle Collection in Reference Counted Systems) 中的同步算法。关于这个算法的介绍我们就不再赘述，在PHP的官方文档有图文并茂的介绍： 回收周期(Collecting Cycles)。',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('338','4','如何清除浮动？','3','1',NULL,'<pre><code class=\"language-xhtml\">\"　方式一:使用overflow属性来清除浮动.ovh{overflow:hidden;}先找到浮动盒子的父元素，再在父元素中添加一个属性：overflow:hidden,就是清除这个父元素中的子元素浮动对页面的影响.注意：一般情况下也不会使用这种方式，因为overflow:hidden有一个特点，离开了这个元素所在的区域以后会被隐藏（overflow:hidden会将超出的部分隐藏起来）.　方式二:使用额外标签法.clear{clear:both;}在浮动的盒子之下再放一个标签，在这个标签中使用clear:both，来清除浮动对页面的影响.a.内部标签：会将这个浮动盒子的父盒子高度重新撑开.b.外部标签：会将这个浮动盒子的影响清除，但是不会撑开父盒子.注意：一般情况下不会使用这一种方式来清除浮动。因为这种清除浮动的方式会增加页面的标签，造成结构的混乱.方法三:使用伪元素来清除浮动(after意思:后来,以后).clearfix:after{content:\"\"\"\";//设置',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('339','4','如何处理多服务器共享 Session ?','3','4',NULL,'数据库/文件同步 sessioncookie 同步 session缓存 (如 memcache ）同步 session',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('340','4','eval是做什么的？','3','2',NULL,'　eval执行会根据上下文来判断改变的变量时局部的还是全局的，所以使用eval函数，关键是看清引用eval的作用域！',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('341','4','redis和memcached的区别','3','4',NULL,'1、网络IO模型：memcached是多线程，非阻塞IO复用的网络模型；redis使用单线程的IO复用模型，对于单存只有IO操作来说，单线程可以将速度优势发挥到最大，但是redis也提供了一些简单的计算功能。2、数据支持类型memcached使用key-value形式存储和访问数据，内存维护一张大的Hash表；redis支持的数据类型：String、Hash、List、Set和SortedSet。注：了解每种数据类型的运用场景，每个至少能举出一个例子。3、内存管理机制Memcached使用预分配的内存池的方式。按照预先规定的大小将分配的内存分割成特定长度的块以存储相应长度的key-value数据；redis定义一个数组来记录所有的内存分配方式的；4、数据存储及持久化memcached不支持持久化；redis持久化两种方式：1、快照（snapshotting）2、只追加式文件（AOF）5、数据一致',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('342','4','js的数据类型？','3','1',NULL,'js中有六种数据类型，包括五种基本数据类型（Number,String,Boolean,Undefined,Null）,和一种复杂数据类型（Object）',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('343','4','在大型项目中，很多数据会采用nosql数据库去缓存数据。但是会出现缓存穿透的情况，简单说下什么是缓存穿透，包括其解决方案','3','5',NULL,'缓存穿透：1：对查询结果为空的情况也进行缓存，缓存时间设置短一点，或者该key对应的数据insert了之后清理缓存。2：对一定不存在的key进行过滤。可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤缓存雪崩：1：在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量。比如对某个key只允许一个线程查询数据和写缓存，其他线程等待。2：不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。3：做二级缓存，A1为原始缓存，A2为拷贝缓存，A1失效时，可以访问A2，A1缓存失效时间设置为短期，A2设置为长期在大型项目中，很多数据会采用nosql数据库去缓存数据。但是会出现缓存穿透的情况，',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('344','4','说说多线程？','3','2',NULL,'使用threading这个高级模块，启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量把内容给改乱了。锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，坏处当然也很多首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。其次，由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。多线程编程，模型复杂，容易发生冲突，必须用锁加以隔离，同时，又要小心死锁的发生。Python解释器由于设计时有GIL全局锁，导致了多线程无法利用多核。多线程的并发在Python中就是一个美丽的梦。Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('345','4','防盗链的原理和实现方式？','3','4',NULL,'原理：通过判断request请求头的refer是否来源于本站。实现方式：1）Apache 防盗链的第一种实现方法，可以用 Rewrite 实现。首先要确认 Apache 的 rewrite module 可用：能够控制 Apache httpd.conf 文件的，打开 httpd.conf，确保有这么一行配置：LoadModule rewrite_module modules/mod_rewrite.so然后在相应虚拟主机配置的地方，加入下列代码：ServerNamewww.itcast.com# 防盗链配置 参数RewriteEngine OnRewriteCond %{HTTP_REFERER} !^http://itcast.com/.*$ [NC]RewriteCond %{HTTP_REFERER} !^http://itcast.com$&nb',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('346','4','redis的数据类型','3','1',NULL,'string、list、set、zset、hash',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('347','4','正则中贪婪与非贪婪的区别','3','2',NULL,'&lt;.*&gt;是贪婪匹配，会从第一个&ldquo;&lt;&rdquo;开始匹配，直到最后一个&ldquo;&gt;&rdquo;中间所有的字符都会匹配到，中间可能会包含&ldquo;&lt;&gt;&rdquo;。&lt;.*?&gt;是非贪婪匹配，从第一个&ldquo;&lt;&rdquo;开始往后，遇到第一个&ldquo;&gt;&rdquo;结束匹配，这中间的字符串都会匹配到，但是不会有&ldquo;&lt;&gt;&rdquo;。',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('348','4','常见的linux命令（不含参数）','3','1',NULL,'cd 切换路径  pwd 显示当前位置 who 显示当前登录的账号 rm 删除 ls 显示当前路径下的所有文件 chmod 修改权限 cat 查看文件内容 tar 打包/压缩 ps 查看进程',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('349','4','说说多线程？','3','2',NULL,'使用threading这个高级模块，启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量把内容给改乱了。锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，坏处当然也很多首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。其次，由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。多线程编程，模型复杂，容易发生冲突，必须用锁加以隔离，同时，又要小心死锁的发生。Python解释器由于设计时有GIL全局锁，导致了多线程无法利用多核。多线程的并发在Python中就是一个美丽的梦。Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('35','7','用Python匹配HTMLtag的时候，&lt;.*&gt;和&lt;.*?&gt;有什么区别？','3','2',NULL,'术语叫贪婪匹配(&lt;.*&gt;)和非贪婪匹配(&lt;.*?&gt;)。',NULL,'0','0','0','1','2023-05-26 10:22:16','2023-05-26 10:22:16'),('350','4','说说多线程？','3','2',NULL,'使用threading这个高级模块，启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量把内容给改乱了。锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，坏处当然也很多首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。其次，由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。多线程编程，模型复杂，容易发生冲突，必须用锁加以隔离，同时，又要小心死锁的发生。Python解释器由于设计时有GIL全局锁，导致了多线程无法利用多核。多线程的并发在Python中就是一个美丽的梦。Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('351','4','vue前后端分离项目怎么进行seo优化？','3','2',NULL,'spa开发模式的最大问题就是搜索引擎无法爬取页面内容，因为页面是通过http请求服务端接口数据动态渲染的，但是搜索引擎不会等待这个过程，这就导致前后端分离项目的seo优化成为一个问题。对于vue项目来说，一般有两种解决方案：1.开启服务端渲染：首先安装ssr支持：npmi-Dvue-server-renderer；重要的是vue-server-renderer与vue版本必须一致匹配优点：可以做到真实数据实时渲染，完全可供SEO小蜘蛛尽情的爬来爬去；完全前后端同构，路由配置共享，不再影响服务器404请求。缺点：依旧只支持h5history的路由模式，配置比较麻烦、处理流程比较复杂(比对预渲染插件，复杂太多)；约束较多，不能随心所欲的乱放大招；对服务器会造成较大的压力，既然让浏览器更快的渲染了，那就得以占用服务器的性能来买单了2.使用prerender-spa-plugin插件',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('352','4','让你来设计接口需要考虑哪些？如何保障接口安全性?','3','5',NULL,'在具备接口文档和实现所需功能的基础之上，需要着重考虑到接口安全问题。如项目需要，则可以从以下几个角度去考虑：1、服务器环境安全，2、数据传输安全，3、身份认证，4、数据完整性校验。',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('353','4','装饰器','3','2',NULL,'装饰器本质上是一个Python函数，它可以在让其他函数在不需要做任何代码的变动的前提下增加额外的功能。 装饰器的返回值也是一个函数的对象，它经常用于有切面需求的场景。 比如：插入日志、性能测试、事务处理、缓存、权限的校验等场景 有了装饰器就可以抽离出大量的与函数功能本身无关的雷同代码并发并继续使用。',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('354','4','lambda函数','3','2',NULL,'lambda 函数是一个可以接收任意多个参数(包括可选参数)并且返回单个表达式值的函数1、lambda 函数比较轻便，即用即仍，很适合需要完成一项功能，但是此功能只在此一处使用，连名字都很随意的情况下；2、匿名函数，一般用来给 filter， map 这样的函数式编程服务;3、作为回调函数，传递给某些应用，比如消息处理',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('355','4','python的内存回收？','3','3',NULL,'内存管理机制：引用计数、垃圾回收、内存池。引用计数：引用计数是一种非常高效的内存管理手段， 当一个 Python 对象被引用时其引用计数增加1， 当其不再被一个变量引用时则计数减 1. 当引用计数等于0时对象被删除。垃圾回收 ：1. 引用计数引用计数也是一种垃圾收集机制，而且也是一种最直观，最简单的垃圾收集技术。当 Python 的某个对象的引用计数降为 0 时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。比如某个新建对象，它被分配给某个引用，对象的引用计数变为 1。如果引用被删除，对象的引用计数为 0，那么该对象就可以被垃圾回收。不过如果出现循环引用的话，引用计数机制就不再起有效的作用了2. 标记清除如果两个对象的引用计数都为 1，但是仅仅存在他们之间的循环引用，那么这两个对象都是需要被回收的，也就是说，它们的引用计数虽然表现为非 0，但实际上有效的引用计数为 0。所以先将循环引用摘掉，就会得出这两个对象的有效计数。3. 分代回收<br ',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('356','4','项目中密码的加密方式？','3','3',NULL,'使用的是django自带的用户认证系统，用的是sha256加密、对称加密、非对称机密、不可逆加密',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('357','4','怎么看进程，杀死？','3','1',NULL,'ps -aux |grep 进程名字  kill -9 进程id             ',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('358','4','进程、线程、协程 的理解 ？','3','2',NULL,'进程包括线程 进程占用cpu资源大 线程其次 ，协程最小 进程是分配资源单位 线程是程序调度的单位吗，协程主要的目的是 利用消耗时间处于协调作用 进程相当于一个工厂 线程是工厂的生产线 协程是生产线的工人',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('359','4','多线程 进程 以及锁的运用？','3','3',NULL,'多线程：一个程序是有一个主进程 线程里面 可以有多个子线程 线程之间更相数据多进程：相当于多个程序 多个进程同时展开 不共享数据 可以理解 一个qq是一个进程 可以同时开多个qq锁 python中提供的对线程控制的对象 有互斥锁 死锁等 互斥锁保证在同一时间内cpu必须执行完当前的代码 死锁是有多个 互斥锁嵌套发生搓澡 造成死锁，GIL全局解释器锁 作用是限制多线程同时执行 保证同一时间 只有一个线程执行 所以cpython中多线程其实就是为多线程更改办法 换成java python或者，协程',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('36','1','Python里面如何生成随机数？','3','2',NULL,'使用random模块。1）随机整数：random.randint(a,b)：返回随机整数x,a&lt;=x&lt;=brandom.randrange(start,stop,[,step])：返回一个范围在(start,stop,step)之间的随机整数，不包括结束值。2）随机实数：random.random():返回0到1之间的浮点数random.uniform(a,b):返回指定范围内的浮点数。',NULL,'0','0','0','1','2023-05-26 10:22:16','2023-05-26 10:22:16'),('360','4','re匹配所有标点','3','1',NULL,'/W',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('361','4','常见的linux命令（不含参数）','3','1',NULL,'cd 切换路径  pwd 显示当前位置 who 显示当前登录的账号 rm 删除 ls 显示当前路径下的所有文件 chmod 修改权限 cat 查看文件内容 tar 打包/压缩 ps 查看进程',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('362','4','正则中贪婪与非贪婪的区别','3','2',NULL,'&lt;.*&gt;是贪婪匹配，会从第一个&ldquo;&lt;&rdquo;开始匹配，直到最后一个&ldquo;&gt;&rdquo;中间所有的字符都会匹配到，中间可能会包含&ldquo;&lt;&gt;&rdquo;。&lt;.*?&gt;是非贪婪匹配，从第一个&ldquo;&lt;&rdquo;开始往后，遇到第一个&ldquo;&gt;&rdquo;结束匹配，这中间的字符串都会匹配到，但是不会有&ldquo;&lt;&gt;&rdquo;。',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('363','4','redis的数据类型','3','1',NULL,'string、list、set、zset、hash',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('364','4','谈谈对ajax的理解','3','3',NULL,'ajax可以实现局部刷新，也叫做无刷新，无刷新指的是整个页面不刷新，只是局部刷新，ajax可以自己发送http请求，不用通过浏览器的地址栏，所以页面整体不会刷新，ajax获取到后台数据，更新页面显示数据的部分，就做到了页面局部刷新。',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('365','4','对于生成器迭代器的理解？','3','2',NULL,'说这个问题我们首先来谈一下for循环遍历对象的本质for循环来遍历列表等容器对象时，先对容器对象调用iter()函数。iter()是python的内置函数iter()函数会返回一个定义了next()方法的迭代器对象，它在容器中逐个访问容器中的元素。next()也是python的内置函数。没有后续元素时，next()会抛出StopIteration异常，此时for循环结束。接下来我们再来说迭代器（Iterator）迭代器用来帮助我们记录每次迭代访问到的位置。当对迭代器使用next()函数的时候，迭代器会返回它所记录位置的下一个位置的数据。实际上，使用next()函数的时候，调用的是迭代器的__next__方法。所以一个迭代器必须有__next__方法。但是这还不够，python本身要求迭代器本身也必须是可迭代的。因此迭代器还必须有一个__iter__方法，这给__iter__方法就是让for循环遍历时使用的，又因为__iter__方法要返回一个迭代器，所',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('366','4','python常用的标准库？','3','3',NULL,'os sys re math random unittest（测试） datatime',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('367','4','django 和 flask 的区别？','3','2',NULL,'flask比较轻量级 Django是重量级 简单的flask是一个可以修饰的毛坯房自己自主的搭配 提供核心的东西，django 是一个已经成型得房子修改性小，在某些方面Django太重了，除了web框架，自带ORM和模板引擎，自带的数据库管理app，第三方库最丰富，模块化是集成在命令里的，Django的配置主要还是靠settings.py来做Flask通过Blueprint来提供模块化，Flask的配置很灵活，有多种方法配置，不同环境的配置也非常方便。',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('368','4','状态码及使用？','3','2',NULL,'通过状态码告诉客户端服务器的执行状态，以判断下一步该执行什么操作。常见的状态机器码有：100-199：表示服务器成功接收部分请求，要求客户端继续提交其余请求才能完成整个处理过程。200-299：表示服务器成功接收请求并已完成处理过程，常用 200（OK 请求成功）。300-399：为完成请求，客户需要进一步细化请求。302（所有请求页面已经临时转移到新的 url）。304、307（使用缓存资源）。400-499：客户端请求有错误，常用 404（服务器无法找到被请求页面），403（服务器拒绝访问，权限不够）。500-599：服务器端出现错误，常用 500（请求未完成，服务器遇到不可预知的情况）。',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('369','4','str和byte的区别','3','1',NULL,'python3中最重要的新特性可能就是将文本(text)和二进制数据做了更清晰的区分。文本总是用unicode进行编码，以str类型表示；而二进制数据以bytes类型表示。strings可以被编码(encode)成字bytes,bytes也可以解码(decode)成strings：',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('37','1','nginx的反向代理','3','2',NULL,'本来浏览器A可以直接访问服务器C，nginx作为反向代理，实际上就是客户访问的ip地址是nginx的，而nginx再去访问服务器的ip，服务器发送的资源先通过nginx再到客户手里',NULL,'0','0','0','3','2023-05-26 10:22:16','2023-05-26 10:22:16'),('370','4','list、tuple、set和dict的区别？','3','2',NULL,'1.list、tuple是有序列表；dict、set是无序列表2.list元素可变、tuple元素不可变3.dict和set的key值不可变，唯一性4.set只有key没有value5.set的用途：去重、并集、交集等6.list、tuple：+、*、索引、切片、检查成员等7.dict查询效率高，但是消耗内存多；list、tuple查询效率低、但是消耗内存少',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('371','4','react的生命周期，如何发送Ajax？','3','4',NULL,'我们应当将AJAX请求放到componentDidMount函数中执行，主要原因有下：　　React下一代调和算法Fiber会通圌过开始或停止渲染的方式优化应用性能，其会影响到componenТWillMount的触发次数。对于componenТWillMount这个生命周期函数的调用次数会变得不确定，React可能会多次频繁调用componenТWillMount。如果我们将AJAX请求放到componenТWillMount函数中，那么显而易见其会被触发多次，自然也就不是好的选择。　　如果我们将AJAX请求放置在生命周期的其他函数中，我们并不能保证请求仅在组件挂载完毕后才会要求响应。如果我们的数据请求在组件挂载之前就完成，并且调用了setState函数将数据添加到组件状态中，对于未挂载的组件则会报错。而在componen',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('372','4','列表的去重？','3','1',NULL,'list转set',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('373','4','Python进程间通信，不用socket怎么通讯','3','3',NULL,'（1）管道（Pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用，允许一个进程和另一个与它有共同祖先的进程之间进行通信。（2）命名管道（namedpipe）：也是半双工的通信方式，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。（3）信号（Signal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。是Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制。（4）消息（Message）队列：消息队列是消息的链接表，包括Posix消息队列systemV消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('374','4','MySQL数据库存储引擎有哪些？InnoDB与MyISAM的区别？','3','4',NULL,'MyISAM、InnoDB、MERGE、MEMORY(HEAP)、BDB(BerkeleyDB)、EXAMPLE、FEDERATED、ARCHIVE、CSV、BLACKHOLEinnoDB一、InnoDB支持事务，MyISAM不支持，这一点是非常之重要。事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。二、MyISAM适合查询以及插入为主的应用，InnoDB适合频繁修改以及涉及到安全性较高的应用三、InnoDB支持外键，MyISAM不支持四、InnoDB不支持FULLTEXT类型的索引五、InnoDB中不保存表的行数，如select count(*) from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(*)语句包含where条件时MyISAM也需要扫描整个表六、对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISA',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('375','4','**args和**kwargs？','3','2',NULL,'*args 是不定长参数，他可以表示输入参数是不确定的，可以是任意多个。**kwargs 是关键字参数，赋值的时候是以键 = 值的方式，参数是可以任意多对在定义函数的时候不确定会有多少参数会传入时，就可以使用两个参数。',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('376','4','使用装饰器实现单例模式？','3','3',NULL,'class fun_1(object):  def __init__(self, cls):    self._cls = cls    self._instances = None;  def __call__(self, *args):    if not self._instances:      self._instances = self._cls(*args)    return self._instances@fun_1class fun_2(object):  def _',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('377','4','用一行代码python 写出1+2+3+4+&hellip;&hellip;10348？','3','2',NULL,'print(sum(range(1,10349)))',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('378','4','同步异步阻塞非阻塞的了解具体说说？','3','2',NULL,'异步：某个事情需要10s完成。而我只需要调用某个函数告诉xxx来帮我做（然后我再干其他的事情）同步：某个事情需要10s完成，我需要一直等它完成（等10s），再能继续后面的工作。阻塞：做某件事情，直到完成，除非超时非阻塞：尝试做，如果不能做，就不做（直接返回），如果能做，就做。',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('379','4','如何实现react组件的通信？','3','3',NULL,'1.父-子组件通信1.1通信的手段这是最常见的通信方式，父组件只需要将子组件需要的props传给子组件，子组件直接通过this.props来使用。1.2通信内容更多要提的是如何合理的设置子组件的props，要想将子组件设计成一个复用性强的通用组件，需要将能够复用的部分抽象出来，抽象出来的props有两种形成，一种是简单的变量，另一种是抽象出来处理某种逻辑的函数。2.子-父组件通信2.1通信的手段父-子组件通信的手段是通过子组件的props是子组件用父组件的东西，子-父组件通信，是父组件用子组件的东西，肿么用，在开发过程中暂时没有用到这种情景。我想到的方法就是将传递的内容直接写在子组件上，然后给子组件设置ref，父组件直接通过ref操作子组件的属性。2.2通信的内容子组件的属性2.3通信的动机父组件想要调用子组件的属性3.1通信的方式',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('38','1','为什么不用django自带的服务器，而是用uwsgi','3','3',NULL,'runserver只适合在开发时候使用，它是单进程的，性能很差，如果出错挂掉，整个进程都会挂掉',NULL,'0','0','0','1','2023-05-26 10:22:16','2023-05-26 10:22:16'),('380','4','python的内存管理机制？','3','2',NULL,'采用引用计数为主，标记清除、分代回收机制为辅',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('381','4','什么是闭包？','3','1',NULL,'在函数内部再定义一个函数，并且这个函数用到了外边函数的变量，那么将这个函数以及用到的一些变量称之为闭包',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('382','4','python2和3的区别。','3','3',NULL,'&gt;1.print不再是语句，而是函数，比如原来是print&#39;abc&#39;现在是print(&#39;abc&#39;)但是python2.6+可以使用from__future__importprint_function来实现相同功能&gt;2.在Python3中，没有旧式类，只有新式类，也就是说不用再像这样classFoobar(object):pass显式地子类化object但是最好还是加上.主要区别在于old-style是classtype类型而new-style是type类型&gt;3.原来1/2（两个整数相除）结果是0，现在是0.5了<b',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('383','4','进程间的数据共享和线程间的数据共享','3','2',NULL,'进程间数据共享:多进程中，每个进程都是独立的，各自持有一份数据，无法共享。本篇文章介绍三种用于进程数据共享的方法Queue:1.frommultiprocessingimportqueues2.importmultiprocessing34.deffunc(i,q):5.q.put(i)6.print(&quot;---&gt;&quot;,i,q.qsize())7.8.9.q=queues.Queue(9,ctx=multiprocessing)10.foriinrange(5):<br ',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('384','4','fastcgi通过端口监听和通过文件监听的区别?','3','4',NULL,'端口监听和文件监听。区别如下：端口监听方式的形式为&ldquo;fastcgi_pass 127.0.0.1:9000&rdquo;，此时Nginx连接fastcgi使用的是tcp协议。文件监听方式的形式为&ldquo;fastcgi_pass /tmp/php_cgi.sock &rdquo;，，此时Nginx连接fastcgi的方式为Unix domain Socket。',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('385','4','python多线程与多进程的区别','3','2',NULL,'进程:一个运行的程序(代码)就是一个进程，没有运行的代码叫程序，进程是系统资源分配的最小单位，进程拥有自己独立的内存空间，所以进程间数据不共享，开销大。线程:调度执行的最小单位，也叫执行路径，不能独立存在，依赖进程存在一个进程至少有一个线程，叫主线程，而多个线程共享内存(数据共享，共享全局变量)，从而极大地提高了程序的运行效率',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('386','4','python多线程','3','2',NULL,'这个问题被问的概率相当之大，其实多线程，多进程，在实际开发中用到的很少，除非是那些对项目性能要求特别高的，有的开发工作几年了，也确实没用过，你可以这么回答，给他扯扯什么是进程，线程(cpython中是伪多线程)的概念就行，实在不行你就说你之前写过下载文件时，用过多线程技术，或者业余时间用过多线程写爬虫，提升效率。进程:一个运行的程序(代码)就是一个进程，没有运行的代码叫程序，进程是系统资源分配的最小单位，进程拥有自己独立的内存空间，所以进程间数据不共享，开销大。',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('387','4','sockets（套接字）编程有三种，哪三种？','3','3',NULL,'套接字有三种类型:流式套接字(SOCK_STREAM),数据报套接字(SOCK_DGRAM)及原始套接字。',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('388','4','应用webpack自动代码分割需要如何调整js代码？','3','5',NULL,'代码分一切都还不错，直到有一天遇到不能以单文件形式下载整个应用的情况。有时候你必须在应用程序中使用多个打包的脚本。这就是需要对代码进行分割的地方。通过将应用程序拆解成多个部分，你才可以按照用户当前操作提供应用程序中相关的部分。提到最小的单包，Webpack通常最后来处理文件大小，但这往往不是恰当的时机。Rollup在这方面就好得多，但它对代码分割的支持则较弱。Webpack各分块文件的大小总和会超出单个Rollup打包出来的文件的大小，但这在你的应用中很可能不是什么问题。如果你根据需求来对Webpack产生和各个包进行懒加载，那么用户最终下载的内容可能只是完整Rollup生成的包文件的一部分。最终，更小更有针对性的打包会比单包给用户带来更多好处。当然如果你的应用中没什么机会用以懒加载，这些好处就不存在。',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('389','4','分别阐述三种引号用的场景与区别','3','2',NULL,'单引号，双引号，三引号都可以表示字符串，双引号可以和单引号嵌套使用，三引号一般表示多行字符串或者注释，三引号可以嵌套双引号和单引号',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('390','4','Python的内存管理机制','3','4',NULL,'1.引用计数：通过引用计数来保持对内存中的变量跟踪，Python内部记录中所有在使用对象各有多少个引用。Python中有个内部跟踪变量叫做引用计数器，每个变量有多少个引用，简称引用计数。当对象被创建时就创建了一个引用计数。当某个对象的引用计数为0时，对象就不在需要，就列入了垃圾回收队列。引用计数增加：1.对象被创建：x=4;2.另外的别人被创建：y=x;3.被作为参数传递给函数：foo(x);4.作为容器对象的一个元素：a=[1,x,&#39;33&#39;];引用计数减少时：1.一个本地引用离开了它的作用域。比如上面的foo(x)函数结束时，x指向的对象引用减1;2.对象的别名被显式的销毁：delx；或者dely;3.对象的一个别名被赋值给其他对象：x=7894.对象从一个窗口对象中移除：myList.remove(x)5.窗口对象本身被销毁delmyList，或者窗口对象本身离开了作用域。2.垃圾回收1.引用计数：每个对象中都有ob-refcnt来做引用计数。当一个对象...,ob-refcnt就会增加，当引用的对象删除，那么ob-refc',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('391','4','域名和IP之间有什么关系，如何查看某个域名对应的所有IP？','3','3',NULL,'输入域名----域名解析服务器（dns）解析成ip地址---访问IP地址---完成访问的内容---返回信息国际互联网(Internet)上有成千百万台主机（host），为了区分这些主机，人们给每台主机都分配了一个专门的&ldquo;地址&rdquo;作为标识，称为IP地址由于IP地址全是些的数字，为了便于用户记忆，Internet上引进了域名服务系统DNS（DomainNameSystem）。当您键入某个域名的时候，这个信息首先到达提供此域名解析的服务器上，再将此域名解析为相应网站的IP地址。完成这一任务的过程就称为域名解析。1.ping2.nslookup3.使用站长工具等',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('392','4','假设a=(1,2,3)改变a的值变为(3,2,3)','3','1',NULL,'b=list（a）b[0]=3a=b',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('393','4','如何在一个多级目录下,找出所有包含有&rsquo;abc&rsquo;字符的文件','3','1',NULL,'grep&lsquo;abc&rsquo;./*',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('394','4','如何抓取ping包','3','4',NULL,'tcpdump-ieth0-nn&#39;icmp&#39;ping命令使用的是icmp协议',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('395','4','gitpush等同于那两个git命令？','3','3',NULL,'<pre><code class=\"language-javascript\">\"git push命令用于将本地分支的更新，推送到远程主机。它的格式与git pull命令相仿。注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以git pull是&lt;远程分支&gt;:&lt;本地分支&gt;，而git push是&lt;本地分支&gt;:&lt;远程分支&gt;。如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支(通常两者同名)，如果该远程分支不存在，则会被新建。\"</code></pre>',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('396','4','print(dir(&lsquo;a&rsquo;))输出的是什么？','3','2',NULL,'会打印出字符型的所有的内置方法[&#39;__add__&#39;,&#39;__cla_&#39;,&#39;__contains__&#39;,&#39;__delattr__&#39;,&#39;__doc__&#39;,&#39;__eq__&#39;,&#39;__format__&#39;,&#39;__ge__&#39;,&#39;__getattribute__&#39;,&#39;__getitem__&#39;,&#39;__getnewargs__&#39;,&#39;__getslice__&#39;,&#39;__gt__&#39;,&#39;__hash__&#39;,&#39;__init__&#39;,&#39;__le__&#39;,&#39;__len__&#39;,&#39;__lt__&#39;,&#39;__mod__&',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('397','4','nginx的负载均衡实现方式?','3','4',NULL,'轮询用户IP哈希指定权重fair（第三方）url_hash（第三方）',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('398','4','__new__和__init__的区别？','3','2',NULL,'__new__是一个静态方法,而__init__是一个实例方法.__new__方法会返回一个创建的实例,而__init__什么都不返回.只有在__new__返回一个cls的实例时后面的__init__才能被调用.当创建一个新实例时调用__new__,初始化一个实例时用__init__',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('399','4','一个包里有三个模块，mod1.py,mod2.py,mod3.py，但使用fromdemopackimport*导入模块时，如何保证只有mod1、mod3被导入了','3','2',NULL,'增加__init__.py文件，并在文件中增加：__all__=[&#39;mod1&#39;,&#39;mod3&#39;]',NULL,'1','1','1','4','2023-05-26 10:22:16','2023-05-26 10:22:16'),('4','1','以下关于toString（）方法、equals（）方法说法正确的是？（ ）','1','2',NULL,'',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('400','1','如实现extend的函数？','3','4',NULL,'<pre><code class=\"language-javascript\">\"var class2type = {}function type(obj) {  return obj == null ? String(obj) :    class2type[toString.call(obj)] || \"\"object\"\"}function isFunction(value) { return type(value) == \"\"function\"\" }function isWindow(obj)     { return obj != null &amp;&amp; obj == obj.window }function isDocument(obj)   { return obj != null &amp;&amp; obj.nodeType == obj.DOCUMENT_NODE }function isObject(obj)     { return type(obj) == \"\"object\"\" }function isPlain',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('401','1','Python里面match()和search()的区别？','3','1',NULL,'re模块中match(pattern,string[,flags]),检查string的开头是否与pattern匹配。re模块中research(pattern,string[,flags]),在string搜索pattern的第一个匹配值。',NULL,'1','1','1','5','2023-02-25 16:21:16','2023-02-25 16:21:16'),('402','1','如何保证线程安全？','3','1',NULL,'通常加锁也有2种不同的粒度的锁：1.fine-grained(细粒度)，程序员需要自行加/解锁来保证线程安全2.coars',NULL,'1','1','1','5','2022-08-21 17:21:16','2022-08-21 17:21:16'),('403','1','Python线程和进程的区别','3','2',NULL,'1)调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位。2)并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行。3）拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源.4）系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。',NULL,'1','1','1','5','2023-05-26 10:22:16','2023-05-26 10:22:16'),('404','1','Python内存管理机制','3','5',NULL,'引用计数机制垃圾回收机制内存池机制',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('405','1','说说你对TCPIP协议的理解','3','1',NULL,'TCP/IP（TransmissionControlProtocol/InternetProtocol）协议是传输层协议，主要解决数据如何在网络中传输。HTTP是应用层协议，主要解决如何包装数据。IP协议对应于网络层。',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('406','1','表单中get与post提交方法的区别?','3','4',NULL,'GET在浏览器回退时是无害的，而POST会再次提交请求。GET产生的URL地址可以被Bookmark，而POST不可以。GET请求会被浏览器主动cache，而POST不会，除非手动设置。GET请求只能进行url编码，而POST支持多种编码方式。GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。GET请求在URL中传送的参数是有长度限制的，而POST没有。对参数的数据类型，GET只接受ASCII字符，而POST没有限制。GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。GET参数通过URL传递，POST放在Request body中。GET产生一个TCP数据包，POST产生两个TCP数据包。',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('407','1','简述HTTP缓存机制','3','3',NULL,'在客户端第一次请求数据时，此时缓存数据库中没有对应的缓存数据，需要请求服务器，服务器返回后，将数据存储至缓存数据库中。对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('408','1','如何避免python中模块间的循环引用','3','3',NULL,'解决循环import的方法主要有几种。1.延迟导入(lazyimport)即把import语句写在方法或函数里面，将它的作用域限制在局部。这种方法的缺点就是会有性能问题。2.将fromxxximportyyy改成importxxx;xxx.yyy来访问的形式3.组织代码出现循环import的问题往往意味着代码的布局有问题。可以合并或者分离竞争资源。合并的话就是都写到一个文件里面去。分离的话就是把需要import的资源提取到一个第三方文件去。总之就是将循环变成单向。',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('409','1','如何避免python中模块间的循环引用','3','3',NULL,'解决循环import的方法主要有几种。1.延迟导入(lazyimport)即把import语句写在方法或函数里面，将它的作用域限制在局部。这种方法的缺点就是会有性能问题。2.将fromxxximportyyy改成importxxx;xxx.yyy来访问的形式3.组织代码出现循环import的问题往往意味着代码的布局有问题。可以合并或者分离竞争资源。合并的话就是都写到一个文件里面去。分离的话就是把需要import的资源提取到一个第三方文件去。总之就是将循环变成单向。',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('41','1','数据库表A中有姓名fname的数据类型为varchar(20),要求使用SQL语句修改该字段的数据类型为nvarchar2(50)','3','2',NULL,'ALERTTABLEAMODIFYCOLUMNfnamenvarchar(50);',NULL,'0','0','0','1','2023-05-25 13:27:14','2023-05-25 13:27:14'),('410','1','用Pythonre模块匹配HTMLtag的时候，&lt;.*&gt;和&lt;.*?&gt;有什么区别','3','2',NULL,'&lt;.*&gt;这种匹配称作贪心匹配&lt;.*?&gt;称作非贪心匹配第一种写法是，尽可能多的匹配，就是匹配到的字符串尽量长，第二中写法是尽可能少的匹配，就是匹配到的字符串尽量短。比如&lt;tag&gt;tag&gt;tag&gt;end，第一个会匹配&lt;tag&gt;tag&gt;tag&gt;,第二个会匹配&lt;tag&gt;,如果要匹配到二个&gt;，就只能自己写',NULL,'1','1','1','5','2023-03-25 11:22:14','2023-03-25 11:22:14'),('411','1','Jquery底层你都了解什么？','3','5',NULL,'jQuery闭包结构//用一个函数域包起来，就是所谓的沙箱//在这里边var定义的变量，属于这个函数域内的局部变量，避免污染全局//把当前沙箱需要的外部变量通过函数参数引入进来//只要保证参数对内提供的接口的一致性，你还可以随意替换传进来的这个参数jQuery具体的实现，都被包含在了一个立即执行函数构造的闭包里面，为了不污染全局作用域，只在后面暴露$和jQuery这2个变量给外界，尽量的避开变量冲突。常用的还有另一种写法：比较推崇的的第一种写法，也就是jQuery的写法。二者有何不同呢，当我们的代码运行在更早期的环境当中（pre-ES5，eg.InternetExplorer8），undefined仅是一个变量且它的值是可以被覆盖的。意味着你可以做这',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('412','1','Python的传参是传值还是传址','3','3',NULL,'Python的参数传递有：位置参数、默认参数、可变参数、关键字参数函数的传值到底是值传递还是引用传递，要分情况：不可变参数用值传递：像整数和字符串这样的不可变对象，是通过拷贝进行传递的，因为你无论如何都不可能在原处改变不可变对象可变参数是引用传递的：比如像列表，字典这样的对象是通过引用传递、和C语言里面的用指针传递数组很相似，可变对象能在函数内部改变',NULL,'1','1','1','5','2022-08-21 17:21:16','2022-08-21 17:21:16'),('414','1','如何在一个function里面设置一个全局的变量','3','1',NULL,'如果要给全局变量在一个函数里赋值，必须使用global语句。globalVarName的表达式会告诉Python，VarName是一个全局变量，这样Python就不会在局部命名空间里寻找这个变量',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('415','1','描述下SOAP的交互流程','3','3',NULL,'SOAP(简单对象访问协议)：SOAP是使用XML通过Internet发送信息和访问动态Web服务的友好界面。其主要作用在于确保信息通过互联网在业务应用之间传输的可靠性。作为一种用在分布式环境中交换结构化数据的协议，它包括三个部分：信封、报头(可选)和协议消息体。信封标记SOAP消息的开始与结束。它还可以规定在网络上数据的编码规则。SOAP报头可以包含发送给一个地址或多个地址的邮件、一个支付代码或有关RPC类型互动的信息。一个信封中可以有多个报头或完全没有报头。SOAP消息体传送自描述结构或RPC类型接口格式的数据。',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('416','1','Git命令以及根据所写的命令说出意思','3','2',NULL,'1、git config --global user.name &#39;username&#39; ，登录git设置账户2、mkdir php，创建文件夹PHP3、touch .gitignore，创建忽略文件4、git commit -m &#39;备注信息&#39;，添加到版本库中',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('417','1','这两个参数什么意思*args**kwargs，我们为什么要使用他们？','3','2',NULL,'缺省参数指在调用函数的时候没有传入参数的情况下，调用默认的参数，在调用函数的同时赋值时，所传入的参数会替代默认参数。*args是不定长参数，他可以表示输入参数是不确定的，可以是任意多个。**kwargs是关键字参数，赋值的时候是以键=值的方式，参数是可以任意多对在定义函数的时候不确定会有多少参数会传入时，就可以使用两个参数。',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('418','1','Python关键字yield的用法？','3','3',NULL,'yield就是保存当前程序执行状态。你用for循环的时候，每次取一个元素的时候就会计算一次。用yield的函数叫generator，和iterator一样，它的好处是不用一次计算所有元素，而是用一次算一次，可以节省很多空间。generator每次计算需要上一次计算结果，所以用yield，否则一return，上次计算结果就没了。',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('419','1','函数参数的传递？def add（a，s_list=[]）:     s_list.append(a)         return s_list &','3','2',NULL,'[1],[1,2],[1,2,3]',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('420','1','Python线程和进程的区别？','3','2',NULL,'1)调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位。2)并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行。3）拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源.4）系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。',NULL,'1','1','1','5','2022-08-21 17:21:16','2022-08-21 17:21:16'),('421','1','Python线程和进程的区别？','3','2',NULL,'1)调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位。2)并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行。3）拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源.4）系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。',NULL,'1','1','1','5','2022-08-21 17:21:16','2022-08-21 17:21:16'),('422','1','mysql优化','3','4',NULL,'MySQL优化三大方向① 优化MySQL所在服务器内核(此优化一般由运维人员完成)。② 对MySQL配置参数进行优化（my.cnf）此优化需要进行压力测试来进行参数调整③ 对SQL语句以及表优化。对MySQL语句性能优化的16条具体措施① 为查询缓存优化查询② EXPLAIN 我们的SELECT查询(可以查看执行的行数)③ 当只要一行数据时使用LIMIT 1④ 为搜索字段建立索引⑤ 在Join表的时候使用相当类型的列，并将其索引⑥ 千万不要 ORDER BY RAND ()⑦ 避免SELECT *⑧ 永远为每张表设置一个ID⑨ 可以使用ENUM 而不要VARCHAR⑩ 尽可能的使用NOT NULL⑪ 固定长度的表会更快⑫ 垂直分割⑬ 拆分打的DELETE或INSERT语句⑭ 越小的列会越快',NULL,'1','1','1','5','2022-08-21 17:21:16','2022-08-21 17:21:16'),('423','1','说说多线程？','3','2',NULL,'使用threading这个高级模块，启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量把内容给改乱了。锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，坏处当然也很多首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。其次，由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。多线程编程，模型复杂，容易发生冲突，必须用锁加以隔离，同时，又要小心死锁的发生。Python解释器由于设计时有GIL全局锁，导致了多线程无法利用多核。多线程的并发在Python中就是一个美丽的梦。Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global',NULL,'1','1','1','5','2023-05-26 10:22:16','2023-05-26 10:22:16'),('424','1','webpack是如何配置？','3','5',NULL,'1.安装NodeJs首先，Webpack是基于NodeJs的工具，你必须首先安装NodeJs.NodeJs仅仅只需要在你的系统中安装一次就可以了。2.全局安装Webpack我们希望能够在系统的任何文件夹中使用Webpack，使用的方式是通过Webpack命令来完成的，这需要我们全局安装Webpack。这也只需要安装一次，以后每个项目就不需要重新全局安装了。npminstallwebpack-g成功安装之后，你应该能够在任何目录中执行webpack命令，如果你还没有项目的配置文件的话，应该会看到当前的Webpack版本和一个命令的帮助列表。3.在项目中安装Webpack<br ',NULL,'1','1','1','5','2022-08-21 17:21:16','2022-08-21 17:21:16'),('425','1','Linux的命令','3','2',NULL,'1、uname -m 显示机器的处理器架构2、uname -r 显示正在使用的内核版本3、shutdown -h now 关闭系统4、rm -rf dir1 删除一个叫做 &#39;dir1&#39; 的目录并同时删除其内容5、find / -user user1 搜索属于用户 &#39;user1&#39; 的文件和目录6、groupadd group_name 创建一个新用户组7、groupdel group_name 删除一个用户组',NULL,'1','1','1','5','2022-08-21 17:21:16','2022-08-21 17:21:16'),('426','1','如何实现购物车的计算功能？','3','5',NULL,'（1）我们平时购物的时候，有时候点击商品页面的加入购物车，然后商品就直接加入到购物车列表中，不管用户是否登录。然后我们换了一台设备，发现该网站我们之前在另一台设备上加入购物车的商品不存在。由此我们可以推断出：购物车列表的内容不是存放在数据库，而是在cookie中。，所以购物车功能实现是在客户端实现的。（2）购物车我们需要实现的功能有哪些呢？展示购物车列表、向购物车列表中添加商品（add）、修改购物车列表中商品的数量、删除列表中的商品。逻辑实现：一、展示购物车列表：因为购物车的商品列表是保存在cookie中的，所以我们获取购物车列表就是从cookie中获取商品列表。首先cookie中保存形式也是key-value的形式，key指的是保存的名称，比如TT_CART,是一个标志而已。value是保存的商品的具体信息，是以字符串的形式保存的，我们通常将列表的形式转换成json格式的数据，因为json',NULL,'1','1','1','5','2022-08-21 17:21:16','2022-08-21 17:21:16'),('427','1','数组去重es5、es6？','3','3',NULL,'<pre><code class=\"language-javascript\">\"let array = Array.from(new Set([1, 1, 1, 2, 3, 2, 4]));console.log(array);// =&gt; [1, 2, 3, 4]附：ES5实现数组去重var array = [1, \'1\', 1, 2, 3, 2, 4];var tmpObj = {};var result = [];array.forEach(function(a) {  var key = (typeof a) + a;  if (!tmpObj[key]) {    tmpObj[key] = true;    result.push(a);  }});console.log(result);// =&gt; [1, \"\"1\"\", 2, 3, 4]\"</code></pre>',NULL,'1','1','1','5','2022-08-21 17:21:16','2022-08-21 17:21:16'),('428','1','跨域的实现？','3','3',NULL,'①通过jsonp跨域②CORS核心思想：在服务器端通过检查请求头部的origin，从而决定请求应该成功还是失败。具体的方法是在服务端设置ResponseHeader响应头中的Access-Control-Allow-Origin为对应的域名，实现了CORS（跨域资源共享），这里出于在安全性方面的考虑就是尽量不要用*，但对于一些不重要的数据则随意。',NULL,'1','1','1','5','2022-08-21 17:21:16','2022-08-21 17:21:16'),('429','1','vuex放在那个目录中？','3','5',NULL,'文件之间的关系：store文件夹-存放vuex的系列文件store.js-引入vuex，设置state状态数据，引入getter、mutation和actiongetter.js-获取store内的状态mutation.js-更改store中状态用的函数的存储之地action.js-提交mutation以达到委婉地修改state状态，可异步操作',NULL,'1','1','1','5','2022-08-21 17:21:16','2022-08-21 17:21:16'),('43','1','当输入http:mioji3.com时，返回页面的过程中发生了什么','3','2',NULL,'浏览器向DNS服务器发送mioji3.com域名解析请求DNS服务器返回解析后的ip给客户端浏览器，浏览器想该ip发送页面请求DNS服务器接收到请求后，查询该页面，并将页面发送给客户端浏览器客户端浏览器接收到页面后，解析页面中的引用，并再次向服务器发送引用资源请求服务器接收到资源请求后，查找并返回资源给客户端客户端浏览器接收到资源后，渲染，输出页面展现给用户',NULL,'0','0','0','1','2023-05-26 10:22:16','2023-05-26 10:22:16'),('430','1','c3新特性？','3','3',NULL,'<pre><code class=\"language-javascript\">\"选择器框模型背景和边框 border-radius、box-shadow、border-image、 background-size：规定背景图片的尺寸 background-origin：规定背景图片的定位区域 background-clip：规定背景的绘制区域文本效果（常用） text-shadow：设置文字阴影 word-wrap：强制换行 word-break css3提出@font-face规则，规则中定义了font-family、font-weight、font-style、font-stretch、src、unicode-range2/3D转换 transform：向元素应用2/3D转换 transition：过渡动画@keyframes规则： animation、animation-name、animation-duration等用户界面（',NULL,'1','1','1','5','2023-05-26 10:22:16','2023-05-26 10:22:16'),('431','1','vue和angular的生命周期？','3','5',NULL,'<pre><code class=\"language-javascript\">\"　　vue【beforeCreate】　　在实例开始初始化时同步调用。此时数据观测、事件等都尚未初始化【created】在实例创建之后调用。此时已完成数据观测、事件方法，但尚未开始DOM编译，即未挂载到document中【beforeMount】　　在mounted之前运行【mounted】　　在编译结束时调用。此时所有指令已生效，数据变化已能触发DOM更新，但不保证$el已插入文档　　【beforeUpdate】　　在实例挂载之后，再次更新实例(例如更新 data)时会调用该方法，此时尚未更新DOM结构【updated】　　在实例挂载之后，再次更新实例并更新完DOM结构后调用【beforeDestroy】　　在开始销毁实例时调用，此刻实例仍然有效【destroyed】　　在实例被销毁之后调用。此时所有绑定和实例指令都已经解绑，子实例也被销毁【activated】　　需要配合动态组件k',NULL,'1','1','1','5','2023-05-26 10:22:16','2023-05-26 10:22:16'),('432','1','如何获取url上面的参数？','3','3',NULL,'js获取URL中的参数js获取URL中的一些参数的意思location对象含有当前URL的信息.属性href整个URL字符串.protocol含有URL第一部分的字符串,如http:host包含有URL中主机名:端口号部分的字符串.如//www.cenpok.net/server/hostname包含URL中主机名的字符串.如http://www.cenpok.net;port包含URL中可能存在的端口号字符串.pathnameURL中&quot;/&quot;以后的部分.如~list/index.htmhash&quot;#&quot;号(CGI参数)之后的字符串.search&quot;?&quot;号(CGI参数)之后的字符串.',NULL,'1','1','1','5','2023-05-26 10:22:16','2023-05-26 10:22:16'),('433','1','阐述你了解的web的攻击技术？','3','5',NULL,'一、主动攻击主动攻击是指攻击者通过直接访问Web应用，把攻击代码传入的攻击模式。由于该模式是直接针对服务器上的资源进行攻击的，因此攻击者需要能够访问到这些资源。主动攻击模式里具有代表性的攻击是SQL注入攻击和OS命令注入攻击。a、SQL注入定义：通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串中，最终达到欺骗服务器执行恶意SQL命令的目的。上述命令，where语句永远成立，且在执行后会删除student表，这样执行后果很严重。如何防止SQL注入：不信任用户的输入；不使用动态拼接sql，可使用参数化的sql或直接使用存储过程进行数据查询存取；不使用管理员权限的数据库连接；对机密信息进行加密或hash掉密码和敏感信息；应用异常尽可能少在web提示，最好使用自定义信息对应用的异常信息进行包装；采用工具或',NULL,'1','1','1','5','2023-05-26 10:22:16','2023-05-26 10:22:16'),('434','1','css3怎么实现平移，旋转，缩放，倾斜以及过渡效果','3','2',NULL,'transform:translate(100px,100px);transform:rotate(7deg);transform:scale(1.1);transform:skew(10deg,10deg);transition:all2s;',NULL,'1','1','1','5','2023-05-26 10:22:16','2023-05-26 10:22:16'),('435','1','vue前后端分离项目怎么进行seo优化？','3','2',NULL,'spa开发模式的最大问题就是搜索引擎无法爬取页面内容，因为页面是通过http请求服务端接口数据动态渲染的，但是搜索引擎不会等待这个过程，这就导致前后端分离项目的seo优化成为一个问题。对于vue项目来说，一般有两种解决方案：1.开启服务端渲染：首先安装ssr支持：npmi-Dvue-server-renderer；重要的是vue-server-renderer与vue版本必须一致匹配优点：可以做到真实数据实时渲染，完全可供SEO小蜘蛛尽情的爬来爬去；完全前后端同构，路由配置共享，不再影响服务器404请求。缺点：依旧只支持h5history的路由模式，配置比较麻烦、处理流程比较复杂(比对预渲染插件，复杂太多)；约束较多，不能随心所欲的乱放大招；对服务器会造成较大的压力，既然让浏览器更快的渲染了，那就得以占用服务器的性能来买单了2.使用prerender-spa-plugin插件',NULL,'1','1','1','5','2023-05-26 10:22:16','2023-05-26 10:22:16'),('436','1','ajax的实现原理？','3','4',NULL,'　Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。要清楚这个过程和原理，我们必须对XMLHttpRequest有所了解。XMLHttpRequest是ajax的核心机制，它是在IE5中首先引入的，是一种支持异步请求的技术。简单的说，也就是javascript可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。　所以我们先从XMLHttpRequest讲起，来看看它的工作原理。　首先，我们先来看看XMLHttpRequest这个对象的属性。　　它的属性有：　　onreadystatechange每次状态改变所触发事件的事件处理程序。<br',NULL,'1','1','1','5','2023-05-26 10:22:16','2023-05-26 10:22:16'),('437','1','你有哪些性能优化的方法？','3','2',NULL,'（1）减少http请求次数：CSSSprites,JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存，图片服务器。（2）前端模板JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数（3）用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。（4）当需要设置的样式很多时设置className而不是直接操作style。（5）少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。（6）避免使用CSSExpression（css表达式)又称Dynamicproperties(动态属性)。（7）图片预加载，将样式表放在顶部，将脚本放在底部加上时间戳。',NULL,'1','1','1','5','2023-05-26 10:22:16','2023-05-26 10:22:16'),('438','1','webpack怎么配置','3','5',NULL,'1.安装NodeJs首先，Webpack是基于NodeJs的工具，你必须首先安装NodeJs.NodeJs仅仅只需要在你的系统中安装一次就可以了。2.全局安装Webpack我们希望能够在系统的任何文件夹中使用Webpack，使用的方式是通过Webpack命令来完成的，这需要我们全局安装Webpack。这也只需要安装一次，以后每个项目就不需要重新全局安装了。npminstallwebpack-g成功安装之后，你应该能够在任何目录中执行webpack命令，如果你还没有项目的配置文件的话，应该会看到当前的Webpack版本和一个命令的帮助列表。3.在项目中安装Webpack<br ',NULL,'1','1','1','5','2023-05-26 10:22:16','2023-05-26 10:22:16'),('439','1','ajax请求中json和jsonp得区别简要回答','3','2',NULL,'a)json是一种轻量级的数据交换格式。b)jsonp是一种跨域数据交互协议。c)json的优点：（1）基于纯文本传递极其简单，（2）轻量级数据格式适合互联网传递，（3）容易编写和解析。d)相同点：都是请求一个urle)不同点：ajax的核心是通过xmlHttpRequest获取内容',NULL,'1','1','1','5','2023-05-26 10:22:16','2023-05-26 10:22:16'),('44','1','请说明HTTP状态吗的用途，请说明常见的状态码机器意义。','3','2',NULL,'通过状态码告诉客户端服务器的执行状态，以判断下一步该执行什么操作常见的状态机器码有:100-199：表示服务器成功接收部分请求，要求客户端继续提交其余请求才能完成整个处理过程。200-299：表示服务器成功接收请求并已完成处理过程，常用200（OK请求成功）300-399：为完成请求，客户需要进一步细化请求。302（所有请求页面已经临时转移到新的url），304、307（使用缓存资源）。400-499：客户端请求有错误，常用404（服务器无法找到被请求页面），403（服务器拒绝访问，权限不够）500-599：服务器端出现错误，常用500（请求未完成，服务器遇到不可预知的情况）',NULL,'0','0','0','1','2023-05-25 13:27:14','2023-05-25 13:27:14'),('440','1','如何实现购物车的计算功能','3','5',NULL,'（1）我们平时购物的时候，有时候点击商品页面的加入购物车，然后商品就直接加入到购物车列表中，不管用户是否登录。然后我们换了一台设备，发现该网站我们之前在另一台设备上加入购物车的商品不存在。由此我们可以推断出：购物车列表的内容不是存放在数据库，而是在cookie中。，所以购物车功能实现是在客户端实现的。（2）购物车我们需要实现的功能有哪些呢？展示购物车列表、向购物车列表中添加商品（add）、修改购物车列表中商品的数量、删除列表中的商品。逻辑实现：一、展示购物车列表：因为购物车的商品列表是保存在cookie中的，所以我们获取购物车列表就是从cookie中获取商品列表。首先cookie中保存形式也是key-value的形式，key指的是保存的名称，比如TT_CART,是一个标志而已。value是保存的商品的具体信息，是以字符串的形式保存的，我们通常将列表的形式转换成json格式的数据，因为json',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('441','1','解决跨域的问题解决方案有哪些?','3','2',NULL,'具体是通过动态创建script标签，然后通过标签的src属性获取js文件中的js脚本，该脚本的内容是一个函数调用，参数就是服务器返回的数据，为了处理这些返回的数据，需要事先在页面定义好回调函数.',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('442','1','简述一下jsonp跨域的原理','3','2',NULL,'具体是通过动态创建script标签，然后通过标签的src属性获取js文件中的js脚本，该脚本的内容是一个函数调用，参数就是服务器返回的数据，为了处理这些返回的数据，需要事先在页面定义好回调函数.',NULL,'1','1','1','5','2022-08-21 17:21:16','2022-08-21 17:21:16'),('443','1','数组去重es5es6','3','4',NULL,'<pre><code class=\"language-javascript\">\" let array = [1, 1, 1, 1, 2, 3, 4, 4, 5, 3]; let set = new Set(array); console.log(set); // =&gt; Set {1, 2, 3, 4, 5}\"</code></pre>',NULL,'1','1','1','5','2023-05-26 10:22:16','2023-05-26 10:22:16'),('444','1','vuex的是放在哪个目录结构中的','3','3',NULL,'放在src下面的store文件中',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('445','1','跨域的实现过程','3','4',NULL,'Cross-OriginResourceSharing（CORS）跨域资源共享是一份浏览器技术的规范，提供了Web服务从不同域传来沙盒脚本的方法，以避开浏览器的同源策略，确保安全的跨域数据传输。现代浏览器使用CORS在API容器如XMLHttpRequest来减少HTTP请求的风险来源。与JSONP不同，CORS除了GET要求方法以外也支持其他的HTTP要求。服务器一般需要增加如下响应头的一种或几种：Access-Control-Allow-Origin:*Access-Control-Allow-Methods:POST,GET,OPTIONSAccess-Control-Allow-Headers:X-PINGOTHER,Content-TypeAccess-Control-Max-A',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('446','1','.简单讲了一下项目遇到的难题&nb','3','3',NULL,'遇到过一个页面传参不会，后来查资料发现可以通过url和H5的数据存储可以解决',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('447','1','vue的双向数据绑定原理','3','4',NULL,'VueJS则使用ES5提供的Object.defineProperty()方法，监控对数据的操作，从而可以自动触发数据同步。并且，由于是在不同的数据上触发同步，可以精确的将变更发送给绑定的视图，而不是对所有的数据都执行一次检测。',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('448','1','url栏中网址敲回车后会发生什么','3','3',NULL,'浏览器向DNS服务器（先查找缓存）查找输入URL对应的IP地址DNS服务器返回对应的IP地址浏览器根据IP地址与目标web服务器在80端口上建立TCP连接浏览器获取请求页面的html代码浏览器在显示窗口内渲染HTML窗口关闭时，浏览器中止与服务器的连接',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('449','1','larave与tp的区别','3','3',NULL,'1.渲染模版方式的不同:在Laravel框架里,使用return view()来渲染模版;而ThinkPHP里则使用了$this-&gt;display()的方式渲染模版;2.在Laravel框架里,由于其考虑到了跨站请求伪造, 所以如果使用form表单以post方式进行传值时,如果不再form表单中加入{{csrf_field()}}则会报出TokenMethodnotfound的语法错误;而TP框架则需要自己手动完成防止跨站攻击的代码;3.Laravel是一个重路由的框架(5.4),所有的功能都是由路由发起的,哪怕没有控制器方法,只要写了路由就能够访问,thinkPHP(3.2),必须要有控制器方法才能正常访问;4.laravel具有强大的社区化扩展，（composer扩展自动加载）;5.laravel具有强大的Blade模版引擎;6.中间件，Laravel特点，可以实现访问前后的处理，例如请求和返回，权限认证等;7.条件判',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('450','1','闭包的运用场景和优缺点','3','3',NULL,'继承，内存泄漏',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('451','1','post和get请求的区别','3','3',NULL,'GET请求，请求的数据会附加在URL之后，以?分割URL和传输数据，多个参数用&amp;连接。URL的编码格式采用的是ASCII编码，而不是uniclde，即是说所有的非ASCII字符都要编码之后再传输。POST请求：POST请求会把请求的数据放置在HTTP请求包的包体中。上面的item=bandsaw就是实际的传输数据。',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('452','1','还有sessionStorage和localStorage','3','4',NULL,'localStorage生命周期是永久，这意味着除非用户显示在浏览器提供的UI上清除localStorage信息，否则这些信息将永远存在。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。sessionStorage仅在当前会话下有效，关闭页面或浏览器后被清除。存放数据大小为一般为5MB,而且它仅在客户端（即浏览器）中保存，不参与和服务器的通信。源生接口可以接受，亦可再次封装来对Object和Array有更好的支持。',NULL,'1','1','1','5','2022-08-21 17:21:16','2022-08-21 17:21:16'),('453','1','以及cookie的区别','3','3',NULL,'生命期为只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。存放数据大小为4K左右。有个数限制（各浏览器不同），一般不能超过20个。与服务器端通信：每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题。',NULL,'1','1','1','5','2023-05-26 10:22:16','2023-05-26 10:22:16'),('454','1','谈谈js脚本攻击','3','3',NULL,'每当接受用户输入的内容并重新显示这些内容时，网站就很容易遭受JavaScript注入攻击。让我们研究一个容易遭受JavaScript注入攻击的具体应用程序。假设已经创建了一个客户反馈网站。客户可以访问网站并输入对产品的反馈信息。当客户提交反馈时，反馈信息重新显示在反馈页面上。客户反馈网站是一个简单的网站。不幸的是，此网站容易遭受JavaScript注入攻击',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('455','1','懒加载的原理','3','4',NULL,'先将img标签中的src链接设为同一张图片（空白图片），将其真正的图片地址存储再img标签的自定义属性中（比如data-src）。当js监听到该图片元素进入可视窗口时，即将自定义属性中的地址存储到src属性中，达到懒加载的效果。这样做能防止页面一次性向服务器响应大量请求导致服务器响应慢，页面卡顿或崩溃等问题',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('456','1','怎么实现登陆注册','3','4',NULL,'点击登录按钮，我们跳转到登录页面，通过获取到用户输入的input值，通过下标的方法取得输入的username和pwd的值，通过连接数据库，判断回调函数返回的状态值，如果成功，给予提示用户注册成功，紧接着进行页面的跳转，如果出现异常，给出提示，并相应的跳转到错误页面，在此处我们可以使用try{}catch(){}方法进行拦截，打印出具体的错误信息。紧接着，我们再来讲一下注册的操作，顾名思义，注册就是将原本不存在于数据库的用户资料通过数据库的insert语句插入数据库中，道理和登录有些类似，首先，我们需要输入需要注册的信息，然后获取到这些信息，然后再发送一个异步请求验证数据库是否有这些资料，如果没有的话就直接创建这些资料',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('457','1','轮播图的原理','3','2',NULL,'实现轮播图最主要的就是定时器（setInterval函数和clearInterval函数），他们分别是定时和清除定时器',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('458','1','手写数组冒泡排序','3','3',NULL,'<pre><code class=\"language-javascript\">\"var arr = [3,1,4,2,5,21,6,15,63];function sortA(arr){    for(var i=0;i&lt;arr.length-1;i++){        for(var j=i+1;j&lt;arr.length;j++){                      //获取第一个值和后一个值比较            var cur = arr[i];            if(cur&gt;arr[j]){                      // 因为需要交换值，所以会把后一个值替换，我们要先保存下来                var index = arr[j];                        // 交换值                arr[j] = cur;                arr[i] = index;            }        }',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('459','1','还有就是看着简历上的项目问一些功能怎么实现的','3','3',NULL,'根据面试官的问题，灵活应对',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('460','1','公司的技术栈','3','2',NULL,'h5c3ajaxbootstrapangular',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('461','1','angular','3','4',NULL,'AngularJS有着诸多特性，最为核心的是：MVVM、模块化、自动化双向数据绑定、语义化标签、依赖注入等等',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('462','1','vue','3','4',NULL,'Vue的核心定位并不是一个框架[3]，设计上也没有完全遵循MVVM模式，可以看到在图中只有State和View两部分，Vue的核心功能强调的是状态到界面的映射，对于代码的结构组织并不重视，所以单纯只使用其核心功能时，它并不是一个框架，而更像一个视图模板引擎，这也是为什么Vue开发者把其命名成读音类似于view的原因',NULL,'1','1','1','5','2022-08-21 17:21:16','2022-08-21 17:21:16'),('463','1','浏览器兼容性的理解','3','2',NULL,'览器的类型及版本的不同会造成CSS效果不尽相同，因此需要实现浏览器兼容，也可以针对不同的浏览器编写不同的CSS。目前，各主流浏览器的新版本，对于W3C的标准支持很好，因此，首先保证代码符合W3C的标准，这是解决浏览器兼容问题的前提。',NULL,'1','1','1','5','2023-05-26 10:22:16','2023-05-26 10:22:16'),('464','1','vue和angular区别','3','4',NULL,'在API与设计两方面上Vue.js都比Angular简单得多，因此你可以快速地掌握它的全部特性并投入开发。Vue.js是一个更加灵活开放的解决方案。它允许你以希望的方式组织应用程序，而不是任何时候都必须遵循Angular制定的规则。它仅仅是一个视图层，所以你可以将它嵌入一个现有页面而不一定要做成一个庞大的单页应用。在配合其他库方面它给了你更大的的空间，但相应，你也需要做更多的架构决策。例如，Vue.js核心默认不包含路由和Ajax功能，并且通常假定你在应用中使用了一个模块构建系统。这可能是最重要的区别。Angular使用双向绑定，Vue也支持双向绑定，不过默认为单向绑定，数据从父组件单向传给子组件。在大型应用中使用单向绑定让数据流易于理解。在Vue.js中指令和组件分得更清晰。指令只封装DOM操作，而组件代表一个自给自足',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('465','1','项目中主要用的技术','3','3',NULL,'jq+vue',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('466','1','xss攻击','3','5',NULL,'XSS攻击是Web攻击中最常见的攻击方法之一，它是通过对网页注入可执行代码且成功地被浏览器执行，达到攻击的目的，形成了一次有效XSS攻击，一旦攻击成功，它可以获取用户的联系人列表，然后向联系人发送虚假诈骗信息，可以删除用户的日志等等，有时候还和其他攻击方式同时实施比如SQL注入攻击服务器和数据库、Click劫持、相对链接劫持等实施钓鱼，它带来的危害是巨大的，是web安全的头号大敌。',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('467','1','原型链','3','4',NULL,'在JavaScript中，每当定义一个对象（函数也是对象）时候，对象中都会包含一些预定义的属性。其中每个函数对象都有一个prototype属性，这个属性指向函数的原型对象。当一个对象查找有个属性或者方法的时候，首先在自身上查找，如果没有就到原型上查找，这样形成的链条我们成为原型链',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('468','1','box-sizing的了解','3','2',NULL,'box-sizing，css3新属性，为了改变ie浏览器的盒模型遗留的width（名副其实）bug',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('469','1','webpack有用么？','3','4',NULL,'工程化工具代码编译、压缩、合并、CSS解析等等',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('470','1','es6有哪些新特性，let和var有什么区别','3','5',NULL,'通过var定义的变量，作用域是整个封闭函数，是全域的。通过let定义的变量，作用域是在块级或是子块中',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('471','1','抓包工具有哪些','3','5',NULL,'FiddlerCharlesAnyproxymitmproxy/mitmdump',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('472','1','状态码知道那些','3','3',NULL,'200（成功）服务器已成功处理了请求，300（多种选择）针对请求，服务器可执行多种操作，400（错误请求）服务器不理解请求的语法，404（未找到）服务器找不到请求的网页。500（服务器内部错误）服务器遇到错误，无法完成请求',NULL,'1','1','1','5','2022-08-21 17:21:16','2022-08-21 17:21:16'),('473','1','call和apply的区别','3','5',NULL,'call函数和apply方法的第一个参数都是要传入给当前对象的对象，及函数内部的this。后面的参数都是传递给当前对象的参数。',NULL,'1','1','1','5','2023-05-26 10:22:16','2023-05-26 10:22:16'),('474','1','对原生js的了解','3','4',NULL,'原生态js是指遵循ECMAscript标准的javascript，不同于微软的jscript也不依赖于任何框架，依托于浏览器标准引擎的脚本语言，jquery是在原生态的js上集成的框架资源，使用jquery并不代表代码就不是你写的，区别在于使用jquery只是使用了它的语法，更利于兼容以及实现，jquery已经将常规的js兼容问题解决，所以使用起来出现不兼容的情况会更少，更利于开发，但同时，要使用jquery等框架也需要去学习相关的语法，拥有js基础的同学学习jquery时会发现很轻松，在使用时也会发现很方便',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('475','1','数据返回有问题了怎么处理','3','5',NULL,'这个要看具体的是报的什么错误，根据提示的错误信息来进行修改',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('476','1','除了npm你还知道什么','3','5',NULL,'包管理工具还有yarncnpm',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('477','1','怎么获取载入当前文档的前一个url','3','4',NULL,'document.URL;',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('478','1','权限管理如何实现的','3','4',NULL,'RBAC就是用户通过角色与权限进行关联。简单地说，一个用户拥有若干角色，每一个角色拥有若干权限。这样，就构造成&ldquo;用户-角色-权限&rdquo;的授权模型。在这种模型中，用户与角色之间，角色与权限之间，一般者是多对多的关系。当用户发生变化的时候，相应的角色也相应变化，并且改变人员的角色信息，添加保存，添加保存的基本思路是先把数据库里人员对应的角色信息全部删除，然后再取到选中的部分，添加到数据库。一般说来有三表、四表、五表三种方式可以实现RBAC，我们常用五表来做，因为对表的操作更加灵活，拓展性更好',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('479','1','redis的特性有哪些','3','4',NULL,'Redis 特点一、Redis数据库完全在内存中，使用磁盘仅用于持久性。二、相比许多键值数据存储，Redis拥有一套较为丰富的数据类型。三、Redis可以将数据复制到任意数量的从服务器。Redis 优势1、异常快速：Redis的速度非常快，每秒能执行约11万集合，每秒约81000+条记录。2、支持丰富的数据类型：Redis支持Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。这使得它非常容易解决各种各样的问题，因为我们知道哪些问题是可以处理通过它的数据类型更好。3、操作都是原子性：所有Redis操作是原子的，这保证了如果两个客户端同时访问的Redis服务器将获得更新后的值。4、多功能实用工具：Redis是一个多实用的工具，可以在多个用例如缓存，消息，队列使用(Redis原生支持发布/订阅)，任何短暂的数据，应用程序，如Web应用程序会话，网页命中计数等',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('480','1','模糊查询怎么实现的','3','4',NULL,'模糊查询有四种方式：1、% ：表示任意0个或多个字符。可匹配任意类型和长度的字符，有些情况下若是中文，请使用两个百分号（%%）表示；2，_ ： 表示任意单个字符。匹配单个任意字符，它常用来限制表达式的字符长度语句；3，[ ] ：表示括号内所列字符中的一个（类似正则表达式）。指定一个字符、字符串或范围，要求所匹配对象为它们中的任一个4，[^ ] ：表示不在括号所列之内的单个字符。其取值和 [] 相同，但它要求所匹配对象为指定字符以外的任一个字符',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('481','1','如何实现分页','3','4',NULL,'首次渲染页面时通过获取数据总数然后除以每页显示的数量结果向上取整获取到总的页码数，将页码展示在页面上，通过点击页码传递需要展示页数，后端接收页码配合每页的数量获取数据，此处需要使用sql语句中的limit语句，查询并返回需要的数据。',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('482','1','谈谈对oop的理解','3','2',NULL,'OOP 达到了软件工程的三个主要目标：重用性、灵活性和扩展性OOP有三大特性：继承、封装、多态OOP的优点：代码维护更容易代码质量更高开发的效率更高易拓展OOP思想中有MVC结构',NULL,'1','1','1','5','2022-08-21 17:21:16','2022-08-21 17:21:16'),('483','1','Empty和isset以及is_null的区别','3','2',NULL,'Empty，检测变量是否为&ldquo;空&rdquo;说明：任何一个未初始化的变量、值为 0 或 false 或 空字符串&rdquo;&quot; 或 null的变量、空数组、没有任何属性的对象，都将判断empty==true；未初始化的变量也能被empty检测为&ldquo;空&rdquo;，empty只能检测变量，而不能检测语句isset判断变量是否被初始化说明：它并不会判断变量是否为空，并且可以用来判断数组中元素是否被定义过,当使用isset来判断数组元素是否被初始化过时，它的效率比array_key_exists高4倍左右is_null：检测变量是否为&ldquo;null&rdquo;，当变量被赋值为&ldquo;null&rdquo;时，检测结果为true',NULL,'1','1','1','5','2023-05-26 10:22:16','2023-05-26 10:22:16'),('484','1','Include require include_once require_once 的区别.','3','2',NULL,'处理失败方式不同：require 失败时会产生一个致命级别错误，并停止程序运行。include 失败时只产生一个警告级别错误，程序继续运行。include_once/require_once和include/require 处理错误方式一样，唯一区别在于当所包含的文件代码已经存在时候，不在包含。',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('485','1','Include require include_once require_once 的区别.','3','2',NULL,'处理失败方式不同：require 失败时会产生一个致命级别错误，并停止程序运行。include 失败时只产生一个警告级别错误，程序继续运行。include_once/require_once和include/require 处理错误方式一样',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('486','1','ajax是什么？','3','2',NULL,'ajax是指一种创建交互式网页应用的网页开发技术，简单的说就是一个异步页面交互技术',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('487','1','说出你知道的一些php魔术方法','3','2',NULL,'__construct() 实例化类时自动调用。__destruct() 类对象使用结束时自动调用。__set() 在给未定义的属性赋值的时候调用。__get() 调用未定义的属性时候调用。__isset() 使用isset()或empty()函数时候会调用。__unset() 使用unset()时候会调用。__sleep() 使用serialize序列化时候调用。__wakeup() 使用unserialize反序列化的时候调用',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('488','1','优化SQL语句执行效率的方法，如何分析SQL语句','3','4',NULL,'（1）选择最有效率的表名顺序（2）WHERE子句中的连接顺序（3）SELECT子句中避免使用&lsquo;*&rsquo;（4）用Where子句替换HAVING子句（5）通过内部函数提高SQL效率（6）避免在索引列上使用计算。（7）提高GROUP BY 语句的效率, 可以通过将不需要的记录在GROUP BY 之前过滤掉',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('489','1','MYSQL索引的实现？','3','4',NULL,'按照分类，将索引列分成N多个磁盘块，使用B-Ztree或者B+Ztree（就是二叉树）查找，这样时间复杂度就是㏒(m+1)N，这里假设当前数据表的数据为N，每个磁盘块的数据项的数量是m',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('490','1','对于大流量的网站,您采用什么样的方法来解决各页面访问量统计问题','3','5',NULL,'1、通过第三方统计 站长之家等2、收集分析web服务器访问日志(access.log)3、自行通过编程方式，实现统计系统',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('491','1','MySQL数据库作发布系统的存储，一天五万条以上的增量，预计运维三年,怎么优化？','3','5',NULL,'a. 设计良好的数据库结构，允许部分数据冗余，尽量避免join查询，提高效率。b. 选择合适的表字段数据类型和存储引擎，适当的添加索引。c. mysql库主从读写分离。d. 找规律分表，减少单表中的数据量提高查询速度。e。添加缓存机制，比如memcached，apc等。f. 不经常改动的页面，生成静态页面。g. 书写高效率的SQL。比如 SELECT * FROM TABEL 改为 SELECT field_1, field_2, field_3 FROM TABLE.',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('492','1','优化某网页的加载速度','3','5',NULL,'1、gzip压缩2、减少http请求（负载均衡技术，集群技术）3、压缩js、css文件4、使用页面静态化技术5、页面懒加载技术6、使用CDN - web服务器离用户更近，则多个HTTP请求的响应时间将缩短',NULL,'1','1','1','5','2022-08-21 17:21:16','2022-08-21 17:21:16'),('493','1','什么是存储过程、事务','3','2',NULL,'是两个概念，存储过程是完成一定功能的可重复调用的程序。即，存储过程是程序。事务是可以整个撤消的一段操作，可能是一个或几个或部份的存储过程，也可能是一条或几条指令，事务是记录的一系列的操作和变化。',NULL,'1','1','1','5','2023-05-26 10:22:16','2023-05-26 10:22:16'),('494','1','有用过跨越请求吗，有几种方式可以实现','3','4',NULL,'四种跨越请求：1、通过json跨域；2、通过doument.domian来跨子域；3通过window.name来跨域；4、使用HTML5中新引进的window.postMessage方法来跨域传送数据',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('495','1','如何防止SQL注入','3','4',NULL,'（1）使用mysql_real_escape_string：转义 SQL 语句中使用的字符串中的特殊字符，并考虑到连接的当前字符集（2）打开magic_quotes_gpc来防止SQL注入：php.ini中有一个设置：magic_quotes_gpc = Off这个默认是关闭的，如果它打开后将自动把用户提交对sql的查询进行转换，比如把 &#39; 转为 \\&#39;等，对于防止sql注射有重大作用。（3）如果magic_quotes_gpc=Off，则使用addslashes()函数或者是使用自定义函数：利用正则匹配；判断参数的合法性',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('496','1','XSS攻击有哪些常见的形式？如何防止XSS攻击','3','4',NULL,'XSS是用户在表单中有意或无意输入一些恶意字符，从而破坏页面的表现！看看常见的恶意字符XSS 输入：1.XSS 输入通常包含 JavaScript 脚本，如弹出恶意警告框：&lt;script&gt;alert(&quot;XSS&quot;);&lt;/script&gt;2.XSS 输入也可能是 HTML 代码段，譬如：(1).网页不停地刷新 &lt;meta http-equiv=&quot;refresh&quot; content=&quot;0;&quot;&gt;(2).嵌入其它网站的链接 &lt;iframe src=http://xxxx width=250 height=250&gt;&lt;/iframe&gt;防止XSS攻击：1、利用 htmlspecialchars() 函数 和 htmlentities() 函数;2、可以定义一个xclean()函数（笔记中有，可以自行查看）;3、可以使用自定义函数，实现放sql注入和xss，具体的代码可以自行搜索</',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('497','1','如何防止暴力破解','3','4',NULL,'1、使用验证码2、使用token令牌3、提交前客户端加密后台解密4、IP及IP段限制进行访问限制',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('498','1','memcache是怎么工作的？Memcache的缓存策略是什么？','3','4',NULL,'Memcache的缓存策略：当memcache服务器的hash表满了之后，新的插入数据会替代老的数据，更新的策略是LRU（最近最少使用），以及每个kv对的有效时限。Kv对存储有效时限是在mc端设置并作为参数传给memcache服务器的。同时memcache服务器采用是偷懒替代法，memcache服务器不会开额外的进程来实时监测过时的kv对并删除，而是当且仅当，新来一个插入的数据，而此时又没有多余的空间放了，才会进行清除动作。',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('499','1','memcache的优缺点','3','4',NULL,'memcached的特点：1.全内存运转2.哈希方式存储3.简单文本协议进行数据通信4.只操作字符型数据5.其它类型数据由应用解释，序列化以及反序列化6.集群也由应用进行控制，采用一致性散列（哈希）算法Memcached的最大优势是：memcached之间没有相互通信，因此不会增加memcached的负载；没有多播协议，不会网络通信量爆炸（implode）Memcached的缺点1、纯内存操作，关机后数据全部丢失2、保存字节数据，数据类型贫乏3、LRU算法导致数据不可控的丢失4、一致性处理简单5、应用端太厚，服务器端太薄6、应用场景有限，难以被看成是完整的数据库产品',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('5','1','以下选项对Lambda说法错误的是 ?（） ','1','2',NULL,'',NULL,'1','3','2','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('50','2','MySQL数据库有几个配置选项可以帮助我们及时捕获低效SQL语句','3','5',NULL,'1，slow_query_log这个参数设置为ON，可以捕获执行时间超过一定数值的SQL语句。2，long_query_time当SQL语句执行时间超过此数值时，就会被记录到日志中，建议设置为1或者更短。3，slow_query_log_file记录日志的文件名。4，log_queries_not_using_indexes这个参数设置为ON，可以捕获到所有未使用索引的SQL语句，尽管这个SQL语句有可能执行得挺快',NULL,'0','0','0','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('500','1','memcached、redis 和MySQL的query的对比','3','4',NULL,'Redis 和 memcached ：1、Redis只使用单核，而Memcached可以使用多核。2、Redis在存储小数据时比Memcached性能更高；而在100k以上的数据中，Memcached性能要高于Redis3、简单的key-value存储，Memcached的内存利用率更高。而如果Redis采用hash结构来做key-value存储，由于其组合式的压缩，其内存利用率会高于Memcached4、如果对数据持久化和数据同步有所要求，那么Redis性能高于Memcached5、Redis相比Memcached来说，拥有更多的数据结构，并支持更丰富的数据操作6、在Redis中，复杂的操作通常和一般的GET/SET一样高效。需要缓存能够支持更复杂的结构和操作，所以Redis 在这方面的性能要更高memcached和MySQL的query cache：1、当修改表时，MySQL的query cache会立刻被刷新（flush）。存储一个memca',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('501','2','memcached的cache机制是怎样的','3','5',NULL,'Memcached主要的cache机制是LRU（最近最少用）算法+超时失效。当存数据到memcached中，可以指定该数据在缓存中可以呆多久。如果memcached的内存不够用了，过期的数据会优先被替换，接着就轮到最老的未被使用的数据。',NULL,'1','1','1','6','2023-02-25 16:21:16','2023-02-25 16:21:16'),('502','2','Redis 常见的性能问题都有哪些？如何解决','3','4',NULL,'1、写内存快照：当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以主服务器最好不要写内存快照。2、AOF持久化：如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响主服务器重启的恢复速度。主服务器最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化,如果数据比较关键，某个从服务器开启AOF备份数据，策略为每秒同步一次。3、主服务器调用重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。4、Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，从服务器和主服务器最好在同一个局域网内',NULL,'1','1','1','6','2022-08-21 17:21:16','2022-08-21 17:21:16'),('503','2','PHP静态化技术','3','4',NULL,'A、什么是PHP静态化PHP静态化的简单理解就是使网站生成页面以静态HTML的形式展现在访客面前，PHP静态化分纯静态化（主要是用到ob缓存）和伪静态化（重写机制），两者的区别在于PHP生成静态页面的处理机制不同。B、为什么要让网页静态化一、加快页面打开浏览速度，静态页面无需连接数据库打开速度较动态页面有明显提高；二、有利于搜索引擎优化SEO，Baidu、Google都会优先收录静态页面，不仅被收录的快还收录的全；三、减轻服务器负担，浏览网页无需调用系统数据库；四、网站更安全，HTML页面不会受php相关漏洞的影响； 观看一下大一点的网站基本全是静态页面，而且可以减少攻击，防sql注入。五、数据库出错时，不影响网站正常访问。',NULL,'1','1','1','6','2023-05-26 10:22:16','2023-05-26 10:22:16'),('504','2','MySQL对千万级的大表要怎么优化','3','5',NULL,'第一优化sql和索引；第二加缓存，memcached,redis；第三做主从复制或主主复制，读写分离，可以在应用层做，效率高，也可以用三方工具第四mysql自带分区表，这个对用户的应用是透明的，无需更改代码,但是sql语句是需要针对分区表做优化的，sql条件中要带上分区条件的列，从而使查询定位到少量的分区上，否则就会扫描全部分区，另外分区表也是可以的第五做垂直拆分，其实就是根据模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统；第六水平切分，针对数据量大的表，要选择一个合理的sharding key,为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('505','2','MySQL常用的函数','3','4',NULL,'mysql_affected_rows &mdash; 取得前一次 MySQL 操作所影响的记录行数mysql_close &mdash; 关闭 MySQL 连接mysql_connect &mdash; 打开一个到 MySQL 服务器的连接mysql_create_db &mdash; 新建一个 MySQL 数据库mysql_data_seek &mdash; 移动内部结果的指针mysql_db_name &mdash; 取得结果数据mysql_db_query &mdash; 发送一条 MySQL 查询mysql_drop_db &mdash; 丢弃（删除）一个 MySQL 数据库',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('506','2','PHP缓存技术有哪些','3','5',NULL,'1. 全页面静态化缓存，也就是将页面全部生成html静态页面，用户访问时直接访问的静态页面，而不会去走php服务器解析的流程2. 页面部分缓存，将一个页面中不经常变的部分进行静态缓存，而经常变化的块不缓存，最后组装在一起显示3. 数据缓存，通过一个id进行请求的数据,将数据缓存到一个php文件中,id和文件是对应的,下次通过这个id进行请求时 直接读php文件4. 查询缓存，和数据缓存差不多,根据查询语句进行缓存;5. 内存式缓存，Redis和memcache',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('507','2','MVC的优缺点','3','4',NULL,'优点：分散关注、松散耦合、逻辑复用、标准定义a. 开发人员可以只关注整个结构中的其中某一层，方便多开发人员间的分工b. 可以很容易的用新的实现来替换原有层次的实现c. 降低层与层之间的依赖d. 利于各层逻辑的复用，有利于标准化e. 对单元测试的支持更加出色缺点：a. 清晰的构架以代码的复杂性为代价， 对小项目优可能反而降低开发效率b. 降低了系统的性能，例如业务造访数据库现在必须通过中间层来完成c. 控制层和表现层有时会过于紧密，导致没有真正分离和重用d. 有时会导致级联的修改，如果在表示层中增加一个功能，为保证符合分层式结构，可能需要在相应的控制层和模型层中都增加相应的代码',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('508','2','说几个你知道的设计模式','3','5',NULL,'单例模式：保证一个类仅有一个实例，并提供一个访问他的全局访问点例如框架中的数据库连接简单工厂模式：它具有创建对象的某些方法，可以使用工厂类创建对象，而不直接使用 new。例如初始化数据库的时候会用到，比如MySQL，MSSQL策略模式：针对一组算法，将每一个算法封装到具有共同接口的独立的类中，例如进入个人主页时，根据浏览者的不同，给予不同的显示与操作注册模式：提供了在程序中有条理的存放并管理一组全局对象 (object)，例如ZF框架中的Zend_Registry::set适配器模式：将不同接口适配成统一的API接口，例如数据操作有mysql、mysqli、pdo等，可利用适配器模式统一接口观察者模式：一个对象通过添加一个方法使本身变得可观察。当可观察的对象更改时，它会将消息发送到已注册的观察者。例如实现实现消息推送装饰器模式：不修改原类代码和继承的情况下动态扩展类的功能，例如框架的每个Controller文件会提供before和after方法',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('509','2','shell命令方式向PHP传入参数的三种方式','3','5',NULL,'使用$argc $argv；使用getopt函数()；提示用户输入，然后获取输入的参数',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('510','2','php获取文件内容的方法，对应的函数','3','4',NULL,'a.file_get_contents得到文件的内容（可以以get和post的方式获取），整个文件读入一个字符串中b. 用fopen打开url, 以get方式获取内容（借助fgets()函数）c. 用fsockopen函数打开url（可以以get和post的方式获取），以get方式获取完整的数据，包括header和bodyd. 使用curl库获取内容，使用curl库之前，需要查看php.ini，查看是否已经打开了curl扩展',NULL,'1','1','1','6','2023-03-25 11:22:14','2023-03-25 11:22:14'),('511','2','HTTP协议的特点有哪些','3','4',NULL,'1、支持客户/服务器模式。2、简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。3、灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记。4、无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。5、无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('512','2','HTTP请求有哪些部分组成?http响应有哪些部分组成','3','4',NULL,'HTTP请求由三部分组成，分别是：请求行、消息报头、请求正文HTTP响应由三部分组成，分别是：状态行、消息报头、响应正文',NULL,'1','1','1','6','2022-08-21 17:21:16','2022-08-21 17:21:16'),('513','2','存储过程那这个技术有什么有点？','3','4',NULL,'存储过程的优点：1存储过程只在创造时进行编译，以后每次执行存储过程都不需再重新编译，而一般SQL语句每执行一次就编译一次,所以使用存储过程可提高数据库执行速度。2当对数据库进行复杂操作时(如对多个表进行Update,Insert,Query,Delete时），可将此复杂操作用存储过程封装起来与数据库提供的事务处理结合一起使用。3存储过程可以重复使用,可减少数据库开发人员的工作量4安全性高,可设定只有某此用户才具有对指定存储过程的使用权',NULL,'1','1','1','6','2023-05-26 10:22:16','2023-05-26 10:22:16'),('514','2','如何用node监听80端口','3','5',NULL,'这题有陷阱！在类Unix系统中你不应该尝试去监听80端口，因为这需要超级用户权限。 因此不推荐让你的应用直接监听这个端口。目前，如果一定要让应用监听80端口的话，你可以有通过在Node应用的前方再增加一层反向代理 （例如nginx）来实现。否则，建议你直接监听大于1024的端口',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('515','2','什么是事件循环','3','4',NULL,'Node采用的是单线程的处理机制（所有的I/O请求都采用非阻塞的工作方式），至少从Node.js开发者的角度是这样的。 而在底层，Node.js借助libuv来作为抽象封装层， 从而屏蔽不同操作系统的差异，Node可以借助livuv来来实现多线程',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('516','2','请写一段PHP代码，确保多个进程同时写入同一个文件成功','3','4',NULL,'function writeData($path, $mode, $data){ $fp = fopen($path, $mode); $retries = 0; $max_retries = 100;&nbs',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('517','2','Linux下修改/usr/local目录下的文件file的权限为755，修改/home/th1下的所有文件的所有者和组为th1和ggv？','3','4',NULL,'chmod 755 /usr/local/filechown -R th1:ggv /home/th1',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('518','2','php保存序列化对象到session中，并可以从session中获取序列化对象的值，用什么序列化函数？','3','4',NULL,'serialize()函数序列化对象; unserialize()函数还原序列化对象。',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('519','2','php中的文件读写操作，读取文件test.txt中前300字节的内容','3','4',NULL,'$handle=fopen(&quot;test.txt&quot;,&quot;r&quot;);$contents=fread($handle,300);fclose($handle);',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('520','2','如何用PHP和MySQL上传视频','3','4',NULL,'可以在数据库中存放视频的地址，而不需要将真正的视频数据存在数据库中。可以将视频数据存放在服务器的指定文件夹下，上传的默认大小是2MB，但是我们也可以在php.ini文件中修改max_file size选项来改变。',NULL,'1','1','1','6','2022-08-21 17:21:16','2022-08-21 17:21:16'),('521','2','前端性能优化的方式有哪些','3','4',NULL,'1.减少DOM操作2.部署前，图片压缩，代码压缩3.优化JS代码结构，减少冗余代码4.减少HTTP请求，合理设置HTTP缓存5.使用内容分发CDN加速6.静态资源缓存7.图片延迟加载',NULL,'1','1','1','6','2022-08-21 17:21:16','2022-08-21 17:21:16'),('522','2','一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好）','3','5',NULL,'1.浏览器查找域名的 IP 地址2.这一步包括 DNS 具体的查找过程，包括：浏览器缓存-&gt;系统缓存-&gt;路由器缓存&hellip;3.浏览器向 web 服务器发送一个 HTTP 请求4.服务器的永久重定向响应（从 http://example.com 到 http://www.example.com）5.浏览器跟踪重定向地址6.服务器处理请求7.服务器返回一个 HTTP 响应8.浏览器显示 HTML9.浏览器发送请求获取嵌入在 HTML 中的资源（如图片、音频、视频、CSS、JS等等）10.浏览器发送异步请求',NULL,'1','1','1','6','2022-08-21 17:21:16','2022-08-21 17:21:16'),('523','2','js深度复制的方式','3','5',NULL,'1.使用jq的$.extend(true,target,obj)2.newobj=Object.create(sourceObj)，// 但是这个是有个问题就是 newobj的更改不会影响到 sourceobj但是 sourceobj的更改会影响到newObj3.newobj=JSON.parse(JSON.stringify(sourceObj))',NULL,'1','1','1','6','2023-05-26 10:22:16','2023-05-26 10:22:16'),('524','2','解释一下rem','3','1',NULL,'em是相对于html元素的font-size的一个单位。如果html上定义了font-size:20px;，则无论在任何地方都是1rem=20px这个大小不会受到父元素的影响。我们统一使用rem对页面进行整体缩放。强烈建议大家对需要适应页面大小的任何元素都使用rem为单位来定义。',NULL,'1','1','1','6','2022-08-21 17:21:16','2022-08-21 17:21:16'),('525','2','position有几个值','3','1',NULL,'四个值',NULL,'1','1','1','6','2022-08-21 17:21:16','2022-08-21 17:21:16'),('526','2','怎样使一个盒子垂直居中','3','2',NULL,'tatic默认值。无特殊定位，对象遵循HTML定位规则（忽略top,bottom,left,right或者z-index声明）。absolute将对象从文档流中拖出，使用left，right，top，bottom等属性相对于其最接近的一个最有定位设置的父对象进行绝对定位。如果不存在这样的父对象，则依据body对象。而其层叠通过z-index属性定义fixed未支持。对象定位遵从绝对(absolute)方式。但是要遵守一些规范relative对象不可层叠，但将依据left，right，top，bottom等属性在正常文档流中偏移位置',NULL,'1','1','1','6','2022-08-21 17:21:16','2022-08-21 17:21:16'),('527','2','css中权重顺序','3','1',NULL,'important&gt;内嵌样式&gt;ID&gt;类&gt;标签|伪类|属性选择&gt;伪对象&gt;继承&gt;通配符',NULL,'1','1','1','6','2022-08-21 17:21:16','2022-08-21 17:21:16'),('528','2','opacity和rgba在ie下有什么区别','3','1',NULL,'CSS样式中，设置透明度的方式有两种。其一，opacity；其二rgba()。opacity和rgba()在一定程度上是没什么区别。但是，如果你只想给背景加上一个透明度，而背景上的字体获取其他元素保持不变的话，那么最好的办法就是用rgba()。因为opacity的透明度会传递给他的子元素，使得子元素也变得透明，看起来很不爽。',NULL,'1','1','1','6','2022-08-21 17:21:16','2022-08-21 17:21:16'),('529','2','行内元素的padding、margin是否无效？','3','1',NULL,'行内元素的padding-top、padding-bottom、margin-top、margin-bottom属性设置是无效的；行内元素的padding-left、padding-right、margin-left、margin-bottom属性设置是有效的；行内元素的padding-top、padding-bottom从显示的效果上是增加的，但其实设置的是无效的。并不会对他周围的元素产生任何影响。',NULL,'1','1','1','6','2022-08-21 17:21:16','2022-08-21 17:21:16'),('53','2','简述一下Django与Tornado的关系与区别','3','3',NULL,'Django注重高效开发全自动化的管理后台（只需要使用起ORM，做简单的定义，就能自动生成数据库结构，全功能的管理后台）session功能Tornado注重性能优越，速度快解决高并发异步非阻塞websockets长连接内嵌了HTTP服务器单线程的异步网络程序，默认启动时根据CPU数量运行多个实例；利用CPU多核的优势。',NULL,'1','1','1','2','2023-05-26 10:22:16','2023-05-26 10:22:16'),('530','2','简单描述下微信小程序的相关文件类型?','3','1',NULL,'微信小程序项目结构主要有四个文件类型,如下（1）、WXML(WeiXinMarkupLanguage)是框架设计的一套标签语言，结合基础组件、事件系统，可以构建出页面的结构。内部主要是微信自己定义的一套组件。（2）、WXSS(WeiXinStyleSheets)是一套样式语言，用于描述WXML的组件样式，二、js逻辑处理，网络请求 三、json小程序设置，如页面注册，页面标题及tabBar。',NULL,'1','1','1','6','2023-05-26 10:22:16','2023-05-26 10:22:16'),('531','2','你是怎么封装微信小程序的数据请求的?','3','2',NULL,'（1）、将所有的接口放在统一的js2）、在app.js中创建封装请求数据的方法三、在子页面中调用封装的方法请求数据文件中并导出',NULL,'1','1','1','6','2023-05-26 10:22:16','2023-05-26 10:22:16'),('532','2','有哪些参数传值的方法?','3','2',NULL,'（1）、给HTML元素添加data-*属性来传递我们需要的值，然后通过e.currentTarget.dataset或onload的param参数获取。但data-名称不能有大写字母和不可以存放对象 二、设置id的方法标识来传值通过e.currentTarget.id获取设置的id的值,然后通过设置全局对象的方式来传递数值 三、在navigator中添加参数传值',NULL,'1','1','1','6','2023-05-26 10:22:16','2023-05-26 10:22:16'),('533','2','你使用过哪些方法，来提高微信小程序的应用速度?','3','2',NULL,'一、提高页面加载速度二、用户行为预测三、减少默认data的大小四、组件化方案',NULL,'1','1','1','6','2023-05-26 10:22:16','2023-05-26 10:22:16'),('534','2','小程序与原生App哪个好?','3','2',NULL,'小程序除了拥有公众号的低开发成本、低获客成本低以及无需下载等优势，在服务请求延时与用户使用体验是都得到了较大幅度的提升，使得其能够承载跟复杂的服务功能以及使用户获得更好的用户体验。',NULL,'1','1','1','6','2023-05-26 10:22:16','2023-05-26 10:22:16'),('535','2','简述微信小程序原理?','3','2',NULL,'微信小程序采用JavaScript、WXML、WXSS三种技术进行开发，从技术讲和现有的前端开发差不多，但深入挖掘的话却又有所不同。JavaScript:首先JavaScript的代码是运行在微信App中的，并不是运行在浏览器中，因此一些H5技术的应用，需要微信App提供对应的API支持，而这限制住了H5技术的应用，且其不能称为严格的H5，可以称其为伪H5，同理，微信提供的独有的某些API，H5也不支持或支持的不是特别好。WXML:WXML微信自己基于XML语法开发的，因此开发时，只能使用微信提供的现有标签，HTML的标签是无法使用的。WXSS:WXSS具有&nb',NULL,'1','1','1','6','2023-05-26 10:22:16','2023-05-26 10:22:16'),('536','2','分析下微信小程序的优劣势?','3','2',NULL,'优势:1、无需下载，通过搜索和扫一扫就可以打开。2、良好的用户体验:打开速度快。3、开发成本要比App要低。4、安卓上可以添加到桌面，与原生App差不多。5、为用户提供良好的安全保障。小程序的发布，微信拥有一套严格的审查流程，不能通过审查的小程序是无法发布到线上的。劣势: 1、限制较多。页面大小不能超过1M。不能打开超过5个层级的页面。2、样式单一。小程序的部分组件已经是成型的了，样式不可以修改。例如:幻灯片、导航。3、推广面窄，不能分享朋友圈，只能通过分享给朋友，附近小程序推广。其中附近小程序也受到微信的限制。4、依托于微信，无法开发后台管理功能。',NULL,'1','1','1','6','2023-05-26 10:22:16','2023-05-26 10:22:16'),('537','2','微信小程序与H5的区别?','3','2',NULL,'第一条是运行环境的不同传统的HTML5的运行环境是浏览器，包括webview，而微信小程序的运行环境并非完整的浏览器，是微信开发团队基于浏览器内核完全重构的一个内置解析器，针对小程序专门做了优化，配合自己定义的开发语言标准，提升了小程序的性能。第二条是开发成本的不同只在微信中运行，所以不用再去顾虑浏览器兼容性，不用担心生产环境中出现不可预料的奇妙BUG第三条是获取系统级权限的不同系统级权限都可以和微信小程序无缝衔接第四条便是应用在生产环境的运行流畅度长久以来，当HTML5应用面对复杂的业务逻辑或者丰富的页面交互时，它的体验总是不尽人意，需要不断的对项目优化来提升用户体验。但是由于微信小程序运行环境独立',NULL,'1','1','1','6','2023-05-26 10:22:16','2023-05-26 10:22:16'),('538','2','怎么解决小程序的异步请求问题?','3','2',NULL,'9、怎么解决小程序的异步请求问题?答:在回调函数中调用下一个组件的函数:app.jssuccess:function(info){that.apirtnCallback(info)}index.jsonLoad:function(){app.apirtnCallback=res=&gt;{console.log(res)}}',NULL,'1','1','1','6','2023-05-26 10:22:16','2023-05-26 10:22:16'),('539','2','小程序的双向绑定和vue哪里不一样?','3','2',NULL,'小程序直接this.data的属性是不可以同步到视图的，必须调用:this.setData({noBind:true})',NULL,'1','1','1','6','2023-05-26 10:22:16','2023-05-26 10:22:16'),('54','2','Django的model继承有几种形式，分别是什么？','3','3',NULL,'模型继承一.抽象基类继承二.多表格继承三.代理模型四.多继承',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('540','2','小程序的wxss和css有哪些不一样的地方?','3','2',NULL,'一、wxss的图片引入需使用外链地址;二、没有Body;样式可直接使用import导入',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('541','2','webview中的页面怎么跳回小程序中?','3','5',NULL,'首先要引入最新版的jweixin-1.3.2.js，然后wx.miniProgram.navigateTo({url:&#39;/pages/login/login&#39;+&#39;$params&#39;})',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('543','2','小程序关联微信公众号如何确定用户的唯一性?','3','2',NULL,'使用wx.getUserInfo方法withCredentials为true时可获取encryptedData，里面有union_id。后端需要进行对称解密',NULL,'1','1','1','6','2023-05-26 10:22:16','2023-05-26 10:22:16'),('544','2','如何实现下拉刷新?','3','5',NULL,'用view代替scroll-view,,设置onPullDownRefresh函数实现(责任编辑:admin)',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('545','2','你是怎么封装微信小程序的数据请求的?','3','2',NULL,'一、将所有的接口放在统一的js文件中并导出二、在app.js中创建封装请求数据的方法三、在子页面中调用封装的方法请求数据',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('546','2','有哪些参数传值的方法?','3','2',NULL,'一、给HTML元素添加data-*属性来传递我们需要的值，然后通过e.currentTarget.dataset或onload的param参数获取。但data-名称不能有大写字母和不可以存放对象 二、设置id的方法标识来传值通过e.currentTarget.id获取设置的id的值,然后通过设置全局对象的方式来传递数值 三、在navigator中添加参数传值',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('547','2','谈谈你对前端性能优化得理解','3','2',NULL,'a)要避免代码的深层级嵌套。因为层级越深的节点在初始化时更占内存。b)诸如img、link、script等元素的src或href属性的值不为空，因为就算我们写为src=&quot;&quot;浏览器仍会发送http请求c)在html文档开始就指定文档字符集，这样做的目的是在有助于浏览器加载时就能立即解析html代码',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('548','2','谈谈作为一个前端开发人员来讲，seo优化需要考虑什么','3','2',NULL,'a)做好404页面b)目录结构不易过深，最好不超出三层&lsquo;c)图片一定要加alt属性，便于引擎搜索',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('549','2','自定义指令(v-check、v-focus)的方法有哪些?它有哪些钩子函数?还有哪些钩子函数参数?','3','2',NULL,'全局定义指令:在vue对象的directive方法里面有两个参数，一个是指令名称，另外一个是函数。组件内定义指令:directives钩子函数:bind(绑定事件触发)、inserted(节点插入的时候触发)、update(组件内相关更新)',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('55','2','Scrapy中间件有几种类？','3','4',NULL,'scrapy的中间件理论上有三种SchdulerMiddleware,SpiderMiddleware,DownloaderMiddleware，在应用上一般有以下两种1.爬虫中间件SpiderMiddleware主要功能是在爬虫运行过程中进行一些处理.2.下载器中间件DownloaderMiddleware',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('550','2','说出至少4种vue当中的指令和它的用法?','3','3',NULL,'v-if:判断是否隐藏;v-for:数据循环出来;v-bind:class:绑定一个属性;v-mode实现双向绑定',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('551','2','导航钩子有哪些?它们有哪些参数?','3','3',NULL,'导航钩子有:a/全局钩子和组件内独享的钩子。b/beforeRouteEnter、afterEnter、beforeRouterUpdate、beforeRouteLeave参数:有to(去的那个路由)、from(离开的路由)、next(一定要用这个函数才能去到下一个路由，如果不用就拦截)最常用就这几种rEnter、beforeRouterUpdate、beforeRouteLeave',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('552','2','请详细说下你对vue生命周期的理解?','3','3',NULL,'总共分为8个阶段创建前/后，载入前/后，更新前/后，销毁前/后。创建前/后:在beforeCreated阶段，vue实例的挂载元素$el和数据对象data都为undefined，还未初始化。在created阶段，vue实例的数据对象data有了，$el还没有。载入前/后:在beforeMount阶段，vue实例的$el和data都初始化了，但还是挂载之前为虚拟的dom节点，data.message还未替换。在mounted阶段，vue实例挂载完成，data.message成功渲染。更新前/后:当data&nb',NULL,'1','1','1','6','2022-08-21 17:21:16','2022-08-21 17:21:16'),('553','2','请说下封装vue组件的过程?','3','3',NULL,'首先，组件可以提升整个项目的开发效率。能够把页面抽象成多个相对独立的模块，解决了我们传统项目开发:效率低、难维护、复用性等问题。然后，使用Vue.extend方法创建一个组件，然后使用Vue.component方法注册组件。子组件需要数据，可以在props中接受定义。而子组件修改好数据后，想把数据传递给父组件。可以采用emit方法。',NULL,'1','1','1','6','2023-05-26 10:22:16','2023-05-26 10:22:16'),('554','2','你是怎么认识vuex的?','3','3',NULL,'vuex可以理解为一种开发模式或框架。比如PHP有thinkphp，java有spring等。通过状态(数据源)集中管理驱动组件的变化(好比spring的IOC容器对bean进行集中管理)。应用级的状态集中放在store中;改变状态的方式是提交mutations，这是个同步的事物;异步逻辑应该封装在action中。',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('555','2','聊聊你对Vue.js的template编译的理解?','3','3',NULL,'简而言之，就是先转化成AST树，再得到的render函数返回VNode(Vue的虚拟DOM节点)详情步骤:首先，通过compile编译器把template编译成AST语法树(abstractsyntaxtree即源代码的抽象语法结构的树状表现形式)，compile是createCompiler的返回值，createCompiler是用以创建编译器的。另外compile还负责合并option。然后，AST会经过generate(将AST语法树转化成renderfuntion字符串的过程)',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('556','2','使用过element.ui吗?说下它其中两个组件的使用方法?','3','3',NULL,'使用过用过一个布局的，它是由24份，它的写法是:span后面带的数字它占24份里面的宽度。:offset是它的间距，后面也是跟数字，也是从24份里面取的。 input按钮，标签是el-input，后面type跟上一个属性就是显示不同按钮的类型，有默认的default(默认的)、success(成功的)、warning(警告)、danger(危险)、info()、primary() ',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('557','2','说出你所使用过的vue指令','3','3',NULL,'第一点、可以通用   第二点、代码尽量简洁第三点、容易修改  第四点、功能要多一点',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('558','2','vuex有哪几种属性?','3','3',NULL,'有五种，分别是State、Getter、Mutation、Action、Module',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('559','2','vuex的State特性是?','3','3',NULL,'一、Vuex就是一个仓库，仓库里面放了很多对象。其中state就是数据源存放地，对应于与一般Vue对象里面的data二、state里面存放的数据是响应式的，Vue组件从store中读取数据，若是store中的数据发生改变，依赖这个数据的组件也会发生更新三、它通过mapState把全局的state和getters映射到当前组件的computed计算属性中',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('560','2','vuex的Getter特性是? ','3','3',NULL,' 一、getters可以对State进行计算操作，它就是Store的计算属性 二、虽然在组件内也可以做计算属性，但是getters可以在多组件之间复用三、如果一个状态只在一个组件内使用，是可以不用getters 4、vuex的Mutation特性是? 答: 一、Action类似于mutation，不同在于:二、Action提交的是mutation，而不是直接变更状态。三、Action可以包含任意异步操作',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('561','2','不用Vuex会带来什么问题?','3','3',NULL,'一、可维护性会下降，你要想修改数据，你得维护三个地方二、可读性会下降，因为一个组件里的数据，你根本就看不出来是从哪来的三、增加耦合，大量的上传派发，会让耦合性大大的增加，本来Vue用Component就是为了减少耦合，现在这么用，和组件化的初衷相背。生命周期 1、什么是vue生命周期?',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('562','2','vue生命周期的作用是什么?','3','3',NULL,'它的生命周期中有多个事件钩子，让我们在控制整个Vue实例的过程时更容易形成好的逻辑。',NULL,'1','1','1','6','2022-08-21 17:21:16','2022-08-21 17:21:16'),('563','2','第一次页面加载会触发哪几个钩子','3','3',NULL,'第一次页面加载时会触发<strong>beforeCreate,created,beforeMount,mounted</strong>这几个钩子',NULL,'1','1','1','6','2023-05-26 10:22:16','2023-05-26 10:22:16'),('564','2','axios的特点有哪些?','3','3',NULL,'一、Axios是一个基于promise的HTTP库，支持promise所有的API二、它可以拦截请求和响应三、它可以转换请求数据和响应数据，并对响应回来的内容自动转换成JSON类型的数据四、安全性更高，客户端支持防御XSRF',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('565','2','axios有哪些常用方法?','3','3',NULL,'一、axios.get(url[,config])//get请求用于列表和信息查询二、axios.delete(url[,config])//删除 三、axios.post(url[,data[,config]])//post请求用于信息的添加四、axios.put(url[,data[,config]])//更新操作',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('567','2','谈谈以前端角度出发做好SEO需要考虑什么?','3','3',NULL,'主要包括主题(Title),网站描述(Description),和关键词(Keywords).其他还有Author(作者),Category(目录),Language(编码语种)等.放置关键词关键词分析和选择是SEO最重要的工作之一.首先要给网站确定主关键词(一般在5个上下),然后针对这些关键词进行优化,包括关键词密度(Density),相关度(Relavancy),突出性(Prominency)等等.的搜索引擎',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('568','2','简介盒子模型','3','2',NULL,'CSS的盒子模型有两种:IE盒子模型、标准的W3C盒子模型模型.内容(content)、填充(padding)、边框(border)、边界(margin)都是盒模型的基本属性.区别: 标准的W3C盒子模型模型:设置的border值只包括content和padding.IE盒子模型:设置的border值包括content,padding和border值.CSS的盒子模型有两种:IE盒子模型、标准的W3C盒子模型模型.内容(content)、填充(padding)、边框(border)、边界(margin)都是盒模型的基本属性.区别: 标准的W3C盒子模型模型:&nbsp',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('569','2','如何垂直居中一个浮动元素?','3','2',NULL,'1.已知浮动元素的宽高设定父元素为相对定位,浮动元素为绝对定位top和left为50%,再设置浮动元素的margin-left/top值为浮动元素宽高一半的负值.2.不知道浮动元素的宽高设定父元素为相对定位,浮动元素为绝对定位.且left/right/top/bottom设置为0,再给浮动元素设置marginauto.另:如何居中div?答:默认div有宽度,设置margin:0auto; ',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('570','2','Sass、LESS是什么?大家为什么要使用他们?','3','2',NULL,'CSS预处理器是一种语言用来为CSS增加一些编程的的特性,无需考虑浏览器的兼容性问题,例如你可以在CSS中使用变量、简单的程序逻辑、函数等等在编程语言中的一些基本技巧,可以让你的CSS更见简洁,适应性更强,代码更直观等诸多好处.SASS、LESS是最常见的.Less是一种.将CSS赋予了动态语言的特性,如变量,继承,运算,函数.LESS既可以在客户端上运行(支持IE6+,Webkit,Firefox),也可一在服务端运行(借助Node.js).优点: 结构清晰,便于扩展.可以方便地屏蔽浏览器私有语法差异.这个不用多说,封装对浏览器语法差异的重复处理, 减少无意义的机械劳动. 可以轻松实现多重',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('571','2','语义化的理解?','3','2',NULL,'1、利于SEO,搜索引擎的爬虫依赖于标记来确定上下文和各个关键字的权重,页面是否对爬虫容易理解非常重要,因为爬虫很大程度上会忽略用于表现的标记,而只注重语义标记2、让页面的内容结构化,便于各种终端根据其自身的条件来合适地显示页面,虽然部分HTML标签存在默认样式,甚至浏览器都各有默认样式,这种表现虽然不是语义化HTML结构的有点,但同样是为了更好的表达HTML语义3、便于维护,方便阅读源码,去掉或样式丢失的时候能让页面呈现清晰的结构4、便于团队开发和维护,W3C给我们定了一个很好的标准,在团队中大家都遵循这个标准,可以减少很多差异化的东西,方便开发和维护,提高开发效率,甚至实现模块化开发',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('572','2','什么是响应式设计?','3','2',NULL,'网页制作的过程中让不同的设备有不同的尺寸和不同的功能.包括弹性网格和布局、图片、CSSmediaquery媒体查询的使用等.响应式网页设计就是一个网站能够兼容多个终端,而不必多次开发.',NULL,'1','1','1','6','2022-08-21 17:21:16','2022-08-21 17:21:16'),('573','2','TP框架的架构是怎么样的','3','5',NULL,'ThinkPHP的架构： 是 核心 + 行为 + 驱动，TP官方简称为：CBD核心（Core）：就是框架的核心代码，不可缺少的东西，TP本身是基于MVC思想开发的框架。行为（Behavior） ：行为在新版ThinkPHP的架构里面起着举足轻重的作用，在系统核心之上，设置了很多标签扩展位，而每个标签位置可以依次执行各自的独立行为。行为扩展就因此而诞生了，而且很多系统功能也是通过内置的行为扩展完成的，所有行为扩展都是可替换和增加的，由此形成了底层框架可组装的基础。驱动（ Driver ）：数据库驱动、缓存驱动、标签库驱动和模板引擎驱动，以及外置的类扩展。',NULL,'1','1','1','6','2023-05-26 10:22:16','2023-05-26 10:22:16'),('574','2','factory、service 和 provider 是什么关系','3','5',NULL,'从底层实现上来看，service 调用了 factory，返回其实例；factory 调用了 provider，返回其$get中定义的内容。factory 和 service 功能类似，只不过 factory 是普通 function，可以返回任何东西；service 是构造器，可以不返回（绑定到 this 的都可以被访问）；provider 是加强版 factory，返回一个可配置的 factory。',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('576','2','说说多线程？','3','2',NULL,'使用threading这个高级模块，启动一个线程就是把一个函数传入并创建Thread实例，然后调用start()开始执行多线程和多进程最大的不同在于，多进程中，同一个变量，各自有一份拷贝存在于每个进程中，互不影响，而多线程中，所有变量都由所有线程共享，所以，任何一个变量都可以被任何一个线程修改，因此，线程之间共享数据最大的危险在于多个线程同时改一个变量把内容给改乱了。锁的好处就是确保了某段关键代码只能由一个线程从头到尾完整地执行，坏处当然也很多首先是阻止了多线程并发执行，包含锁的某段代码实际上只能以单线程模式执行，效率就大大地下降了。其次，由于可以存在多个锁，不同的线程持有不同的锁，并试图获取对方持有的锁时，可能会造成死锁，导致多个线程全部挂起，既不能执行，也无法结束，只能靠操作系统强制终止。多线程编程，模型复杂，容易发生冲突，必须用锁加以隔离，同时，又要小心死锁的发生。Python解释器由于设计时有GIL全局锁，导致了多线程无法利用多核。多线程的并发在Python中就是一个美丽的梦。Python的线程虽然是真正的线程，但解释器执行代码时，有一个GIL锁：Global',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('577','2','Python线程和进程的区别？','3','2',NULL,'1)调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位。2)并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行。3）拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源.4）系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('578','2','函数参数的传递？def add（a，s_list=[]）:     s_list.append(a)         return s_list &','3','2',NULL,'[1],[1,2],[1,2,3]',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('579','2','Python关键字yield的用法？','3','3',NULL,'yield就是保存当前程序执行状态。你用for循环的时候，每次取一个元素的时候就会计算一次。用yield的函数叫generator，和iterator一样，它的好处是不用一次计算所有元素，而是用一次算一次，可以节省很多空间。generator每次计算需要上一次计算结果，所以用yield，否则一return，上次计算结果就没了。',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('580','2','这两个参数什么意思*args**kwargs，我们为什么要使用他们？','3','2',NULL,'缺省参数指在调用函数的时候没有传入参数的情况下，调用默认的参数，在调用函数的同时赋值时，所传入的参数会替代默认参数。*args是不定长参数，他可以表示输入参数是不确定的，可以是任意多个。**kwargs是关键字参数，赋值的时候是以键=值的方式，参数是可以任意多对在定义函数的时候不确定会有多少参数会传入时，就可以使用两个参数。',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('581','2','描述下SOAP的交互流程','3','3',NULL,'SOAP(简单对象访问协议)：SOAP是使用XML通过Internet发送信息和访问动态Web服务的友好界面。其主要作用在于确保信息通过互联网在业务应用之间传输的可靠性。作为一种用在分布式环境中交换结构化数据的协议，它包括三个部分：信封、报头(可选)和协议消息体。信封标记SOAP消息的开始与结束。它还可以规定在网络上数据的编码规则。SOAP报头可以包含发送给一个地址或多个地址的邮件、一个支付代码或有关RPC类型互动的信息。一个信封中可以有多个报头或完全没有报头。SOAP消息体传送自描述结构或RPC类型接口格式的数据。',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('582','2','如何在一个function里面设置一个全局的变量','3','1',NULL,'如果要给全局变量在一个函数里赋值，必须使用global语句。globalVarName的表达式会告诉Python，VarName是一个全局变量，这样Python就不会在局部命名空间里寻找这个变量',NULL,'1','1','1','6','2022-08-21 17:21:16','2022-08-21 17:21:16'),('583','2','Python的传参是传值还是传址','3','3',NULL,'Python的参数传递有：位置参数、默认参数、可变参数、关键字参数函数的传值到底是值传递还是引用传递，要分情况：不可变参数用值传递：像整数和字符串这样的不可变对象，是通过拷贝进行传递的，因为你无论如何都不可能在原处改变不可变对象可变参数是引用传递的：比如像列表，字典这样的对象是通过引用传递、和C语言里面的用指针传递数组很相似，可变对象能在函数内部改变',NULL,'1','1','1','6','2023-05-26 10:22:16','2023-05-26 10:22:16'),('584','2','用Pythonre模块匹配HTMLtag的时候，&lt;.*&gt;和&lt;.*?&gt;有什么区别','3','2',NULL,'&lt;.*&gt;这种匹配称作贪心匹配&lt;.*?&gt;称作非贪心匹配第一种写法是，尽可能多的匹配，就是匹配到的字符串尽量长，第二中写法是尽可能少的匹配，就是匹配到的字符串尽量短。比如&lt;tag&gt;tag&gt;tag&gt;end，第一个会匹配&lt;tag&gt;tag&gt;tag&gt;,第二个会匹配&lt;tag&gt;,如果要匹配到二个&gt;，就只能自己写',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('585','2','如何避免python中模块间的循环引用','3','3',NULL,'解决循环import的方法主要有几种。1.延迟导入(lazyimport)即把import语句写在方法或函数里面，将它的作用域限制在局部。这种方法的缺点就是会有性能问题。2.将fromxxximportyyy改成importxxx;xxx.yyy来访问的形式3.组织代码出现循环import的问题往往意味着代码的布局有问题。可以合并或者分离竞争资源。合并的话就是都写到一个文件里面去。分离的话就是把需要import的资源提取到一个第三方文件去。总之就是将循环变成单向。',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('586','2','简述HTTP缓存机制','3','3',NULL,'在客户端第一次请求数据时，此时缓存数据库中没有对应的缓存数据，需要请求服务器，服务器返回后，将数据存储至缓存数据库中。对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('587','2','说说你对TCPIP协议的理解','3','1',NULL,'TCP/IP（TransmissionControlProtocol/InternetProtocol）协议是传输层协议，主要解决数据如何在网络中传输。HTTP是应用层协议，主要解决如何包装数据。IP协议对应于网络层。',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('588','2','Python内存管理机制','3','5',NULL,'引用计数机制垃圾回收机制内存池机制',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('589','2','Python线程和进程的区别','3','2',NULL,'1)调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位。2)并发性：不仅进程之间可以并发执行，同一个进程的多个线程之间也可并发执行。3）拥有资源：进程是拥有资源的一个独立单位，线程不拥有系统资源，但可以访问隶属于进程的资源.4）系统开销：在创建或撤消进程时，由于系统都要为之分配和回收资源，导致系统的开销明显大于创建或撤消线程时的开销。',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('59','3','ArrayList 和HashSet 的区别,HastMap 和Hashtable 的区别?','3','3',NULL,'a) Set集合中的元素不能重复，arrayList是可以放入重复元素的 arrayList 效率较高b) Hashtable是线程安全的 速度慢 c) HashtMap是线程不安全安全的 速度快',NULL,'1','1','1','3','2023-05-25 13:27:14','2023-05-25 13:27:14'),('590','2','如何保证线程安全？','3','1',NULL,'通常加锁也有2种不同的粒度的锁：1.fine-grained(细粒度)，程序员需要自行加/解锁来保证线程安全2.coars',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('591','2','Python里面match()和search()的区别？','3','1',NULL,'re模块中match(pattern,string[,flags]),检查string的开头是否与pattern匹配。re模块中research(pattern,string[,flags]),在string搜索pattern的第一个匹配值。',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('592','2','一个包里有三个模块，mod1.py,mod2.py,mod3.py，但使用fromdemopackimport*导入模块时，如何保证只有mod1、mod3被导入了','3','2',NULL,'增加__init__.py文件，并在文件中增加：__all__=[&#39;mod1&#39;,&#39;mod3&#39;]',NULL,'1','1','1','6','2022-08-21 17:21:16','2022-08-21 17:21:16'),('593','2','__new__和__init__的区别？','3','2',NULL,'__new__是一个静态方法,而__init__是一个实例方法.__new__方法会返回一个创建的实例, 而__init__什么都不返回.只有在__new__返回一个cls的实例时后面的__init__才能被调用.当创建一个新实例时调用__new__,初始化一个实例时用__init__',NULL,'1','1','1','6','2023-05-26 10:22:16','2023-05-26 10:22:16'),('594','2','print(dir(&lsquo;a&rsquo;))输出的是什么？','3','2',NULL,'会打印出字符型的所有的内置方法[&#39;__add__&#39;,&#39;__cla_&#39;,&#39;__contains__&#39;,&#39;__delattr__&#39;,&#39;__doc__&#39;,&#39;__eq__&#39;,&#39;__format__&#39;,&#39;__ge__&#39;,&#39;__getattribute__&#39;,&#39;__getitem__&#39;,&#39;__getnewargs__&#39;,&#39;__getslice__&#39;,&#39;__gt__&#39;,&#39;__hash__&#39;,&#39;__init__&#39;,&#39;__le__&#39;,&#39;__len__&#39;,&#39;__lt__&#39;,&#39;__mod__&',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('595','2','如何在一个多级目录下,找出所有包含有&rsquo;abc&rsquo;字符的文件','3','1',NULL,'grep&lsquo;abc&rsquo;./*',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('596','2','如何抓取ping包','3','4',NULL,'tcpdump-ieth0-nn&#39;icmp&#39;ping命令使用的是icmp协议',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('597','2','假设a=(1,2,3)改变a的值变为(3,2,3)','3','1',NULL,'a = tuple([3] + list(a[1:]))',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('598','2','域名和IP之间有什么关系，如何查看某个域名对应的所有IP？','3','3',NULL,'输入域名----域名解析服务器（dns）解析成ip地址---访问IP地址---完成访问的内容---返回信息国际互联网(Internet)上有成千百万台主机（host），为了区分这些主机，人们给每台主机都分配了一个专门的&ldquo;地址&rdquo;作为标识，称为IP地址由于IP地址全是些的数字，为了便于用户记忆，Internet上引进了域名服务系统DNS（DomainNameSystem）。当您键入某个域名的时候，这个信息首先到达提供此域名解析的服务器上，再将此域名解析为相应网站的IP地址。完成这一任务的过程就称为域名解析。1.ping2.nslookup3.使用站长工具等',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('599','2','Python的内存管理机制','3','4',NULL,'1.引用计数：通过引用计数来保持对内存中的变量跟踪，Python内部记录中所有在使用对象各有多少个引用。Python中有个内部跟踪变量叫做引用计数器，每个变量有多少个引用，简称引用计数。当对象被创建时就创建了一个引用计数。当某个对象的引用计数为0时，对象就不在需要，就列入了垃圾回收队列。引用计数增加：1.对象被创建：x=4;2.另外的别人被创建：y=x;3.被作为参数传递给函数：foo(x);4.作为容器对象的一个元素：a=[1,x,&#39;33&#39;];引用计数减少时：1.一个本地引用离开了它的作用域。比如上面的foo(x)函数结束时，x指向的对象引用减1;2.对象的别名被显式的销毁：delx；或者dely;3.对象的一个别名被赋值给其他对象：x=7894.对象从一个窗口对象中移除：myList.remove(x)5.窗口对象本身被销毁delmyList，或者窗口对象本身离开了作用域。2.垃圾回收1.引用计数：每个对象中都有ob-refcnt来做引用计数。当一个对象...,ob-refcnt就会增加，当引用的对象删除，那么ob-refc',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('6','1','关于递归的描述正确的是?（）','2','2',NULL,'',NULL,'1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('60','3','Redis数据库结构有那些?','3','1',NULL,'String(字符串)，Hash(哈希)，List(列表)，Set(集合)及zset(sortedset:有序集合',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('600','2','分别阐述三种引号用的场景与区别','3','2',NULL,'单引号，双引号，三引号都可以表示字符串，双引号可以和单引号嵌套使用，三引号一般表示多行字符串或者注释，三引号可以嵌套双引号和单引号',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('601','2','sockets（套接字）编程有三种，哪三种？','3','3',NULL,'套接字有三种类型:流式套接字(SOCK_STREAM),数据报套接字(SOCK_DGRAM)及原始套接字。',NULL,'1','1','1','6','2023-02-25 16:21:16','2023-02-25 16:21:16'),('602','2','python多线程','3','2',NULL,'这个问题被问的概率相当之大，其实多线程，多进程，在实际开发中用到的很少，除非是那些对项目性能要求特别高的，有的开发工作几年了，也确实没用过，你可以这么回答，给他扯扯什么是进程，线程(cpython中是伪多线程)的概念就行，实在不行你就说你之前写过下载文件时，用过多线程技术，或者业余时间用过多线程写爬虫，提升效率。进程:一个运行的程序(代码)就是一个进程，没有运行的代码叫程序，进程是系统资源分配的最小单位，进程拥有自己独立的内存空间，所以进程间数据不共享，开销大。',NULL,'1','1','1','6','2022-08-21 17:21:16','2022-08-21 17:21:16'),('603','2','python多线程与多进程的区别','3','2',NULL,'进程:一个运行的程序(代码)就是一个进程，没有运行的代码叫程序，进程是系统资源分配的最小单位，进程拥有自己独立的内存空间，所以进程间数据不共享，开销大。线程:调度执行的最小单位，也叫执行路径，不能独立存在，依赖进程存在一个进程至少有一个线程，叫主线程，而多个线程共享内存(数据共享，共享全局变量)，从而极大地提高了程序的运行效率',NULL,'1','1','1','6','2023-05-26 10:22:16','2023-05-26 10:22:16'),('604','2','进程间的数据共享和线程间的数据共享','3','2',NULL,'进程间数据共享:多进程中，每个进程都是独立的，各自持有一份数据，无法共享。本篇文章介绍三种用于进程数据共享的方法Queue:1.frommultiprocessingimportqueues2.importmultiprocessing34.deffunc(i,q):5.q.put(i)6.print(&quot;---&gt;&quot;,i,q.qsize())7.8.9.q=queues.Queue(9,ctx=multiprocessing)10.foriinrange(5):<br ',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('605','2','列举几项python2和3的区别？','3','3',NULL,'&gt;1.print不再是语句，而是函数，比如原来是print&#39;abc&#39;现在是print(&#39;abc&#39;)但是python2.6+可以使用from__future__importprint_function来实现相同功能&gt;2.在Python3中，没有旧式类，只有新式类，也就是说不用再像这样classFoobar(object):pass显式地子类化object但是最好还是加上.主要区别在于old-style是classtype类型而new-style是type类型&gt;3.原来1/2（两个整数相除）结果是0，现在是0.5了<b',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('606','2','什么是闭包？','3','1',NULL,'在函数内部再定义一个函数，并且这个函数用到了外边函数的变量，那么将这个函数以及用到的一些变量称之为闭包',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('607','2','python的内存管理机制？','3','2',NULL,'采用引用计数为主，标记清除、分代回收机制为辅',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('608','2','同步异步阻塞非阻塞的了解具体说说？','3','2',NULL,'异步：某个事情需要10s完成。而我只需要调用某个函数告诉xxx来帮我做（然后我再干其他的事情）同步：某个事情需要10s完成，我需要一直等它完成（等10s），再能继续后面的工作。阻塞：做某件事情，直到完成，除非超时非阻塞：尝试做，如果不能做，就不做（直接返回），如果能做，就做。',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('609','2','用一行代码python 写出1+2+3+4+&hellip;&hellip;10348？','3','2',NULL,'print(sum(range(1,10349)))',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('61','3','redis用途','3','1',NULL,'Redis用到的地方很多，如我们最熟悉的分布式爬虫，Set去重等',NULL,'1','1','1','3','2023-05-25 13:27:14','2023-05-25 13:27:14'),('610','2','使用装饰器实现单例模式？','3','3',NULL,'class fun_1(object):  def __init__(self, cls):    self._cls = cls    self._instances = None;  def __call__(self, *args):    if not self._instances:      self._instances = self._cls(*args)    return self._instances@fun_1class fun_2(object):  def _',NULL,'1','1','1','6','2023-03-25 11:22:14','2023-03-25 11:22:14'),('611','2','简单谈谈**args和**kwargs的理解','3','2',NULL,'两者都是不定长参数*args 是不定长位置参数，他可以表示输入参数是不确定的，可以是任意多个，args变量实则是一个元组。**kwargs 是不定长关键字参数，赋值的时候是以键 = 值的方式，参数是可以任意多对在定义函数的时候不确定会有多少参数会传入时，就可以使用两个参数，kwargs变量实则是一个字典。',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('612','2','Python进程间通信，除了socket方式，还有哪些方式可以实现通讯？','3','3',NULL,'（1）管道（Pipe）：管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用，允许一个进程和另一个与它有共同祖先的进程之间进行通信。（2）命名管道（namedpipe）：也是半双工的通信方式，除具有管道所具有的功能外，它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。（3）信号（Signal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生。是Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制。（4）消息（Message）队列：消息队列是消息的链接表，包括Posix消息队列systemV消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式',NULL,'1','1','1','6','2022-08-21 17:21:16','2022-08-21 17:21:16'),('613','2','如何快速实现列表的去重？','3','1',NULL,'最快速的方法是使用set函数转换为集合',NULL,'1','1','1','6','2023-05-26 10:22:16','2023-05-26 10:22:16'),('614','2','简单对比一下list、tuple、set和dict的区别？','3','2',NULL,'1.list、tuple是有序列表；dict、set是无序列表2.list元素可变、tuple元素不可变3.dict和set的key值不可变，唯一性4.set只有key没有value5.set的用途：去重、并集、交集等6.list、tuple：+、*、索引、切片、检查成员等7.dict查询效率高，但是消耗内存多；list、tuple查询效率低、但是消耗内存少',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('615','2','请简要对比Python3中str和byte的区别','3','1',NULL,'python3中最重要的新特性可能就是将文本(text)和二进制数据做了更清晰的区分。文本总是用unicode进行编码，以str类型表示；而二进制数据以bytes类型表示。strings可以被编码(encode)成字bytes, bytes也可以解码(decode)成strings：',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('616','2','简单谈谈HTTP响应状态码及使用？','3','2',NULL,'通过状态码告诉客户端服务器的执行状态，以判断下一步该执行什么操作。常见的状态机器码有：100-199：表示服务器成功接收部分请求，要求客户端继续提交其余请求才能完成整个处理过程。200-299：表示服务器成功接收请求并已完成处理过程，常用 200（OK 请求成功）。300-399：为完成请求，客户需要进一步细化请求。302（所有请求页面已经临时转移到新的 url）。304、307（使用缓存资源）。400-499：客户端请求有错误，常用 404（服务器无法找到被请求页面），403（服务器拒绝访问，权限不够）。500-599：服务器端出现错误，常用 500（请求未完成，服务器遇到不可预知的情况）。',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('617','2','简单谈谈django和flask的区别？','3','2',NULL,'flask比较轻量级，Django是重量级简单的比喻就是：flask是一个可以修饰的毛坯房自己自主的搭配，提供核心的东西，django 是一个已经成型得房子修改性小，在某些方面Django使用起来灵活性差，显得比较笨重。django中除了web框架，自带ORM和模板引擎，自带的数据库管理app，第三方库最丰富，模块化是集成在命令里的，Django的配置主要还是靠settings.py来做Flask通过Blueprint来提供模块化，Flask的配置很灵活，有多种方法配置，不同环境的配置也非常方便。',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('618','2','列举一下python常用的标准库？','3','3',NULL,'os sys re math random unittest（测试） datatime',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('619','2','简单谈谈对迭代器与生成器的理解？','3','2',NULL,'说这个问题我们首先来谈一下for循环遍历对象的本质for循环来遍历列表等容器对象时，先对容器对象调用iter()函数。iter()是python的内置函数iter()函数会返回一个定义了next()方法的迭代器对象，它在容器中逐个访问容器中的元素。next()也是python的内置函数。没有后续元素时，next()会抛出StopIteration异常，此时for循环结束。接下来我们再来说迭代器（Iterator）迭代器用来帮助我们记录每次迭代访问到的位置。当对迭代器使用next()函数的时候，迭代器会返回它所记录位置的下一个位置的数据。实际上，使用next()函数的时候，调用的是迭代器的__next__方法。所以一个迭代器必须有__next__方法。但是这还不够，python本身要求迭代器本身也必须是可迭代的。因此迭代器还必须有一个__iter__方法，这给__iter__方法就是让for循环遍历时使用的，又因为__iter__方法要返回一个迭代器，所',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('62','3','线程同步的关键字是什么?sleep0 和waito 有什么区别?怎么唤wait()停的线程?','3','3',NULL,'关键字 synchronizedb) sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。c) 唤醒：notify() 唤醒在此同步监视器上等待的单个线程',NULL,'1','1','1','6','2022-08-21 17:21:16','2022-08-21 17:21:16'),('620','2','谈谈对ajax的理解','3','3',NULL,'ajax可以实现局部刷新，也叫做无刷新，无刷新指的是整个页面不刷新，只是局部刷新，ajax可以自己发送http请求，不用通过浏览器的地址栏，所以页面整体不会刷新，ajax获取到后台数据，更新页面显示数据的部分，就做到了页面局部刷新。',NULL,'1','1','1','6','2022-08-21 17:21:16','2022-08-21 17:21:16'),('621','2','Redis的数据类型有哪些？','3','1',NULL,'string、list、set、zset、hash',NULL,'1','1','1','6','2022-08-21 17:21:16','2022-08-21 17:21:16'),('622','2','Python正则表达式中贪婪与非贪婪的区别','3','2',NULL,'&lt;.*&gt;是贪婪匹配，会从第一个&ldquo;&lt;&rdquo;开始匹配，直到最后一个&ldquo;&gt;&rdquo;中间所有的字符都会匹配到，中间可能会包含&ldquo;&gt;&rdquo;。&lt;.*?&gt;是非贪婪匹配，从第一个&ldquo;&lt;&rdquo;开始往后，遇到第一个&ldquo;&gt;&rdquo;结束匹配，这中间的字符串都会匹配到，但是不会有&ldquo;&gt;&rdquo;。',NULL,'1','1','1','6','2022-08-21 17:21:16','2022-08-21 17:21:16'),('623','2','常见的linux命令（不含参数）','3','1',NULL,'cd 切换路径 pwd 显示当前位置 who 显示当前登录的账号rm 删除 ls 显示当前路径下的所有文件chmod 修改权限cat 查看文件内容tar 打包/压缩ps 查看进程',NULL,'1','1','1','6','2023-05-26 10:22:16','2023-05-26 10:22:16'),('624','2','Python中如何使用正则匹配所有标点符号？','3','1',NULL,'/W 理由：因为小写/w匹配所有的字母和数字',NULL,'1','1','1','6','2022-08-21 17:21:16','2022-08-21 17:21:16'),('625','2','简单谈谈多线程、多进程、协程以及锁的运用？','3','3',NULL,'多线程的优点：1. 创建进程的空间和时间开销要大于线程，进程之间有着不同的地址空间，而同一进程里的多线程则使用同一地址空间，共享该进程里的堆、数据资源；2. 方便高效的通信方式：线程间共享内存，通信方便，而进程通信需使用IPC；3. 较轻的切换开销 ：不用切换地址空间，不用更改CR3寄存器，不用刷新TLB多进程的优点：1. 一个进程crash不会导致整个系统崩溃2. python中多进程能使用起多核协程：1. 协程又被为微线程，拥有线程的大部分优点2. 相比于线程最主要的优点是协程的切换效率更高，不用惊动CPU，而是交由应用程序自己调度切换多线程和协程适合IO密集型应用程序；多进程适合计算密集型任务多线程中由于共享资源问题，如果出现资源竞争那么就需要锁来进行限制；同理多进程中，如果出现多进程间共享资源竞争等问',NULL,'1','1','1','6','2022-08-21 17:21:16','2022-08-21 17:21:16'),('626','2','简要谈谈你对进程、线程、协程的理解 ？','3','2',NULL,'进程和线程其实都是CPU工作时间段的描述，不过是颗粒大小不同进程就是包换上下文切换的程序执行时间总和=CPU加载上下文+CPU执行+CPU保存上下文线程直接共享上下文，不用考虑加载的问题所以说进程在执行过程中拥有独立的内存资源，而多个线程共享内存同一份内存资源；进程间切换代价大，线程间切换代价小同时一个程序至少有一个进程,一个进程至少有一个线程；协程又称为微线程，因为其很多特征和线程几乎一样，只是线程的调度切换完全交由操作系统/CPU来做，而协程之间的切换完全基于用户来管理。通常多进程单指多个进程，多线程指单进程中多个线程、协程也指的单线程中的协程；但也有可能使用多进程+多线程；多进程+协程；多线程+协程的方式设计程序，此时就要考虑他们之间哪些资源是共享的、哪些的调度需要用户来管理的。',NULL,'1','1','1','6','2022-08-21 17:21:16','2022-08-21 17:21:16'),('627','2','Unix/Linux系统上，如何查看进程或杀死进程？','3','1',NULL,'查看某进程：ps -aux |grep 进程名字 杀死某进程：kill -9 进程id  注意： -9 代表信号 kill -l 查看更多信号类型        ',NULL,'1','1','1','6','2022-08-21 17:21:16','2022-08-21 17:21:16'),('628','2','Django项目中密码的加密方式是怎样的？','3','3',NULL,'使用的是django自带的用户认证系统，用的是sha256加密、对称加密、非对称机密、不可逆加密',NULL,'1','1','1','6','2022-08-21 17:21:16','2022-08-21 17:21:16'),('629','2','简要谈谈python的内存回收机制？','3','3',NULL,'内存管理机制：引用计数、垃圾回收、内存池。引用计数：引用计数是一种非常高效的内存管理手段， 当一个 Python 对象被引用时其引用计数增加1， 当其不再被一个变量引用时则计数减 1. 当引用计数等于0时对象被删除。垃圾回收 ：1. 引用计数引用计数也是一种垃圾收集机制，而且也是一种最直观，最简单的垃圾收集技术。当 Python 的某个对象的引用计数降为 0 时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾了。比如某个新建对象，它被分配给某个引用，对象的引用计数变为 1。如果引用被删除，对象的引用计数为 0，那么该对象就可以被垃圾回收。不过如果出现循环引用的话，引用计数机制就不再起有效的作用了2. 标记清除如果两个对象的引用计数都为 1，但是仅仅存在他们之间的循环引用，那么这两个对象都是需要被回收的，也就是说，它们的引用计数虽然表现为非 0，但实际上有效的引用计数为 0。所以先将循环引用摘掉，就会得出这两个对象的有效计数。3. 分代回收<br ',NULL,'1','1','1','6','2022-08-21 17:21:16','2022-08-21 17:21:16'),('63','3','MonggoDB中存入了100万条数据，如何提高查询速度?','3','2',NULL,'索引在很多数据库中是提高性能的标志优化手段，所以在大数据量的情况下索引可以提高数据的查询速度，如果没有索引MongoDB会扫描全部数据，才能获取满足条件的内容，在关系数据库中可以使用强制索引方式查询数据库，确保更准确快速的查询到满足条件的数据。语法:1、ensureIndex()基本语法1创建升序索引-1创建降序索引2、mongodb默认所以字段_id,创建文档，会自动创建，此索引不能删除由mongodb自己维护1、unique创建唯一索引，默认false，true必须唯一索引，否则报错实例:1、创建升序索引db.user.ensureIndex({age:1});db.user.find({age:{$gte:20}});',NULL,'1','1','1','3','2023-05-26 10:22:16','2023-05-26 10:22:16'),('630','2','谈谈你对lambda函数的理解','3','2',NULL,'lambda 函数俗称匿名函数，是一个可以接收任意多个参数(包括可选参数)并且返回单个表达式值的函数1、lambda 函数比较轻便，即用即仍，很适合需要完成一项功能，通常只在该函数只会被使用一次的场景下使用；2、匿名函数内部只能写一句表达式，并以此表达式的计算结果作为返回值3、任何使用函数的场景理论上都是可以使用匿名函数的，但是要注意第二条',NULL,'1','1','1','6','2023-05-26 10:22:16','2023-05-26 10:22:16'),('631','2','谈谈你对装饰器的理解','3','2',NULL,'装饰器本质上是一个Python函数，它可以在让其他函数在不需要做任何代码的变动的前提下增加额外的功能。 装饰器的返回值也是一个函数的对象，它经常用于有切面需求的场景。 比如：插入日志、性能测试、事务处理、缓存、权限的校验等场景。有了装饰器就可以抽离出大量的逻辑相似代码，并进行复用，实现解耦，从而便于代码编写和维护。',NULL,'1','1','1','6','2023-05-26 10:22:16','2023-05-26 10:22:16'),('632','2','如何在一个function里面设置一个全局的变量','3','1',NULL,'如果要给全局变量在一个函数里赋值，必须使用global语句。globalVarName的表达式会告诉Python，VarName是一个全局变量，这样Python就不会在局部命名空间里寻找这个变量',NULL,'1','1','1','6','2023-05-26 10:22:16','2023-05-26 10:22:16'),('633','2','写出冒泡排序的实现','3','1',NULL,'<pre><code class=\"language-java\">void bubble_sort(int arr[], int len) {      int i, j;      for (i = 0; i &lt; len - 1; i++)    //外层循环控制趟数，总趟数为len-1        for (j = 0; j &lt; len - 1 - i; j++)  //内层循环为当前i趟数 所需要比较的次数            if (arr[j] &gt; arr[j + 1])                  swap(arr[j], arr[j + 1]);          } </code></pre>',NULL,'1','1','1','6','2023-05-26 10:22:16','2023-05-26 10:22:16'),('634','3','test33333','2','3',NULL,'111','','1','0','0',NULL,'2023-05-26 10:22:16','2023-05-26 10:22:16'),('635','3','test33333','2','3',NULL,'111','','0','0','0','2','2023-05-26 10:22:16','2023-05-26 10:22:16'),('638','3','test33333','2','3',NULL,'111','','0','0','0','2','2023-05-26 10:22:16','2023-05-26 10:22:16'),('639','3','test33333','2','3',NULL,'111','','0','0','0','2','2023-05-26 10:22:16','2023-05-26 10:22:16'),('64','3','如何提高并发性能?','3','4',NULL,'1.动态页面静态化。2.制作数据库散列表，即分库分表。3.增加缓存。4.增加镜像。5.部署集群。6.负载均衡。7.异步读取，异步编程。8.创建线程池和自定义连接池，将数据持久化。9.把一件事，拆成若干件小事，启用线程，为每个线程分配一定的事做，多个线程同时进行把该事件搞定再合并。',NULL,'1','1','1','3','2023-05-25 13:27:14','2023-05-25 13:27:14'),('640','2','test','1','2',NULL,'','','0','0','0','1','2023-05-25 13:27:14','2023-05-25 13:27:14'),('641','3','test33333','2','3',NULL,'111','','0','0','0','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('642','1','谈谈你对Lambda表达式的理解','2','3',NULL,'从函数式接口和lambda表达式特征入手','','1','1','0','2','2022-08-21 17:21:16','2023-06-02 16:29:24'),('643','1','a','3','1',NULL,'a','a','0','0','0','1','2023-05-26 10:22:16','2023-05-26 10:22:16'),('644','2','bb','2','2',NULL,'b','b','0','0','0','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('645','5','cccc','2','2',NULL,'cccc','cccc','1','0','0','3','2023-05-25 13:27:14','2023-05-25 13:27:14'),('646','4','c222222','2','2',NULL,'cccc','cccc','0','0','0','3','2023-05-25 13:27:14','2023-05-25 13:27:14'),('647','2','','3','1',NULL,'','','0','0','0','1','2023-05-25 13:27:14','2023-05-25 13:27:14'),('648','6','','1','1',NULL,'','aaa','0','0','0','3','2023-05-25 13:27:14','2023-05-25 13:27:14'),('649','1','','1','1',NULL,'','','0','0','0','1','2023-05-25 13:27:14','2023-05-25 13:27:14'),('65','4','枚举类Enumeration和iterator的区别','3','3',NULL,'①java中的集合类都提供了返回Iterator的方法，就是迭代器，它和Enumeration的主要区别其实就是Iterator可以删除元素，但是Enumration却不能。②还有一点要注意的就是，使用Iterator来遍历集合时，应使用Iterator的remove()方法来删除集合中的元素，使用集合的remove()方法将抛出ConncurrentModificationException异常。③Enumeration 与 iterator 都是迭代输出的方法，Enumeration先进后出，iterator先进先出',NULL,'1','1','1','4','2023-05-25 13:27:14','2023-05-25 13:27:14'),('650','1','','1','1',NULL,'','图片单选','0','0','0','1','2023-05-25 13:27:14','2023-05-25 13:27:14'),('651','1','','1','1',NULL,'','图片单选','0','0','0','1','2023-05-25 13:27:14','2023-05-25 13:27:14'),('652','1','','1','1',NULL,'','sss','0','0','0','1','2022-08-21 17:21:16','2022-08-21 17:21:16'),('653','1','','3','1',NULL,'','sss','0','0','0','1','2023-05-26 10:22:16','2023-05-26 10:22:16'),('654','1','图片选择','1','1',NULL,'图片选择','图片选择','0','0','0','1','2023-05-25 13:27:14','2023-05-25 13:27:14'),('655','2','xxx','1','1',NULL,'xxx','xxx','0','0','0','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('656','2','图片2','1','1',NULL,'图片2','图片2','0','0','0','1','2023-05-25 13:27:14','2023-05-25 13:27:14'),('657','2','aaa','1','1',NULL,'c','c','0','0','0','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('658','2','bbbb','1','1',NULL,'abcd','abcd','0','0','0','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('659','1','bbbbb','2','1',NULL,'bbbb','bbbb','0','0','0','1','2023-05-25 13:27:14','2023-05-25 13:27:14'),('66','4','谈谈你对Django框架的认识？','3','3',NULL,'Django太重了，除了web框架，自带ORM和模板引擎，灵活和自由度不够高;Django能开发小应用，但总会有&ldquo;杀鸡焉用牛刀&rdquo;的感觉;Django的自带ORM非常优秀，综合评价略高于SQLAlchemy;Django自带的模板引擎简单好用，但其强大程度和综合评价略低于Jinja;Django自带ORM也使Django与关系型数据库耦合度过高，如果想使用MongoDB等NoSQL数据，需要选取合适的第三方库，且总感觉Django+SQL才是天生一对的搭配，Django+NoSQL砍掉了Django的半壁江山;Django目前支持Jinja等',NULL,'1','1','1','4','2023-05-25 13:27:14','2023-05-25 13:27:14'),('660','1','dddd','2','1',NULL,'abceeeee','badd','1','0','0','1','2023-05-25 13:27:14','2023-05-25 13:27:14'),('661','1','新的多选多选','2','1',NULL,'新的多选多选','新的多选多选','1','0','0','1','2023-05-25 13:27:14','2023-05-25 13:27:14'),('662','2','图片选择','1','1',NULL,'图片选择','图片选择','1','0','0','2','2022-08-21 17:21:16','2022-08-21 17:21:16'),('663','1','11','1','1',NULL,'aa','aa','0','0','0','1','2023-05-26 10:22:16','2023-05-26 10:22:16'),('664','1','111xxxx','1','1',NULL,'aa','aa','0','0','0','1','2023-05-25 13:27:14','2023-05-25 13:27:14'),('665','1','22222xxxxxx','2','2',NULL,'aa','aa','0','0','0','1','2023-05-25 13:27:14','2023-05-25 13:27:14'),('666','5','111xxxx','2','2',NULL,'aa','aa','0','0','0','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('667','5','aa','1','1',NULL,'aa','aa','1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('668','1','aaa','2','1',NULL,'a','a','1','1','1','2','2023-05-25 13:27:14','2023-05-25 13:27:14'),('669','1','aaa','3','1',NULL,'aaa','aaa','1','1','1','1','2023-05-25 13:27:14','2023-05-25 13:27:14'),('67','4','如何准确判断一个变量是数组类型','3','1',NULL,'.typeof操作符这种方法对于一些常用的类型来说那算是毫无压力，比如Function、String、Number、Undefined等，但是要是检测Array的对象就不起作用了。代码如下:alert(typeofnull);//&quot;object&quot;alert(typeoffunction(){return1;});//&quot;function&quot;alert(typeof&#39;梦龙小站&#39;);//&quot;string&quot;alert(typeof1);//&quot;number&quot;alert(typeof&nb',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('670','5','ss','2','1',NULL,'dd','dd','0','0','0','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('68','5','flask框架和Django框架的区别','3','3',NULL,'Flask确实很&ldquo;轻&rdquo;，不愧是MicroFramework，从Django转向Flask的开发者一定会如此感慨，除非二者均为深入使用过;Flask自由、灵活，可扩展性强，第三方库的选择面广，开发时可以结合自己最喜欢用的轮子，也能结合最流行最强大的Python库;入门简单，即便没有多少web开发经验，也能很快做出网站;非常适用于小型网站;非常适用于开发web服务的API;开发大型网站无压力，但代码架构需要自己设计，开发成本取决于开发者的能力和经验;各方面性能均等于或优于Django;Django自带的或第三方的好评如潮的功能，Flask&nb',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('69','5','有一个无序数组，如何获取第K大的数，说下思路，实现后的时间复杂度?','3','5',NULL,'根据自己熟悉的算法说下思路，如:快排、二分法。',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('7','1','下面关于线程创建的定义不正确的有（）','2','3',NULL,'',NULL,'1','1','1','1','2023-05-25 13:27:14','2023-05-25 13:27:14'),('70','5','归并排序的时间复杂度?','3','5',NULL,'合并排序是比较复杂的排序，特别是对于不了解分治法基本思想的同学来说可能难以理解。总时间=分解时间+解决问题时间+合并时间。分解时间就是把一个待排序序列分解成两序列，时间为一常数，时间复杂度o(1).解决问题时间是两个递归式，把一个规模为n的问题分成两个规模分别为n/2的子问题，时间为2T(n/2).合并时间复杂度为o(n)。总时间T(n)=2T(n/2)+o(n).这个递归式可以用递归树来解，其解是o(nlogn).此外在最坏、最佳、平均情况下归并排序时间复杂度均为o(nlogn).从合并过程中可以看出合并排序稳定。用递归树的方法解递归式T(n)=2T(n/2)+o(n):假设解决最后的子问题用时为常数c，则对于n个待排序记录来说整个问题的规模为cn。从这个递归树可以看出，第一层时间代价为cn，第二层',NULL,'1','1','1','5','2023-05-25 13:27:14','2023-05-25 13:27:14'),('71','6','如何理解反射','3','5',NULL,'①Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制②反射的作用是可以获取一个运行状态下的类里面所有信息（类的实例，构造，方法，属性等）③反射的应用场景：框架的配置文件都是通过反射来生成对象的，还有动态代理的底层就是反射实现的.',NULL,'1','1','1','6','2023-05-25 13:27:14','2023-05-25 13:27:14'),('72','6','Array和ArrayList区别','3','3',NULL,'同构的对象是指类型相同的对象，若声明为int[]的数组就只能存放整形数据,string[]只能存放字符型数据,但声明为object[]的数组除外。而ArrayList可以存放任何不同类型的数据（因为它里面存放的都是被装箱了的Object型对象，实际上ArrayList内部就是使用&quot;object[] _items;&quot;这样一个私有字段来封装对象的）3 在CLR托管对中的存放方式Array是始终是连续存放的，而ArrayList的存放不一定连续。4 初始化大小Array对象的初始化必须只定指定大小，且创建后的数组大小是固定的，',NULL,'1','1','1','6','2022-08-21 17:21:16','2022-08-21 17:21:16'),('73','6','什么是xml','3','3',NULL,'①可扩展标记语言，标准通用标记语言的子集，是一种用于标记电子文件使其具有结构性的标记语言②用途：开发中用来传递数据，共享数据的。Webservice也用xml来传递数据。③扩展，json和xml的区别：http://www.cnblogs.com/SanMaoSpace/p/3139186.html',NULL,'1','1','1','6','2023-05-26 10:22:16','2023-05-26 10:22:16'),('74','7','xml的解析方式','3','3',NULL,'xml的解析方式有多种，我们课内学了dom和sax解析，以及第三方dom4j,除了这几种以外Android有自己的独特解析方式pull解析，接下来再讲解一下这几种解析方式的不同。DOM方式&bull; 原理：基于文档驱动，是先把dom全部文件读入到内存中，构建一个主流内存的树结构，然后使用DOM的API遍历所有数据，调用API检索想要的数据和操作数据。所以，DOM方式的优缺点是：&bull; 特点：优点：整个文档树存在内存中，可对XML文档进行操作：删除、修改等等；可多次访问已解析的文档；由于在内存中以树形结构存放，因此检索和更新效率会更高。；缺点：解析 XML 文件时会将整个 XML 文件的内容解析成树型结构存放在内存中并创建新对象，比较消耗时间和内存；&bull; 使用情境对于像手机这样的移动设备来讲，内存是非常有限的，在XML文档比较小、需要对解析文档进行一定的操作且一旦解析了文档需要多次访问这些数据的情况下可以考虑使用DOM方式，因为其检索和解析',NULL,'1','1','1','7','2023-05-25 13:27:14','2023-05-25 13:27:14'),('75','7','Java中sleep和wait的区别','3','3',NULL,'sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。',NULL,'1','1','1','7','2023-05-25 13:27:14','2023-05-25 13:27:14'),('76','7','我们能将int 强制转换为byte 类型的变量吗? 如果该变量大于byte 类型的范围消会出现什么现象？','3','2',NULL,'a) 可以强制转换 超出范围会溢出',NULL,'1','1','1','1','2023-05-25 13:27:14','2023-05-25 13:27:14'),('77','1','二叉树','3','1',NULL,'二叉树主要需要掌握遍历，先序、中序、后序',NULL,'1','1','1','1','2023-05-25 13:27:14','2023-05-25 13:27:14'),('78','2','a=a+b 与a+=b 的区别?','3','2',NULL,'+= 结合了强制类型转换的功能 a+=b;执行的时候效率高',NULL,'1','1','1','1','2023-05-25 13:27:14','2023-05-25 13:27:14'),('79','2','抽象类和接口的区别','3','1',NULL,'1、抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。2、抽象类要被子类继承，接口要被类实现。3、接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现4、接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。5、抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。6、抽象方法只能申明，不能实现，接口是设计的结果 ，抽象类是重构的结果7、抽象类里可以没有抽象方法8、如果一个类里有抽象方法，那么这个类只能是抽象类 9、抽象方法要被实现，所以不能是静态的，也不能是私有的。10、接口可继承接口，并可多继承接口，但类只能单根继承。',NULL,'1','1','1','1','2023-05-25 13:27:14','2023-05-25 13:27:14'),('8','1','数据库连表查询？','3','3',NULL,'内连接：innerjoinon；2.左连接：leftjoinon；3.右连接：rightjoinon;',NULL,'1','1','1','1','2023-05-25 13:27:14','2023-05-25 13:27:14'),('80','3','Arraylist如何扩容？ArrayList和LinkedList的区别，结合说原理说？','3','1',NULL,'当数组容量满时数组会自动一当前数组容量的2倍扩容，1.ArrayList是实现了基于动态数组的数据结构，LinkedList基于链表的数据结构。2.对于随机访问get和set，ArrayList觉得优于LinkedList，因为LinkedList要移动指针。3.对于新增和删除操作add和remove，LinedList比较占优势，因为ArrayList要移动数据。',NULL,'1','1','1','1','2023-05-25 13:27:14','2023-05-25 13:27:14'),('82','3','mysql和mongodb的区别','3','4',NULL,'一、1、基于分布式文件存储2、高负载情况下添加更多节点，可以保证服务器性能3、将数据存储为一个文档二、比较1、稳定性2、索引，索引放在内存中，能够提升随机读写的性能。如果索引不能完全放在内存，一旦出现随机读写比较高的时候，就会频繁地进行磁盘交换，MongoDB的性能就会急剧下降3、占用的空间很大，因为它属于典型空间换时间原则的类型。那么它的磁盘空间比普通数据库会浪费一些，而且到目前为止它还没有实现在线压缩功能，在MongoDB中频繁的进行数据增删改时，如果记录变了，例如数据大小发生了变化，这时候容易产生一些数据碎片，出现碎片引发的结果，一个是索引会出现性能问题，另外一个就是在一定的时间后，所占空间会莫明其妙地增大，所以要定期把数据库做修复，定期重新做索引，这样会提升MongoDB的稳定性和效率。在最新的版本里，它已经在实现在线压缩，估计应该在2.0版左右，应该能够实现在线压缩，可以在后台执行现在repair',NULL,'1','1','1','1','2022-08-21 17:21:16','2022-08-21 17:21:16'),('83','1','我能在不进行强制转换的情况下将一个double 值赋值给long类型的变量吗?','3','2',NULL,'a) 不能 double范围比long的范围大',NULL,'1','1','1','1','2023-05-26 10:22:16','2023-05-26 10:22:16'),('84','4','对https的了解？为什么安全','3','3',NULL,'HTTPS其实就是在HTTP跟TCP中间加多了一层加密层TLS/SSL。SSL是个加密套件，负责对HTTP的数据进行加密。TLS是SSL的升级版。现在提到HTTPS，加密套件基本指的是TLS。原先是应用层将数据直接给到TCP进行传输，现在改成应用层将数据给到TLS/SSL，将数据加密后，再给到TCP进行传输。',NULL,'1','1','1','1','2023-05-25 13:27:14','2023-05-25 13:27:14'),('85','1','3*0.1 ==0.3 将会返画什么? true 还是false?','3','2',NULL,') False, 因为有些浮点数不能完全精确的表示出来',NULL,'1','1','1','1','2023-05-25 13:27:14','2023-05-25 13:27:14'),('86','1','实现模拟登录的方式','3','1',NULL,'1)使用一个具有登录状态的cookie，结合请求报头一起发送，可以直接发送get请求，访问登录后才能访问的页面。2)先发送登录界面的get请求，在登录页面HTML里获取登录需要的数据（如果需要的话），然后结合账户密码，再发送post请求，即可登录成功。然后根据获取的cookie信息，继续访问之后的页面。3) 如果有验证码，还需要处理验证码',NULL,'1','1','1','1','2023-05-25 13:27:14','2023-05-25 13:27:14'),('87','1','int 和Integer 哪个会占用更多的内存?','3','3',NULL,'a) Integer 对象会占用更多的内存。Integer 是一个对象，需要存储对象的元数据。b) 但是 int 是一个原始类型的数据，所以占用的空间更少。',NULL,'1','1','1','1','2023-05-25 13:27:14','2023-05-25 13:27:14'),('88','1','a==b和&quot;a.equals(b)有什么区别','3','3',NULL,'a) a 和 b 都是对象，则 a==b 是比较两个对象的引用，只有当 a 和 b 指向的是堆中的同一个对象才会返回 true，而 a.equals(b) 是进行逻辑比较，当内容相同时，返回true，所以通常需要重写该方法来提供逻辑一致性的比较。例如，String 类重写 equals() 方法，所以可以用于两个不同对象，但是包含的字母相同的比较。',NULL,'1','1','1','1','2023-05-25 13:27:14','2023-05-25 13:27:14'),('89','1','加入solr索引库存满了，怎么办？','3','5',NULL,'在data-config.xml文件&lt;dataSource&gt;标签里添加batchSize=&quot;-1&quot;；',NULL,'1','1','1','1','2023-05-25 13:27:14','2023-05-25 13:27:14'),('9','3','new_请用BeautifulSoup或者Xpath任一方式找到以下id标签里面的内容？&lt;aclass=\"sister\"href=\"http://example.com/elsie\"id=\"link1\"&gt;Elsie&lt;/a&gt;','3','2',NULL,'html.xpath(\"//a[@id=\'link1\']\")',NULL,'1','1','1','3','2023-05-25 13:27:14','2023-05-25 13:27:14'),('90','1','反爬虫措施？','3','2',NULL,'1.添加代理2.降低访问频率3.User-Agent4.动态HTML数据加载5.验证码处理',NULL,'1','1','1','1','2023-05-25 13:27:14','2023-05-25 13:27:14'),('91','1','Java序列化与反序列化是什么？为什么需要序列化与反序列化？如何实现Java序列化与反序列化？','3','1',NULL,'序列化：把对象转换为字节序列的过程称为对象的序列化。反序列化：把字节序列恢复为对象的过程称为对象的反序列化。当你想把的内存中的对象状态保存到一个文件中或者数据库中时候；当你想用套接字在网络上传送对象的时候；当你想通过RMI传输对象的时候；都需要序列化；实现Serializable接口即可实现序列化',NULL,'1','1','1','1','2023-05-25 13:27:14','2023-05-25 13:27:14'),('92','1','写一个原型链继承的例子','3','1',NULL,'functionA(){　　this.name=&quot;zhangsan&quot;;}A.prototype.getName=function(){　　returnthis.name;}functionB(){　　this.age=20;}',NULL,'1','1','1','1','2022-08-21 17:21:16','2022-08-21 17:21:16'),('93','1','final.finalize 和finally 的区别','3','3',NULL,'a) final为用于标识常量的关键字，final标识的关键字存储在常量池中（在这里final常量的具体用法将在下面进行介绍）；b) finalize()方法在Object中进行了定义，用于在对象&ldquo;消失&rdquo;时，由JVM进行调用用于对对象进行垃圾回收，类似于C++中的析构函数；用户自定义时，用于释放对象占用的资源（比如进行I/0操作）；c) finally{}用于标识代码块，与try{}进行配合，不论try中的代码执行完或没有执行完（这里指有异常），该代码块之中的程序必定会进行；',NULL,'1','1','1','1','2023-05-26 10:22:16','2023-05-26 10:22:16'),('94','1','举例说说几个排序，并说明其排序原理','3','1',NULL,'冒泡、快速、二分等等，拿个冒泡举个例子/** 冒泡排序*/public class BubbleSort {　　public static void main(String[] args) {　　　　int[] arr={6,3,8,2,9,1};　　　　System.out.println(&quot;排序前数组为：&quot;);　　　　for(int num:arr){　　　　　　System.out.print(num+&quot; &quot;);　　　　}　　　　for(int i=0;i&lt;arr.length-1;i++){//外层循环控制排序趟数　　　　　　for(int j=0;j&lt;arr.length-1-i;j++){//内层循环控制每一趟排序多少次　　　　　　　　if(arr[j]&gt;arr[j+1]){　　　　',NULL,'1','1','1','1','2023-05-25 13:27:14','2023-05-25 13:27:14'),('95','1','谈谈你对NIO的理解','3','1',NULL,'NIO 的创建目的是为了让 Java 程序员可以实现高速 I/O 而无需编写自定义的本机代码。NIO 将最耗时的 I/O 操作(即填充和提取缓冲区)转移回操作系统，因而可以极大地提高速度。NIO最重要的组成部分通道 Channels缓冲区 Buffers选择器 SelectorsBuffer 是一个对象， 它包含一些要写入或者刚读出的数据。Channel是一个对象，可以通过它读取和写入数据',NULL,'1','1','1','1','2023-05-25 13:27:14','2023-05-25 13:27:14'),('96','1','List.Set.Map 和Queue之间的区别','3','3',NULL,'a) list 和set 有共同的父类 它们的用法也是一样的 唯一的不太就是set中不能有相同的元素 list中可以b) list和set的用途非常广泛 list可以完全代替数组来使用c) map 是独立的合集 它使用键值对的方式来储存数据 键不能有重复的 值可以用d) map不像上边两种集合那个用的广泛 不过在servlet 和jsp中 map可是绝对的重中之重 页面之间传值全靠map',NULL,'1','1','1','1','2023-05-25 13:27:14','2023-05-25 13:27:14'),('97','1','.随便说说几个单例模式，并选择一种线程安全的','3','1',NULL,'（懒汉，线程安全）：public class SingletonDemo2 {  private static SingletonDemo2 instance;  private SingletonDemo2(){}  public static synchronized SingletonDemo2 getInstance(){    if (instance == null) {      instance = new SingletonDemo2();    }    return instance;  }}<',NULL,'1','1','1','1','2023-05-25 13:27:14','2023-05-25 13:27:14'),('98','1','描述new一个对象的过程','3','1',NULL,'1.定义构造函数；2.通过new来创建对象实例。当我们使用new新建一个对象的时候，以newfoo(...)为例：1.一个新的对象被创建，同时继承了对象类型的原型，即foo.prototype；2.执行对象类型的构造函数，同时该实例的属性和方法被this所引用，即this指向新构造的实例；3.如果构造函数return了一个新的&ldquo;对象&rdquo;，那么这个对象就会取代整个new出来的结果。如果构造函数没有return对象，那么就会返回步骤1所创建的对象，即隐式返回this。（一般情况下构造函数不会返回任何值，不过在一些特殊情况下，如果用户想',NULL,'1','1','1','1','2023-05-25 13:27:14','2023-05-25 13:27:14'),('99','1','重写equals为何要重写hashCode？','3','1',NULL,'不重写hashcode，equals方法还是用的原始的==',NULL,'1','1','1','1','2023-05-25 13:27:14','2023-05-25 13:27:14');
/*!40000 ALTER TABLE `question` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `question_item`
--

DROP TABLE IF EXISTS `question_item`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `question_item` (
  `id` varchar(100) NOT NULL COMMENT '选项的唯一标识id',
  `questionId` varchar(100) DEFAULT NULL COMMENT '所属的题目id',
  `content` varchar(200) DEFAULT NULL COMMENT '选项内容',
  `isRight` varchar(10) DEFAULT NULL COMMENT '是否正确答案 ： 0 不是 ，1 是',
  PRIMARY KEY (`id`),
  KEY `FK_question_id` (`questionId`),
  CONSTRAINT `FK_question_id` FOREIGN KEY (`questionId`) REFERENCES `question` (`id`) ON DELETE CASCADE
) COMMENT='题目选项表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `question_item`
--

LOCK TABLES `question_item` WRITE;
/*!40000 ALTER TABLE `question_item` DISABLE KEYS */;
INSERT INTO `question_item` VALUES ('1','3','new Thread(){ 	 public void run() { 	System.out.println(\"ThreadOne重写run方法！！\"); 	 } };','0'),('10','5','Lambda表达式的参数列表 ，没有参数时小括号可省略。','1'),('100','662','','0'),('101','662','','0'),('102','662','','1'),('103','662','','0'),('104','664','11xx','0'),('105','664','22xx','1'),('106','664','33xx','0'),('107','664','44tttt','0'),('108','665','11xxaaa','1'),('109','665','22xxxxxxxxxxxx','1'),('11','5','Lambda表达式的都是延迟执行。	 ','0'),('110','665','33xx','0'),('111','665','44tttt','0'),('112','666','11xxaaa','1'),('113','666','22xxxxxxxxxxxx','1'),('114','666','33xx','0'),('115','666','44tttt','0'),('116','667','','1'),('117','667','','0'),('118','667','','0'),('119','667','','0'),('12','5','Lambda表达式的参数列表的 参数数据类型可以省略。','0'),('120','668','aa','0'),('121','668','bb','1'),('122','668','cc','1'),('123','668','dd','0'),('124','669','','0'),('125','670','ss','0'),('126','670','ss','1'),('127','670','dd','0'),('128','670','dd','0'),('129','670','dd','0'),('13','6','是一种直接或间接地调用自身的算法。','1'),('14','6','使程序变得简洁','1'),('15','6','递归的次数对程序的运行没有任何影响','0'),('16','6','递归一定要有条件限定，保证递归能够停止下来','1'),('17','7','<? extends E> E包括E的子类，也叫向上限定。','1'),('18','7','<? super E> E包括E的父类，也叫向下限定。','1'),('19','7','泛型的上限：只能接收该类型及其子类。','1'),('2','3','class ThreadOne extends Thread{ 	 public void run() { 	System.out.println(\"ThreadOne重写run方法！！\"); 	 } }','0'),('20','7','泛型的下限：只能接收该类型及其父类型。','1'),('3','3','class ThreadOne extends Runnable{ 	 public void run() { 	 System.out.println(\"ThreadOne重写run方法！！\"); 	 } }','1'),('37','639','必须有接口且接口中只有一个抽象方法。','0'),('38','639','Lambda表达式的参数列表 ，没有参数时小括号可省略。','1'),('39','639','Lambda表达式的都是延迟执行。	 ','0'),('4','3','new Thread(new Runnable() { 	public void run() { 	System.out.println(\"ThreadOne重写run方法！！\"); 	} 	  } 	);','0'),('40','639','Lambda表达式的参数列表的 参数数据类型可以省略。','0'),('41','642','必须有接口且接口中只有一个抽象方法。','1'),('42','642','Lambda表达式的参数列表 ，没有参数时小括号可省略。','1'),('43','642','Lambda表达式的都是延迟执行。	 ','1'),('44','642','Lambda表达式的参数列表的 参数数据类型可以省略。','1'),('45','641','Lambda表达式的参数列表的 参数数据类型可以省略-new 。','0'),('46','634','Lambda表达式的参数列表的 参数数据类型可以省略-new 。','0'),('47','635','Lambda表达式的参数列表的 参数数据类型可以省略-new 。','0'),('49','638','Lambda表达式的参数列表的 参数数据类型可以省略-new 。','0'),('5','4','重写Object类的toString（）方法是为了方便打印对象的地址值。','0'),('50','639','Lambda表达式的参数列表的 参数数据类型可以省略-new 。','0'),('52','643','','0'),('53','643','','0'),('54','643','','0'),('55','643','','0'),('56','643','','0'),('57','643','','0'),('58','644','b1','1'),('59','644','b2','1'),('6','4','重写Object类的equals（）方法是为了比较对象的地址值。','0'),('60','644','b3','0'),('61','644','b4','0'),('62','644','','0'),('63','644','','0'),('64','646','c1','1'),('65','646','c2','1'),('66','646','c3','1'),('67','646','c4','0'),('68','651','','0'),('69','651','','1'),('7','4','未重写Object类的equals()方法默认是比较对象中的属性值。	 ','0'),('70','651','','0'),('71','651','','0'),('72','654','','0'),('73','654','','0'),('74','654','','0'),('75','654','','0'),('76','655','','0'),('77','655','','0'),('78','655','','1'),('79','655','','0'),('8','4','重写Object类的toString()方法是方便打印对象中的属性值 。','1'),('80','656','','0'),('81','656','','0'),('82','656','','0'),('83','656','','0'),('84','657','a','0'),('85','657','b','1'),('86','657','c','0'),('87','657','d','0'),('88','658','aaaaa','1'),('89','658','bbbb','0'),('9','5','必须有接口且接口中只有一个抽象方法。','0'),('90','658','cccc','0'),('91','658','ddd','0'),('92','660','ddd1','1'),('93','660','de2','1'),('94','660','d3','1'),('95','660','d3','0'),('96','661','新的多选多选\nA','1'),('97','661','新的多选多选\nB','1'),('98','661','新的多选多选','0'),('99','661','新的多选多选','0'),('be0de4dc0f4a4e9293b565bf9926475b','01406E951164496CBA7A29FC91DF5246','bbb','1'),('D0B60454464C40BD995115B3B9BA20BA','01406E951164496CBA7A29FC91DF5246','ddd','1');
/*!40000 ALTER TABLE `question_item` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `role`
--

DROP TABLE IF EXISTS `role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `role` (
  `id` varchar(40) NOT NULL COMMENT '角色Id',
  `name` varchar(30) DEFAULT NULL COMMENT '角色名称',
  `remark` varchar(200) DEFAULT NULL COMMENT '备注信息',
  `createTime` datetime DEFAULT NULL COMMENT '添加时间',
  `updateTime` datetime DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`)
) COMMENT='角色表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `role`
--

LOCK TABLES `role` WRITE;
/*!40000 ALTER TABLE `role` DISABLE KEYS */;
INSERT INTO `role` VALUES ('4028a1c34ec2e5c8014ec2ebf8430001','系统维护管理员','日常系统维护管理人员，账户异常处理，忘记密码重置等等','2023-05-31 16:01:33','2023-05-31 16:01:33'),('4028a1c34ec2e5c8014ec2ec38cc0002','题目审核员','负责题目审核，包括题干和选项','2023-05-31 16:01:33','2023-05-31 16:01:33'),('4028a1cd4ee2d9d6014ee2df4c6a0000','题目录入员','负责题目录入','2023-05-31 16:01:33','2023-05-31 16:01:33'),('4028a1cd4ee2d9d6014ee2df4c6a0001','超级管理员（慎用）','sysadmin，超级管理员，为系统最高权限','2023-05-31 16:01:33','2023-05-31 16:01:33'),('8c247fe4-e208-4032-bcbc-8717df8119a2','试题评分员','负责评分','2023-05-31 16:01:33','2023-05-31 17:01:33');
/*!40000 ALTER TABLE `role` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `role_module`
--

DROP TABLE IF EXISTS `role_module`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `role_module` (
  `roleId` varchar(255) NOT NULL DEFAULT '' COMMENT '角色id',
  `moduleId` varchar(255) NOT NULL DEFAULT '' COMMENT '模块id',
  PRIMARY KEY (`roleId`,`moduleId`),
  KEY `FK_Reference_6` (`moduleId`),
  CONSTRAINT `FK_Reference_5` FOREIGN KEY (`roleId`) REFERENCES `role` (`id`) ON DELETE CASCADE,
  CONSTRAINT `FK_Reference_6` FOREIGN KEY (`moduleId`) REFERENCES `module` (`id`) ON DELETE CASCADE
) COMMENT='角色模块关系表(中间表)';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `role_module`
--

LOCK TABLES `role_module` WRITE;
/*!40000 ALTER TABLE `role_module` DISABLE KEYS */;
INSERT INTO `role_module` VALUES ('4028a1c34ec2e5c8014ec2ebf8430001','1'),('4028a1cd4ee2d9d6014ee2df4c6a0001','1'),('4028a1c34ec2e5c8014ec2ebf8430001','101'),('4028a1cd4ee2d9d6014ee2df4c6a0001','101'),('4028a1c34ec2e5c8014ec2ebf8430001','102'),('4028a1cd4ee2d9d6014ee2df4c6a0001','102'),('4028a1c34ec2e5c8014ec2ebf8430001','103'),('4028a1cd4ee2d9d6014ee2df4c6a0001','103'),('4028a1c34ec2e5c8014ec2ebf8430001','104'),('4028a1cd4ee2d9d6014ee2df4c6a0001','104'),('4028a1c34ec2e5c8014ec2ebf8430001','105'),('4028a1cd4ee2d9d6014ee2df4c6a0001','105'),('4028a1c34ec2e5c8014ec2ebf8430001','106'),('4028a1cd4ee2d9d6014ee2df4c6a0001','106'),('4028a1c34ec2e5c8014ec2ebf8430001','2'),('4028a1c34ec2e5c8014ec2ec38cc0002','2'),('4028a1cd4ee2d9d6014ee2df4c6a0000','2'),('4028a1cd4ee2d9d6014ee2df4c6a0001','2'),('4028a1c34ec2e5c8014ec2ebf8430001','201'),('4028a1c34ec2e5c8014ec2ec38cc0002','201'),('4028a1cd4ee2d9d6014ee2df4c6a0000','201'),('4028a1cd4ee2d9d6014ee2df4c6a0001','201'),('4028a1c34ec2e5c8014ec2ebf8430001','202'),('4028a1c34ec2e5c8014ec2ec38cc0002','202'),('4028a1cd4ee2d9d6014ee2df4c6a0000','202'),('4028a1cd4ee2d9d6014ee2df4c6a0001','202'),('4028a1c34ec2e5c8014ec2ebf8430001','203'),('4028a1c34ec2e5c8014ec2ec38cc0002','203'),('4028a1cd4ee2d9d6014ee2df4c6a0000','203'),('4028a1cd4ee2d9d6014ee2df4c6a0001','203'),('4028a1c34ec2e5c8014ec2ebf8430001','204'),('4028a1c34ec2e5c8014ec2ec38cc0002','204'),('4028a1cd4ee2d9d6014ee2df4c6a0000','204'),('4028a1cd4ee2d9d6014ee2df4c6a0001','204'),('4028a1cd4ee2d9d6014ee2df4c6a0001','3'),('4028a1cd4ee2d9d6014ee2df4c6a0001','301'),('4028a1cd4ee2d9d6014ee2df4c6a0001','302');
/*!40000 ALTER TABLE `role_module` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `sys_log`
--

DROP TABLE IF EXISTS `sys_log`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `sys_log` (
  `id` varchar(40) NOT NULL COMMENT '唯一标识id',
  `username` varchar(30) DEFAULT NULL COMMENT '操作人用户名',
  `ip` varchar(20) DEFAULT NULL COMMENT '操作人的IP地址',
  `time` datetime DEFAULT NULL COMMENT '操作时间',
  `method` varchar(100) DEFAULT NULL COMMENT '操作的方法名',
  `action` varchar(100) DEFAULT NULL COMMENT '访问的地址',
  PRIMARY KEY (`id`)
) COMMENT='系统日志表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `sys_log`
--

LOCK TABLES `sys_log` WRITE;
/*!40000 ALTER TABLE `sys_log` DISABLE KEYS */;
INSERT INTO `sys_log` VALUES ('05111F64939940F9B9B447BB96D48E48','cgx','0:0:0:0:0:0:0:1','2020-03-08 17:29:42','main','http://localhost:8998/heima_mm_advance/login?operation=main'),('05690FAB0B1F4F4BBDB21A2E62FCD9C9','cgx','0:0:0:0:0:0:0:1','2020-03-08 17:31:39','home','http://localhost:8998/heima_mm_advance/login?operation=home'),('168969F2F5D14414852ACE2403A03EC7','cgx','0:0:0:0:0:0:0:1','2020-03-08 17:48:22','list','http://localhost:8998/heima_mm_advance/front/examinationPaper?operation=list');
/*!40000 ALTER TABLE `sys_log` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `user`
--

DROP TABLE IF EXISTS `user`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `user` (
  `id` varchar(40) NOT NULL COMMENT '员工Id',
  `email` varchar(60) DEFAULT NULL COMMENT '邮箱',
  `username` varchar(50) DEFAULT NULL COMMENT '不能重复,可为中文',
  `password` varchar(64) DEFAULT NULL COMMENT 'shiro MD5密码32位',
  `state` decimal(11,0) DEFAULT NULL COMMENT '1启用0停用',
  `gender` char(1) DEFAULT NULL COMMENT '性别，0：男，1：女',
  `telephone` varchar(11) DEFAULT NULL COMMENT '手机号',
  `birthday` varchar(20) DEFAULT NULL COMMENT '生日',
  `joinDate` varchar(20) DEFAULT NULL COMMENT '入职日期',
  `deptId` varchar(40) DEFAULT NULL COMMENT '所属部门id',
  `createTime` datetime DEFAULT NULL COMMENT '添加时间',
  `updateTime` datetime DEFAULT NULL COMMENT '修改时间',
  PRIMARY KEY (`id`),
  KEY `SYS_C005467` (`deptId`),
  CONSTRAINT `SYS_C005467` FOREIGN KEY (`deptId`) REFERENCES `dept` (`id`)
) COMMENT='用户表';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `user`
--

LOCK TABLES `user` WRITE;
/*!40000 ALTER TABLE `user` DISABLE KEYS */;
INSERT INTO `user` VALUES ('002108e2-9a10-4510-9683-8d8fd1d374ef','admin@itcast.cn','admin','202cb962ac59075b964b07152d234b70',1,'0','12345678','1989-01-06 00:00:00','2019-02-26 00:00:00','100101','2023-05-31 16:03:16','2023-05-31 16:03:16'),('0514e280620740878541d0387a2ec701','zyd@itcast.cn','张益达','202cb962ac59075b964b07152d234b70',1,'1','17666668888','2020-10-01','2020-10-30','100105','2023-05-31 16:03:16','2023-05-31 16:03:16'),('27b8c988-8314-464c-84cf-c0e160a5a853','liutao@ppd.cn','刘涛','202cb962ac59075b964b07152d234b70',1,'1','12312341234','2020-10-01','2020-10-03','100','2023-05-31 16:03:16','2023-05-31 16:03:16'),('735730bf-3ac0-4690-882d-100178d58ff9','zbz@export.com','张柏芝','202cb962ac59075b964b07152d234b70',1,'1','13800138013','1989-01-06 00:00:00','2016-03-22 00:00:00','100','2023-05-31 16:03:16','2023-05-31 16:03:16'),('74af665326ad4dedaf38797f99ba73ca','xwt@itcast.cn','向问天','202cb962ac59075b964b07152d234b70',1,'1','17666668888','2020-10-01','2020-10-30','100106','2023-05-31 16:03:16','2023-05-31 16:03:16'),('ca592c7c-860a-464c-8f56-ea51b42a046f','baitu@export.com','白图','202cb962ac59075b964b07152d234b70',1,'1','13800138021','1977-11-09 00:00:00','2014-06-06 00:00:00','100101','2023-05-31 16:03:16','2023-05-31 16:03:16'),('cf0015d3-bcdd-433b-889d-808b53b72640','zhangwei@itheima.com','张伟','202cb962ac59075b964b07152d234b70',1,'1','13800138022','1984-08-13 00:00:00','2010-01-05 00:00:00','100','2023-05-31 16:03:16','2023-05-31 16:03:16'),('e0de22fe-2c50-4216-ad75-ed0494d2dc92','cg@itheima.com','陈刚','202cb962ac59075b964b07152d234b70',1,'0','13800138023','1981-01-13 00:00:00','2011-09-16 00:00:00','100101','2023-05-31 16:03:16','2023-05-31 16:03:16'),('ef1f631d-76c8-4837-9ad9-f5f6209e4463','zwj@export.com','张无忌','202cb962ac59075b964b07152d234b70',1,'1','13800138025','1988-07-26 00:00:00','2013-02-20 00:00:00','100','2023-05-31 16:03:16','2023-05-31 16:03:16');
/*!40000 ALTER TABLE `user` ENABLE KEYS */;
UNLOCK TABLES;

--
-- Table structure for table `user_role`
--

DROP TABLE IF EXISTS `user_role`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `user_role` (
  `userId` varchar(255) NOT NULL COMMENT '用户id',
  `roleId` varchar(255) NOT NULL COMMENT '角色id',
  PRIMARY KEY (`roleId`,`userId`),
  KEY `SYS_C005471` (`userId`),
  CONSTRAINT `FK_Reference_3` FOREIGN KEY (`userId`) REFERENCES `user` (`id`),
  CONSTRAINT `FK_Reference_4` FOREIGN KEY (`roleId`) REFERENCES `role` (`id`)
) COMMENT='用户角色关系表(中间表)';
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `user_role`
--

LOCK TABLES `user_role` WRITE;
/*!40000 ALTER TABLE `user_role` DISABLE KEYS */;
INSERT INTO `user_role` VALUES ('002108e2-9a10-4510-9683-8d8fd1d374ef','4028a1cd4ee2d9d6014ee2df4c6a0001'),('0514e280620740878541d0387a2ec701','4028a1c34ec2e5c8014ec2ebf8430001');
/*!40000 ALTER TABLE `user_role` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2023-06-05  7:59:02
